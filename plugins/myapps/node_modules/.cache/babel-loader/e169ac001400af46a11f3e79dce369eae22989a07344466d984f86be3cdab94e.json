{"ast":null,"code":"import _defineProperty from \"/data/stackhub-web/plugins/myapps/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _slicedToArray from \"/data/stackhub-web/plugins/myapps/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport * as ReactDOM from 'react-dom';\nimport { globalWidthBreakpoints, globalHeightBreakpoints, SIDE } from './constants';\n/**\n * @param {string} input - String to capitalize first letter\n */\nexport function capitalize(input) {\n  return input[0].toUpperCase() + input.substring(1);\n}\n/**\n * @param {string} prefix - String to prefix ID with\n */\nexport function getUniqueId() {\n  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'pf';\n  var uid = new Date().getTime() + Math.random().toString(36).slice(2);\n  return \"\".concat(prefix, \"-\").concat(uid);\n}\n/**\n * @param { any } this - \"This\" reference\n * @param { Function } func - Function to debounce\n * @param { number } wait - Debounce amount\n */\nexport function debounce(func, wait) {\n  var _this = this;\n  var timeout;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      return func.apply(_this, args);\n    }, wait);\n  };\n}\n/** This function returns whether or not an element is within the viewable area of a container. If partial is true,\n * then this function will return true even if only part of the element is in view.\n *\n * @param {HTMLElement} container  The container to check if the element is in view of.\n * @param {HTMLElement} element    The element to check if it is view\n * @param {boolean} partial   true if partial view is allowed\n * @param {boolean} strict    true if strict mode is set, never consider the container width and element width\n *\n * @returns { boolean } True if the component is in View.\n */\nexport function isElementInView(container, element, partial) {\n  var strict = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  if (!container || !element) {\n    return false;\n  }\n  var containerBounds = container.getBoundingClientRect();\n  var elementBounds = element.getBoundingClientRect();\n  var containerBoundsLeft = Math.ceil(containerBounds.left);\n  var containerBoundsRight = Math.floor(containerBounds.right);\n  var elementBoundsLeft = Math.ceil(elementBounds.left);\n  var elementBoundsRight = Math.floor(elementBounds.right);\n  // Check if in view\n  var isTotallyInView = elementBoundsLeft >= containerBoundsLeft && elementBoundsRight <= containerBoundsRight;\n  var isPartiallyInView = (partial || !strict && containerBounds.width < elementBounds.width) && (elementBoundsLeft < containerBoundsLeft && elementBoundsRight > containerBoundsLeft || elementBoundsRight > containerBoundsRight && elementBoundsLeft < containerBoundsRight);\n  // Return outcome\n  return isTotallyInView || isPartiallyInView;\n}\n/** This function returns the side the element is out of view on (right, left or both)\n *\n * @param {HTMLElement} container    The container to check if the element is in view of.\n * @param {HTMLElement} element      The element to check if it is view\n *\n * @returns {string} right if the element is of the right, left if element is off the left or both if it is off on both sides.\n */\nexport function sideElementIsOutOfView(container, element) {\n  var containerBounds = container.getBoundingClientRect();\n  var elementBounds = element.getBoundingClientRect();\n  var containerBoundsLeft = Math.floor(containerBounds.left);\n  var containerBoundsRight = Math.floor(containerBounds.right);\n  var elementBoundsLeft = Math.floor(elementBounds.left);\n  var elementBoundsRight = Math.floor(elementBounds.right);\n  // Check if in view\n  var isOffLeft = elementBoundsLeft < containerBoundsLeft;\n  var isOffRight = elementBoundsRight > containerBoundsRight;\n  var side = SIDE.NONE;\n  if (isOffRight && isOffLeft) {\n    side = SIDE.BOTH;\n  } else if (isOffRight) {\n    side = SIDE.RIGHT;\n  } else if (isOffLeft) {\n    side = SIDE.LEFT;\n  }\n  // Return outcome\n  return side;\n}\n/** Interpolates a parameterized templateString using values from a templateVars object.\n * The templateVars object should have keys and values which match the templateString's parameters.\n * Example:\n *    const templateString: 'My name is ${firstName} ${lastName}';\n *    const templateVars: {\n *      firstName: 'Jon'\n *      lastName: 'Dough'\n *    };\n *    const result = fillTemplate(templateString, templateVars);\n *    // \"My name is Jon Dough\"\n *\n * @param {string} templateString  The string passed by the consumer\n * @param {object} templateVars The variables passed to the string\n *\n * @returns {string} The template string literal result\n */\nexport function fillTemplate(templateString, templateVars) {\n  return templateString.replace(/\\${(.*?)}/g, function (_, match) {\n    return templateVars[match] || '';\n  });\n}\n/**\n * This function allows for keyboard navigation through dropdowns. The custom argument is optional.\n *\n * @param {number} index The index of the element you're on\n * @param {number} innerIndex Inner index number\n * @param {string} position The orientation of the dropdown\n * @param {string[]} refsCollection Array of refs to the items in the dropdown\n * @param {object[]} kids Array of items in the dropdown\n * @param {boolean} [custom] Allows for handling of flexible content\n */\nexport function keyHandler(index, innerIndex, position, refsCollection, kids) {\n  var custom = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  if (!Array.isArray(kids)) {\n    return;\n  }\n  var isMultiDimensional = refsCollection.filter(function (ref) {\n    return ref;\n  })[0].constructor === Array;\n  var nextIndex = index;\n  var nextInnerIndex = innerIndex;\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = kids.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (position === 'down') {\n    if (index === kids.length - 1) {\n      // loop back to beginning\n      nextIndex = 0;\n    } else {\n      nextIndex = index + 1;\n    }\n  } else if (position === 'left') {\n    if (innerIndex === 0) {\n      nextInnerIndex = refsCollection[index].length - 1;\n    } else {\n      nextInnerIndex = innerIndex - 1;\n    }\n  } else if (position === 'right') {\n    if (innerIndex === refsCollection[index].length - 1) {\n      nextInnerIndex = 0;\n    } else {\n      nextInnerIndex = innerIndex + 1;\n    }\n  }\n  if (refsCollection[nextIndex] === null || refsCollection[nextIndex] === undefined || isMultiDimensional && (refsCollection[nextIndex][nextInnerIndex] === null || refsCollection[nextIndex][nextInnerIndex] === undefined)) {\n    keyHandler(nextIndex, nextInnerIndex, position, refsCollection, kids, custom);\n  } else if (custom) {\n    if (refsCollection[nextIndex].focus) {\n      refsCollection[nextIndex].focus();\n    }\n    // eslint-disable-next-line react/no-find-dom-node\n    var element = ReactDOM.findDOMNode(refsCollection[nextIndex]);\n    element.focus();\n  } else if (position !== 'tab') {\n    if (isMultiDimensional) {\n      refsCollection[nextIndex][nextInnerIndex].focus();\n    } else {\n      refsCollection[nextIndex].focus();\n    }\n  }\n}\n/** This function returns a list of tabbable items in a container\n *\n *  @param {any} containerRef to the container\n *  @param {string} tababbleSelectors CSS selector string of tabbable items\n */\nexport function findTabbableElements(containerRef, tababbleSelectors) {\n  var tabbable = containerRef.current.querySelectorAll(tababbleSelectors);\n  var list = Array.prototype.filter.call(tabbable, function (item) {\n    return item.tabIndex >= '0';\n  });\n  return list;\n}\n/** This function is a helper for keyboard navigation through dropdowns.\n *\n * @param {number} index The index of the element you're on\n * @param {string} position The orientation of the dropdown\n * @param {string[]} collection Array of refs to the items in the dropdown\n */\nexport function getNextIndex(index, position, collection) {\n  var nextIndex;\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = collection.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (index === collection.length - 1) {\n    // loop back to beginning\n    nextIndex = 0;\n  } else {\n    nextIndex = index + 1;\n  }\n  if (collection[nextIndex] === undefined || collection[nextIndex][0] === null) {\n    return getNextIndex(nextIndex, position, collection);\n  } else {\n    return nextIndex;\n  }\n}\n/** This function is a helper for pluralizing strings.\n *\n * @param {number} i The quantity of the string you want to pluralize\n * @param {string} singular The singular version of the string\n * @param {string} plural The change to the string that should occur if the quantity is not equal to 1.\n *                 Defaults to adding an 's'.\n */\nexport function pluralize(i, singular, plural) {\n  if (!plural) {\n    plural = \"\".concat(singular, \"s\");\n  }\n  return \"\".concat(i || 0, \" \").concat(i === 1 ? singular : plural);\n}\n/**\n * This function is a helper for turning arrays of breakpointMod objects for flex and grid into style object\n *\n * @param {object} mods The modifiers object\n * @param {string} css-variable The appropriate css variable for the component\n */\nexport var setBreakpointCssVars = function setBreakpointCssVars(mods, cssVar) {\n  return Object.entries(mods || {}).reduce(function (acc, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      breakpoint = _ref2[0],\n      value = _ref2[1];\n    return breakpoint === 'default' ? Object.assign(Object.assign({}, acc), _defineProperty({}, cssVar, value)) : Object.assign(Object.assign({}, acc), _defineProperty({}, \"\".concat(cssVar, \"-on-\").concat(breakpoint), value));\n  }, {});\n};\n/**\n * This function is a helper for turning arrays of breakpointMod objects for data toolbar and flex into classes\n *\n * @param {object} mods The modifiers object\n * @param {any} styles The appropriate styles object for the component\n */\nexport var formatBreakpointMods = function formatBreakpointMods(mods, styles) {\n  var stylePrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  var breakpoint = arguments.length > 3 ? arguments[3] : undefined;\n  var vertical = arguments.length > 4 ? arguments[4] : undefined;\n  if (!mods) {\n    return '';\n  }\n  if (breakpoint && !vertical) {\n    if (breakpoint in mods) {\n      return styles.modifiers[toCamel(\"\".concat(stylePrefix).concat(mods[breakpoint]))];\n    }\n    // the current breakpoint is not specified in mods, so we try to find the next nearest\n    var breakpointsOrder = ['2xl', 'xl', 'lg', 'md', 'sm', 'default'];\n    var breakpointsIndex = breakpointsOrder.indexOf(breakpoint);\n    for (var i = breakpointsIndex; i < breakpointsOrder.length; i++) {\n      if (breakpointsOrder[i] in mods) {\n        return styles.modifiers[toCamel(\"\".concat(stylePrefix).concat(mods[breakpointsOrder[i]]))];\n      }\n    }\n    return '';\n  }\n  return Object.entries(mods || {}).map(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n      breakpoint = _ref4[0],\n      mod = _ref4[1];\n    return \"\".concat(stylePrefix).concat(mod).concat(breakpoint !== 'default' ? \"-on-\".concat(breakpoint) : '').concat(vertical && breakpoint !== 'default' ? '-height' : '');\n  }).map(toCamel).map(function (mod) {\n    return mod.replace(/-?(\\dxl)/gi, function (_res, group) {\n      return \"_\".concat(group);\n    });\n  }).map(function (modifierKey) {\n    return styles.modifiers[modifierKey];\n  }).filter(Boolean).join(' ');\n};\n/**\n * Return the breakpoint for the given height\n *\n * @param {number | null} height The height to check\n * @returns {'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl'} The breakpoint\n */\nexport var getVerticalBreakpoint = function getVerticalBreakpoint(height) {\n  if (height === null) {\n    return null;\n  }\n  if (height >= globalHeightBreakpoints['2xl']) {\n    return '2xl';\n  }\n  if (height >= globalHeightBreakpoints.xl) {\n    return 'xl';\n  }\n  if (height >= globalHeightBreakpoints.lg) {\n    return 'lg';\n  }\n  if (height >= globalHeightBreakpoints.md) {\n    return 'md';\n  }\n  if (height >= globalHeightBreakpoints.sm) {\n    return 'sm';\n  }\n  return 'default';\n};\n/**\n * Return the breakpoint for the given width\n *\n * @param {number | null} width The width to check\n * @returns {'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl'} The breakpoint\n */\nexport var getBreakpoint = function getBreakpoint(width) {\n  if (width === null) {\n    return null;\n  }\n  if (width >= globalWidthBreakpoints['2xl']) {\n    return '2xl';\n  }\n  if (width >= globalWidthBreakpoints.xl) {\n    return 'xl';\n  }\n  if (width >= globalWidthBreakpoints.lg) {\n    return 'lg';\n  }\n  if (width >= globalWidthBreakpoints.md) {\n    return 'md';\n  }\n  if (width >= globalWidthBreakpoints.sm) {\n    return 'sm';\n  }\n  return 'default';\n};\nvar camelize = function camelize(s) {\n  return s.toUpperCase().replace('-', '').replace('_', '');\n};\n/**\n *\n * @param {string} s string to make camelCased\n */\nexport var toCamel = function toCamel(s) {\n  return s.replace(/([-_][a-z])/gi, camelize);\n};\n/**\n * Copied from exenv\n */\nexport var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n/**\n * Calculate the width of the text\n * Example:\n * getTextWidth('my text', node)\n *\n * @param {string} text The text to calculate the width for\n * @param {HTMLElement} node The HTML element\n */\nexport var getTextWidth = function getTextWidth(text, node) {\n  var computedStyle = getComputedStyle(node);\n  // Firefox returns the empty string for .font, so this function creates the .font property manually\n  var getFontFromComputedStyle = function getFontFromComputedStyle() {\n    var computedFont = '';\n    // Firefox uses percentages for font-stretch, but Canvas does not accept percentages\n    // so convert to keywords, as listed at:\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/font-stretch\n    var fontStretchLookupTable = {\n      '50%': 'ultra-condensed',\n      '62.5%': 'extra-condensed',\n      '75%': 'condensed',\n      '87.5%': 'semi-condensed',\n      '100%': 'normal',\n      '112.5%': 'semi-expanded',\n      '125%': 'expanded',\n      '150%': 'extra-expanded',\n      '200%': 'ultra-expanded'\n    };\n    // If the retrieved font-stretch percentage isn't found in the lookup table, use\n    // 'normal' as a last resort.\n    var fontStretch;\n    if (computedStyle.fontStretch in fontStretchLookupTable) {\n      fontStretch = fontStretchLookupTable[computedStyle.fontStretch];\n    } else {\n      fontStretch = 'normal';\n    }\n    computedFont = computedStyle.fontStyle + ' ' + computedStyle.fontVariant + ' ' + computedStyle.fontWeight + ' ' + fontStretch + ' ' + computedStyle.fontSize + '/' + computedStyle.lineHeight + ' ' + computedStyle.fontFamily;\n    return computedFont;\n  };\n  var canvas = document.createElement('canvas');\n  var context = canvas.getContext('2d');\n  context.font = computedStyle.font || getFontFromComputedStyle();\n  return context.measureText(text).width;\n};\n/**\n * Get the inner dimensions of an element\n *\n * @param {HTMLElement} node HTML element to calculate the inner dimensions for\n */\nexport var innerDimensions = function innerDimensions(node) {\n  var computedStyle = getComputedStyle(node);\n  var width = node.clientWidth; // width with padding\n  var height = node.clientHeight; // height with padding\n  height -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);\n  width -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  return {\n    height: height,\n    width: width\n  };\n};\n/**\n * This function is a helper for truncating text content on the left, leaving the right side of the content in view\n *\n * @param {HTMLElement} node HTML element\n * @param {string} value The original text value\n */\nexport var trimLeft = function trimLeft(node, value) {\n  var availableWidth = innerDimensions(node).width;\n  var newValue = value;\n  if (getTextWidth(value, node) > availableWidth) {\n    // we have text overflow, trim the text to the left and add ... in the front until it fits\n    while (getTextWidth(\"...\".concat(newValue), node) > availableWidth) {\n      newValue = newValue.substring(1);\n    }\n    // replace text with our truncated text\n    if (node.value) {\n      node.value = \"...\".concat(newValue);\n    } else {\n      node.innerText = \"...\".concat(newValue);\n    }\n  } else {\n    if (node.value) {\n      node.value = value;\n    } else {\n      node.innerText = value;\n    }\n  }\n};\n/**\n * @param {string[]} events - Operations to prevent when disabled\n */\nexport var preventedEvents = function preventedEvents(events) {\n  return events.reduce(function (handlers, eventToPrevent) {\n    return Object.assign(Object.assign({}, handlers), _defineProperty({}, eventToPrevent, function (event) {\n      event.preventDefault();\n    }));\n  }, {});\n};","map":{"version":3,"names":["ReactDOM","globalWidthBreakpoints","globalHeightBreakpoints","SIDE","capitalize","input","toUpperCase","substring","getUniqueId","prefix","arguments","length","undefined","uid","Date","getTime","Math","random","toString","slice","concat","debounce","func","wait","_this","timeout","_len","args","Array","_key","clearTimeout","setTimeout","apply","isElementInView","container","element","partial","strict","containerBounds","getBoundingClientRect","elementBounds","containerBoundsLeft","ceil","left","containerBoundsRight","floor","right","elementBoundsLeft","elementBoundsRight","isTotallyInView","isPartiallyInView","width","sideElementIsOutOfView","isOffLeft","isOffRight","side","NONE","BOTH","RIGHT","LEFT","fillTemplate","templateString","templateVars","replace","_","match","keyHandler","index","innerIndex","position","refsCollection","kids","custom","isArray","isMultiDimensional","filter","ref","constructor","nextIndex","nextInnerIndex","focus","findDOMNode","findTabbableElements","containerRef","tababbleSelectors","tabbable","current","querySelectorAll","list","prototype","call","item","tabIndex","getNextIndex","collection","pluralize","i","singular","plural","setBreakpointCssVars","mods","cssVar","Object","entries","reduce","acc","_ref","_ref2","_slicedToArray","breakpoint","value","assign","_defineProperty","formatBreakpointMods","styles","stylePrefix","vertical","modifiers","toCamel","breakpointsOrder","breakpointsIndex","indexOf","map","_ref3","_ref4","mod","_res","group","modifierKey","Boolean","join","getVerticalBreakpoint","height","xl","lg","md","sm","getBreakpoint","camelize","s","canUseDOM","window","document","createElement","getTextWidth","text","node","computedStyle","getComputedStyle","getFontFromComputedStyle","computedFont","fontStretchLookupTable","fontStretch","fontStyle","fontVariant","fontWeight","fontSize","lineHeight","fontFamily","canvas","context","getContext","font","measureText","innerDimensions","clientWidth","clientHeight","parseFloat","paddingTop","paddingBottom","paddingLeft","paddingRight","trimLeft","availableWidth","newValue","innerText","preventedEvents","events","handlers","eventToPrevent","event","preventDefault"],"sources":["/data/stackhub-web/plugins/myapps/node_modules/@patternfly/react-core/src/helpers/util.ts"],"sourcesContent":["import * as ReactDOM from 'react-dom';\nimport { globalWidthBreakpoints, globalHeightBreakpoints, SIDE } from './constants';\n\n/**\n * @param {string} input - String to capitalize first letter\n */\nexport function capitalize(input: string) {\n  return input[0].toUpperCase() + input.substring(1);\n}\n\n/**\n * @param {string} prefix - String to prefix ID with\n */\nexport function getUniqueId(prefix = 'pf') {\n  const uid =\n    new Date().getTime() +\n    Math.random()\n      .toString(36)\n      .slice(2);\n  return `${prefix}-${uid}`;\n}\n\n/**\n * @param { any } this - \"This\" reference\n * @param { Function } func - Function to debounce\n * @param { number } wait - Debounce amount\n */\nexport function debounce(this: any, func: (...args: any[]) => any, wait: number) {\n  let timeout: number;\n  return (...args: any[]) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func.apply(this, args), wait) as any;\n  };\n}\n\n/** This function returns whether or not an element is within the viewable area of a container. If partial is true,\n * then this function will return true even if only part of the element is in view.\n *\n * @param {HTMLElement} container  The container to check if the element is in view of.\n * @param {HTMLElement} element    The element to check if it is view\n * @param {boolean} partial   true if partial view is allowed\n * @param {boolean} strict    true if strict mode is set, never consider the container width and element width\n *\n * @returns { boolean } True if the component is in View.\n */\nexport function isElementInView(\n  container: HTMLElement,\n  element: HTMLElement,\n  partial: boolean,\n  strict: boolean = false\n): boolean {\n  if (!container || !element) {\n    return false;\n  }\n  const containerBounds = container.getBoundingClientRect();\n  const elementBounds = element.getBoundingClientRect();\n  const containerBoundsLeft = Math.ceil(containerBounds.left);\n  const containerBoundsRight = Math.floor(containerBounds.right);\n  const elementBoundsLeft = Math.ceil(elementBounds.left);\n  const elementBoundsRight = Math.floor(elementBounds.right);\n\n  // Check if in view\n  const isTotallyInView = elementBoundsLeft >= containerBoundsLeft && elementBoundsRight <= containerBoundsRight;\n  const isPartiallyInView =\n    (partial || (!strict && containerBounds.width < elementBounds.width)) &&\n    ((elementBoundsLeft < containerBoundsLeft && elementBoundsRight > containerBoundsLeft) ||\n      (elementBoundsRight > containerBoundsRight && elementBoundsLeft < containerBoundsRight));\n\n  // Return outcome\n  return isTotallyInView || isPartiallyInView;\n}\n\n/** This function returns the side the element is out of view on (right, left or both)\n *\n * @param {HTMLElement} container    The container to check if the element is in view of.\n * @param {HTMLElement} element      The element to check if it is view\n *\n * @returns {string} right if the element is of the right, left if element is off the left or both if it is off on both sides.\n */\nexport function sideElementIsOutOfView(container: HTMLElement, element: HTMLElement): string {\n  const containerBounds = container.getBoundingClientRect();\n  const elementBounds = element.getBoundingClientRect();\n  const containerBoundsLeft = Math.floor(containerBounds.left);\n  const containerBoundsRight = Math.floor(containerBounds.right);\n  const elementBoundsLeft = Math.floor(elementBounds.left);\n  const elementBoundsRight = Math.floor(elementBounds.right);\n\n  // Check if in view\n  const isOffLeft = elementBoundsLeft < containerBoundsLeft;\n  const isOffRight = elementBoundsRight > containerBoundsRight;\n\n  let side = SIDE.NONE;\n\n  if (isOffRight && isOffLeft) {\n    side = SIDE.BOTH;\n  } else if (isOffRight) {\n    side = SIDE.RIGHT;\n  } else if (isOffLeft) {\n    side = SIDE.LEFT;\n  }\n  // Return outcome\n  return side;\n}\n\n/** Interpolates a parameterized templateString using values from a templateVars object.\n * The templateVars object should have keys and values which match the templateString's parameters.\n * Example:\n *    const templateString: 'My name is ${firstName} ${lastName}';\n *    const templateVars: {\n *      firstName: 'Jon'\n *      lastName: 'Dough'\n *    };\n *    const result = fillTemplate(templateString, templateVars);\n *    // \"My name is Jon Dough\"\n *\n * @param {string} templateString  The string passed by the consumer\n * @param {object} templateVars The variables passed to the string\n *\n * @returns {string} The template string literal result\n */\nexport function fillTemplate(templateString: string, templateVars: any) {\n  return templateString.replace(/\\${(.*?)}/g, (_, match) => templateVars[match] || '');\n}\n\n/**\n * This function allows for keyboard navigation through dropdowns. The custom argument is optional.\n *\n * @param {number} index The index of the element you're on\n * @param {number} innerIndex Inner index number\n * @param {string} position The orientation of the dropdown\n * @param {string[]} refsCollection Array of refs to the items in the dropdown\n * @param {object[]} kids Array of items in the dropdown\n * @param {boolean} [custom] Allows for handling of flexible content\n */\nexport function keyHandler(\n  index: number,\n  innerIndex: number,\n  position: string,\n  refsCollection: any[],\n  kids: any[],\n  custom = false\n) {\n  if (!Array.isArray(kids)) {\n    return;\n  }\n  const isMultiDimensional = refsCollection.filter(ref => ref)[0].constructor === Array;\n  let nextIndex = index;\n  let nextInnerIndex = innerIndex;\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = kids.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (position === 'down') {\n    if (index === kids.length - 1) {\n      // loop back to beginning\n      nextIndex = 0;\n    } else {\n      nextIndex = index + 1;\n    }\n  } else if (position === 'left') {\n    if (innerIndex === 0) {\n      nextInnerIndex = refsCollection[index].length - 1;\n    } else {\n      nextInnerIndex = innerIndex - 1;\n    }\n  } else if (position === 'right') {\n    if (innerIndex === refsCollection[index].length - 1) {\n      nextInnerIndex = 0;\n    } else {\n      nextInnerIndex = innerIndex + 1;\n    }\n  }\n  if (\n    refsCollection[nextIndex] === null ||\n    refsCollection[nextIndex] === undefined ||\n    (isMultiDimensional &&\n      (refsCollection[nextIndex][nextInnerIndex] === null || refsCollection[nextIndex][nextInnerIndex] === undefined))\n  ) {\n    keyHandler(nextIndex, nextInnerIndex, position, refsCollection, kids, custom);\n  } else if (custom) {\n    if (refsCollection[nextIndex].focus) {\n      refsCollection[nextIndex].focus();\n    }\n    // eslint-disable-next-line react/no-find-dom-node\n    const element = ReactDOM.findDOMNode(refsCollection[nextIndex]) as HTMLElement;\n    element.focus();\n  } else if (position !== 'tab') {\n    if (isMultiDimensional) {\n      refsCollection[nextIndex][nextInnerIndex].focus();\n    } else {\n      refsCollection[nextIndex].focus();\n    }\n  }\n}\n\n/** This function returns a list of tabbable items in a container\n *\n *  @param {any} containerRef to the container\n *  @param {string} tababbleSelectors CSS selector string of tabbable items\n */\nexport function findTabbableElements(containerRef: any, tababbleSelectors: string): any[] {\n  const tabbable = containerRef.current.querySelectorAll(tababbleSelectors);\n  const list = Array.prototype.filter.call(tabbable, function(item) {\n    return item.tabIndex >= '0';\n  });\n  return list;\n}\n\n/** This function is a helper for keyboard navigation through dropdowns.\n *\n * @param {number} index The index of the element you're on\n * @param {string} position The orientation of the dropdown\n * @param {string[]} collection Array of refs to the items in the dropdown\n */\nexport function getNextIndex(index: number, position: string, collection: any[]): number {\n  let nextIndex;\n  if (position === 'up') {\n    if (index === 0) {\n      // loop back to end\n      nextIndex = collection.length - 1;\n    } else {\n      nextIndex = index - 1;\n    }\n  } else if (index === collection.length - 1) {\n    // loop back to beginning\n    nextIndex = 0;\n  } else {\n    nextIndex = index + 1;\n  }\n  if (collection[nextIndex] === undefined || collection[nextIndex][0] === null) {\n    return getNextIndex(nextIndex, position, collection);\n  } else {\n    return nextIndex;\n  }\n}\n\n/** This function is a helper for pluralizing strings.\n *\n * @param {number} i The quantity of the string you want to pluralize\n * @param {string} singular The singular version of the string\n * @param {string} plural The change to the string that should occur if the quantity is not equal to 1.\n *                 Defaults to adding an 's'.\n */\nexport function pluralize(i: number, singular: string, plural?: string) {\n  if (!plural) {\n    plural = `${singular}s`;\n  }\n  return `${i || 0} ${i === 1 ? singular : plural}`;\n}\n\n/**\n * This function is a helper for turning arrays of breakpointMod objects for flex and grid into style object\n *\n * @param {object} mods The modifiers object\n * @param {string} css-variable The appropriate css variable for the component\n */\nexport const setBreakpointCssVars = (\n  mods: {\n    default?: string;\n    sm?: string;\n    md?: string;\n    lg?: string;\n    xl?: string;\n    '2xl'?: string;\n    '3xl'?: string;\n  },\n  cssVar: string\n): React.CSSProperties =>\n  Object.entries(mods || {}).reduce(\n    (acc, [breakpoint, value]) =>\n      breakpoint === 'default' ? { ...acc, [cssVar]: value } : { ...acc, [`${cssVar}-on-${breakpoint}`]: value },\n    {}\n  );\n\nexport interface Mods {\n  default?: string;\n  sm?: string;\n  md?: string;\n  lg?: string;\n  xl?: string;\n  '2xl'?: string;\n  '3xl'?: string;\n}\n\n/**\n * This function is a helper for turning arrays of breakpointMod objects for data toolbar and flex into classes\n *\n * @param {object} mods The modifiers object\n * @param {any} styles The appropriate styles object for the component\n */\nexport const formatBreakpointMods = (\n  mods: Mods,\n  styles: any,\n  stylePrefix: string = '',\n  breakpoint?: 'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl',\n  vertical?: boolean\n) => {\n  if (!mods) {\n    return '';\n  }\n  if (breakpoint && !vertical) {\n    if (breakpoint in mods) {\n      return styles.modifiers[toCamel(`${stylePrefix}${mods[breakpoint as keyof Mods]}`)];\n    }\n    // the current breakpoint is not specified in mods, so we try to find the next nearest\n    const breakpointsOrder = ['2xl', 'xl', 'lg', 'md', 'sm', 'default'];\n    const breakpointsIndex = breakpointsOrder.indexOf(breakpoint);\n    for (let i = breakpointsIndex; i < breakpointsOrder.length; i++) {\n      if (breakpointsOrder[i] in mods) {\n        return styles.modifiers[toCamel(`${stylePrefix}${mods[breakpointsOrder[i] as keyof Mods]}`)];\n      }\n    }\n    return '';\n  }\n\n  return Object.entries(mods || {})\n    .map(\n      ([breakpoint, mod]) =>\n        `${stylePrefix}${mod}${breakpoint !== 'default' ? `-on-${breakpoint}` : ''}${\n          vertical && breakpoint !== 'default' ? '-height' : ''\n        }`\n    )\n    .map(toCamel)\n    .map(mod => mod.replace(/-?(\\dxl)/gi, (_res, group) => `_${group}`))\n    .map(modifierKey => styles.modifiers[modifierKey])\n    .filter(Boolean)\n    .join(' ');\n};\n\n/**\n * Return the breakpoint for the given height\n *\n * @param {number | null} height The height to check\n * @returns {'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl'} The breakpoint\n */\nexport const getVerticalBreakpoint = (height: number): 'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl' => {\n  if (height === null) {\n    return null;\n  }\n  if (height >= globalHeightBreakpoints['2xl']) {\n    return '2xl';\n  }\n  if (height >= globalHeightBreakpoints.xl) {\n    return 'xl';\n  }\n  if (height >= globalHeightBreakpoints.lg) {\n    return 'lg';\n  }\n  if (height >= globalHeightBreakpoints.md) {\n    return 'md';\n  }\n  if (height >= globalHeightBreakpoints.sm) {\n    return 'sm';\n  }\n  return 'default';\n};\n\n/**\n * Return the breakpoint for the given width\n *\n * @param {number | null} width The width to check\n * @returns {'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl'} The breakpoint\n */\nexport const getBreakpoint = (width: number): 'default' | 'sm' | 'md' | 'lg' | 'xl' | '2xl' => {\n  if (width === null) {\n    return null;\n  }\n  if (width >= globalWidthBreakpoints['2xl']) {\n    return '2xl';\n  }\n  if (width >= globalWidthBreakpoints.xl) {\n    return 'xl';\n  }\n  if (width >= globalWidthBreakpoints.lg) {\n    return 'lg';\n  }\n  if (width >= globalWidthBreakpoints.md) {\n    return 'md';\n  }\n  if (width >= globalWidthBreakpoints.sm) {\n    return 'sm';\n  }\n  return 'default';\n};\n\nconst camelize = (s: string) =>\n  s\n    .toUpperCase()\n    .replace('-', '')\n    .replace('_', '');\n/**\n *\n * @param {string} s string to make camelCased\n */\nexport const toCamel = (s: string) => s.replace(/([-_][a-z])/gi, camelize);\n\n/**\n * Copied from exenv\n */\nexport const canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\n/**\n * Calculate the width of the text\n * Example:\n * getTextWidth('my text', node)\n *\n * @param {string} text The text to calculate the width for\n * @param {HTMLElement} node The HTML element\n */\nexport const getTextWidth = (text: string, node: HTMLElement) => {\n  const computedStyle = getComputedStyle(node);\n  // Firefox returns the empty string for .font, so this function creates the .font property manually\n  const getFontFromComputedStyle = () => {\n    let computedFont = '';\n    // Firefox uses percentages for font-stretch, but Canvas does not accept percentages\n    // so convert to keywords, as listed at:\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/font-stretch\n    const fontStretchLookupTable = {\n      '50%': 'ultra-condensed',\n      '62.5%': 'extra-condensed',\n      '75%': 'condensed',\n      '87.5%': 'semi-condensed',\n      '100%': 'normal',\n      '112.5%': 'semi-expanded',\n      '125%': 'expanded',\n      '150%': 'extra-expanded',\n      '200%': 'ultra-expanded'\n    };\n    // If the retrieved font-stretch percentage isn't found in the lookup table, use\n    // 'normal' as a last resort.\n    let fontStretch;\n    if (computedStyle.fontStretch in fontStretchLookupTable) {\n      fontStretch = (fontStretchLookupTable as any)[computedStyle.fontStretch];\n    } else {\n      fontStretch = 'normal';\n    }\n    computedFont =\n      computedStyle.fontStyle +\n      ' ' +\n      computedStyle.fontVariant +\n      ' ' +\n      computedStyle.fontWeight +\n      ' ' +\n      fontStretch +\n      ' ' +\n      computedStyle.fontSize +\n      '/' +\n      computedStyle.lineHeight +\n      ' ' +\n      computedStyle.fontFamily;\n    return computedFont;\n  };\n\n  const canvas = document.createElement('canvas');\n  const context = canvas.getContext('2d');\n  context.font = computedStyle.font || getFontFromComputedStyle();\n\n  return context.measureText(text).width;\n};\n\n/**\n * Get the inner dimensions of an element\n *\n * @param {HTMLElement} node HTML element to calculate the inner dimensions for\n */\nexport const innerDimensions = (node: HTMLElement) => {\n  const computedStyle = getComputedStyle(node);\n\n  let width = node.clientWidth; // width with padding\n  let height = node.clientHeight; // height with padding\n\n  height -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);\n  width -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  return { height, width };\n};\n\n/**\n * This function is a helper for truncating text content on the left, leaving the right side of the content in view\n *\n * @param {HTMLElement} node HTML element\n * @param {string} value The original text value\n */\nexport const trimLeft = (node: HTMLElement, value: string) => {\n  const availableWidth = innerDimensions(node).width;\n  let newValue = value;\n  if (getTextWidth(value, node) > availableWidth) {\n    // we have text overflow, trim the text to the left and add ... in the front until it fits\n    while (getTextWidth(`...${newValue}`, node) > availableWidth) {\n      newValue = newValue.substring(1);\n    }\n    // replace text with our truncated text\n    if ((node as HTMLInputElement).value) {\n      (node as HTMLInputElement).value = `...${newValue}`;\n    } else {\n      node.innerText = `...${newValue}`;\n    }\n  } else {\n    if ((node as HTMLInputElement).value) {\n      (node as HTMLInputElement).value = value;\n    } else {\n      node.innerText = value;\n    }\n  }\n};\n\n/**\n * @param {string[]} events - Operations to prevent when disabled\n */\nexport const preventedEvents = (events: string[]) =>\n  events.reduce(\n    (handlers, eventToPrevent) => ({\n      ...handlers,\n      [eventToPrevent]: (event: React.SyntheticEvent<HTMLElement>) => {\n        event.preventDefault();\n      }\n    }),\n    {}\n  );\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}