{"ast":null,"code":"import getBoundingClientRect from '../dom-utils/getBoundingClientRect';\nimport getClippingRect from '../dom-utils/getClippingRect';\nimport getDocumentElement from '../dom-utils/getDocumentElement';\nimport computeOffsets from './computeOffsets';\nimport rectToClientRect from './rectToClientRect';\nimport { clippingParents, reference, popper, bottom, top, right, basePlacements, viewport } from '../enums';\nimport { isElement } from '../dom-utils/instanceOf';\nimport mergePaddingObject from './mergePaddingObject';\nimport expandToHashMap from './expandToHashMap';\n/**\n * @param state\n * @param options\n */\nexport default function detectOverflow(state) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$placement = options.placement,\n    placement = _options$placement === void 0 ? state.placement : _options$placement,\n    _options$boundary = options.boundary,\n    boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n    _options$rootBoundary = options.rootBoundary,\n    rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n    _options$elementConte = options.elementContext,\n    elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n    _options$altBoundary = options.altBoundary,\n    altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n    _options$padding = options.padding,\n    padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  var altContext = elementContext === popper ? reference : popper;\n  var referenceElement = state.elements.reference;\n  var popperRect = state.rects.popper;\n  var element = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n  var referenceClientRect = getBoundingClientRect(referenceElement);\n  var popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement: placement\n  });\n  var popperClientRect = rectToClientRect(Object.assign(Object.assign({}, popperRect), popperOffsets));\n  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;\n  // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset;\n  // Offsets can be applied only to the popper element\n  if (elementContext === popper && offsetData) {\n    var offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function (key) {\n      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n  return overflowOffsets;\n}","map":{"version":3,"names":["getBoundingClientRect","getClippingRect","getDocumentElement","computeOffsets","rectToClientRect","clippingParents","reference","popper","bottom","top","right","basePlacements","viewport","isElement","mergePaddingObject","expandToHashMap","detectOverflow","state","options","arguments","length","undefined","_options$placement","placement","_options$boundary","boundary","_options$rootBoundary","rootBoundary","_options$elementConte","elementContext","_options$altBoundary","altBoundary","_options$padding","padding","paddingObject","altContext","referenceElement","elements","popperRect","rects","element","clippingClientRect","contextElement","referenceClientRect","popperOffsets","strategy","popperClientRect","Object","assign","elementClientRect","overflowOffsets","left","offsetData","modifiersData","offset","keys","forEach","key","multiply","indexOf","axis"],"sources":["/data/stackhub-web/plugins/myapps/node_modules/@patternfly/react-core/src/helpers/Popper/thirdparty/popper-core/utils/detectOverflow.ts"],"sourcesContent":["// @ts-nocheck\nimport { State, SideObject, Padding } from '../types';\nimport { Placement, Boundary, RootBoundary, Context } from '../enums';\nimport getBoundingClientRect from '../dom-utils/getBoundingClientRect';\nimport getClippingRect from '../dom-utils/getClippingRect';\nimport getDocumentElement from '../dom-utils/getDocumentElement';\nimport computeOffsets from './computeOffsets';\nimport rectToClientRect from './rectToClientRect';\nimport { clippingParents, reference, popper, bottom, top, right, basePlacements, viewport } from '../enums';\nimport { isElement } from '../dom-utils/instanceOf';\nimport mergePaddingObject from './mergePaddingObject';\nimport expandToHashMap from './expandToHashMap';\n\n// eslint-disable-next-line import/no-unused-modules\nexport interface Options {\n  placement: Placement;\n  boundary: Boundary;\n  rootBoundary: RootBoundary;\n  elementContext: Context;\n  altBoundary: boolean;\n  padding: Padding;\n}\n\n/**\n * @param state\n * @param options\n */\nexport default function detectOverflow(state: State, options: Partial<Options> = {}): SideObject {\n  const {\n    placement = state.placement,\n    boundary = clippingParents,\n    rootBoundary = viewport,\n    elementContext = popper,\n    altBoundary = false,\n    padding = 0\n  } = options;\n\n  const paddingObject = mergePaddingObject(\n    typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements)\n  );\n\n  const altContext = elementContext === popper ? reference : popper;\n\n  const referenceElement = state.elements.reference;\n  const popperRect = state.rects.popper;\n  const element = state.elements[altBoundary ? altContext : elementContext];\n\n  const clippingClientRect = getClippingRect(\n    isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper),\n    boundary,\n    rootBoundary\n  );\n\n  const referenceClientRect = getBoundingClientRect(referenceElement);\n\n  const popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement\n  });\n\n  const popperClientRect = rectToClientRect({\n    ...popperRect,\n    ...popperOffsets\n  });\n\n  const elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;\n\n  // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n  const overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n\n  const offsetData = state.modifiersData.offset;\n\n  // Offsets can be applied only to the popper element\n  if (elementContext === popper && offsetData) {\n    const offset = offsetData[placement];\n\n    Object.keys(overflowOffsets).forEach(key => {\n      const multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      const axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}