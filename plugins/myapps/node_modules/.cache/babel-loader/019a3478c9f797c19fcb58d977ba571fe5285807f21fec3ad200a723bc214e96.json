{"ast":null,"code":"import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { isTypeDefinitionNode, isTypeExtensionNode } from \"../../language/predicates.mjs\";\nimport { specifiedDirectives } from \"../../type/directives.mjs\";\n\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all non-repeatable directives at\n * a given location are uniquely named.\n */\nexport function UniqueDirectivesPerLocationRule(context) {\n  var uniqueDirectiveMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {\n    var directive = definedDirectives[_i2];\n    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;\n  }\n  var astDefinitions = context.getDocument().definitions;\n  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {\n    var def = astDefinitions[_i4];\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      uniqueDirectiveMap[def.name.value] = !def.repeatable;\n    }\n  }\n  var schemaDirectives = Object.create(null);\n  var typeDirectivesMap = Object.create(null);\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter: function enter(node) {\n      if (node.directives == null) {\n        return;\n      }\n      var seenDirectives;\n      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {\n        seenDirectives = schemaDirectives;\n      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {\n        var typeName = node.name.value;\n        seenDirectives = typeDirectivesMap[typeName];\n        if (seenDirectives === undefined) {\n          typeDirectivesMap[typeName] = seenDirectives = Object.create(null);\n        }\n      } else {\n        seenDirectives = Object.create(null);\n      }\n      for (var _i6 = 0, _node$directives2 = node.directives; _i6 < _node$directives2.length; _i6++) {\n        var _directive = _node$directives2[_i6];\n        var directiveName = _directive.name.value;\n        if (uniqueDirectiveMap[directiveName]) {\n          if (seenDirectives[directiveName]) {\n            context.reportError(new GraphQLError(\"The directive \\\"@\".concat(directiveName, \"\\\" can only be used once at this location.\"), [seenDirectives[directiveName], _directive]));\n          } else {\n            seenDirectives[directiveName] = _directive;\n          }\n        }\n      }\n    }\n  };\n}","map":{"version":3,"names":["GraphQLError","Kind","isTypeDefinitionNode","isTypeExtensionNode","specifiedDirectives","UniqueDirectivesPerLocationRule","context","uniqueDirectiveMap","Object","create","schema","getSchema","definedDirectives","getDirectives","_i2","length","directive","name","isRepeatable","astDefinitions","getDocument","definitions","_i4","def","kind","DIRECTIVE_DEFINITION","value","repeatable","schemaDirectives","typeDirectivesMap","enter","node","directives","seenDirectives","SCHEMA_DEFINITION","SCHEMA_EXTENSION","typeName","undefined","_i6","_node$directives2","_directive","directiveName","reportError","concat"],"sources":["/data/stackhub-web/plugins/myapps/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs"],"sourcesContent":["import { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { Kind } from \"../../language/kinds.mjs\";\nimport { isTypeDefinitionNode, isTypeExtensionNode } from \"../../language/predicates.mjs\";\nimport { specifiedDirectives } from \"../../type/directives.mjs\";\n\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all non-repeatable directives at\n * a given location are uniquely named.\n */\nexport function UniqueDirectivesPerLocationRule(context) {\n  var uniqueDirectiveMap = Object.create(null);\n  var schema = context.getSchema();\n  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;\n\n  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {\n    var directive = definedDirectives[_i2];\n    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;\n  }\n\n  var astDefinitions = context.getDocument().definitions;\n\n  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {\n    var def = astDefinitions[_i4];\n\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      uniqueDirectiveMap[def.name.value] = !def.repeatable;\n    }\n  }\n\n  var schemaDirectives = Object.create(null);\n  var typeDirectivesMap = Object.create(null);\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter: function enter(node) {\n      if (node.directives == null) {\n        return;\n      }\n\n      var seenDirectives;\n\n      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {\n        seenDirectives = schemaDirectives;\n      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {\n        var typeName = node.name.value;\n        seenDirectives = typeDirectivesMap[typeName];\n\n        if (seenDirectives === undefined) {\n          typeDirectivesMap[typeName] = seenDirectives = Object.create(null);\n        }\n      } else {\n        seenDirectives = Object.create(null);\n      }\n\n      for (var _i6 = 0, _node$directives2 = node.directives; _i6 < _node$directives2.length; _i6++) {\n        var _directive = _node$directives2[_i6];\n        var directiveName = _directive.name.value;\n\n        if (uniqueDirectiveMap[directiveName]) {\n          if (seenDirectives[directiveName]) {\n            context.reportError(new GraphQLError(\"The directive \\\"@\".concat(directiveName, \"\\\" can only be used once at this location.\"), [seenDirectives[directiveName], _directive]));\n          } else {\n            seenDirectives[directiveName] = _directive;\n          }\n        }\n      }\n    }\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}