{"ast":null,"code":"import { Kind } from \"../language/kinds.mjs\";\nimport { visit } from \"../language/visitor.mjs\";\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\n\nexport function separateOperations(documentAST) {\n  var operations = [];\n  var depGraph = Object.create(null); // Populate metadata and build a dependency graph.\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var definitionNode = _documentAST$definiti2[_i2];\n    switch (definitionNode.kind) {\n      case Kind.OPERATION_DEFINITION:\n        operations.push(definitionNode);\n        break;\n      case Kind.FRAGMENT_DEFINITION:\n        depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);\n        break;\n    }\n  } // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n  var separatedDocumentASTs = Object.create(null);\n  var _loop = function _loop(_i4) {\n    var operation = operations[_i4];\n    var dependencies = new Set();\n    for (var _i6 = 0, _collectDependencies2 = collectDependencies(operation.selectionSet); _i6 < _collectDependencies2.length; _i6++) {\n      var fragmentName = _collectDependencies2[_i6];\n      collectTransitiveDependencies(dependencies, depGraph, fragmentName);\n    } // Provides the empty string for anonymous operations.\n\n    var operationName = operation.name ? operation.name.value : ''; // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(function (node) {\n        return node === operation || node.kind === Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value);\n      })\n    };\n  };\n  for (var _i4 = 0; _i4 < operations.length; _i4++) {\n    _loop(_i4);\n  }\n  return separatedDocumentASTs;\n}\n\n// From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  if (!collected.has(fromName)) {\n    collected.add(fromName);\n    var immediateDeps = depGraph[fromName];\n    if (immediateDeps !== undefined) {\n      for (var _i8 = 0; _i8 < immediateDeps.length; _i8++) {\n        var toName = immediateDeps[_i8];\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\nfunction collectDependencies(selectionSet) {\n  var dependencies = [];\n  visit(selectionSet, {\n    FragmentSpread: function FragmentSpread(node) {\n      dependencies.push(node.name.value);\n    }\n  });\n  return dependencies;\n}","map":{"version":3,"names":["Kind","visit","separateOperations","documentAST","operations","depGraph","Object","create","_i2","_documentAST$definiti2","definitions","length","definitionNode","kind","OPERATION_DEFINITION","push","FRAGMENT_DEFINITION","name","value","collectDependencies","selectionSet","separatedDocumentASTs","_loop","_i4","operation","dependencies","Set","_i6","_collectDependencies2","fragmentName","collectTransitiveDependencies","operationName","DOCUMENT","filter","node","has","collected","fromName","add","immediateDeps","undefined","_i8","toName","FragmentSpread"],"sources":["/data/stackhub-web/plugins/myapps/node_modules/graphql/utilities/separateOperations.mjs"],"sourcesContent":["import { Kind } from \"../language/kinds.mjs\";\nimport { visit } from \"../language/visitor.mjs\";\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\n\nexport function separateOperations(documentAST) {\n  var operations = [];\n  var depGraph = Object.create(null); // Populate metadata and build a dependency graph.\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var definitionNode = _documentAST$definiti2[_i2];\n\n    switch (definitionNode.kind) {\n      case Kind.OPERATION_DEFINITION:\n        operations.push(definitionNode);\n        break;\n\n      case Kind.FRAGMENT_DEFINITION:\n        depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);\n        break;\n    }\n  } // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n\n  var separatedDocumentASTs = Object.create(null);\n\n  var _loop = function _loop(_i4) {\n    var operation = operations[_i4];\n    var dependencies = new Set();\n\n    for (var _i6 = 0, _collectDependencies2 = collectDependencies(operation.selectionSet); _i6 < _collectDependencies2.length; _i6++) {\n      var fragmentName = _collectDependencies2[_i6];\n      collectTransitiveDependencies(dependencies, depGraph, fragmentName);\n    } // Provides the empty string for anonymous operations.\n\n\n    var operationName = operation.name ? operation.name.value : ''; // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(function (node) {\n        return node === operation || node.kind === Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value);\n      })\n    };\n  };\n\n  for (var _i4 = 0; _i4 < operations.length; _i4++) {\n    _loop(_i4);\n  }\n\n  return separatedDocumentASTs;\n}\n\n// From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  if (!collected.has(fromName)) {\n    collected.add(fromName);\n    var immediateDeps = depGraph[fromName];\n\n    if (immediateDeps !== undefined) {\n      for (var _i8 = 0; _i8 < immediateDeps.length; _i8++) {\n        var toName = immediateDeps[_i8];\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\n\nfunction collectDependencies(selectionSet) {\n  var dependencies = [];\n  visit(selectionSet, {\n    FragmentSpread: function FragmentSpread(node) {\n      dependencies.push(node.name.value);\n    }\n  });\n  return dependencies;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}