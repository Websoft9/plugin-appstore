{"ast":null,"code":"import didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isTypeDefinitionNode, isTypeSystemDefinitionNode, isTypeSystemExtensionNode } from \"../../language/predicates.mjs\";\nimport { specifiedScalarTypes } from \"../../type/scalars.mjs\";\nimport { introspectionTypes } from \"../../type/introspection.mjs\";\n\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n */\nexport function KnownTypeNamesRule(context) {\n  var schema = context.getSchema();\n  var existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  var definedTypes = Object.create(null);\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\n    var def = _context$getDocument$2[_i2];\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n  var typeNames = Object.keys(existingTypesMap).concat(Object.keys(definedTypes));\n  return {\n    NamedType: function NamedType(node, _1, parent, _2, ancestors) {\n      var typeName = node.name.value;\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var _ancestors$;\n        var definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;\n        var isSDL = definitionNode != null && isSDLNode(definitionNode);\n        if (isSDL && isStandardTypeName(typeName)) {\n          return;\n        }\n        var suggestedTypes = suggestionList(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);\n        context.reportError(new GraphQLError(\"Unknown type \\\"\".concat(typeName, \"\\\".\") + didYouMean(suggestedTypes), node));\n      }\n    }\n  };\n}\nvar standardTypeNames = [].concat(specifiedScalarTypes, introspectionTypes).map(function (type) {\n  return type.name;\n});\nfunction isStandardTypeName(typeName) {\n  return standardTypeNames.indexOf(typeName) !== -1;\n}\nfunction isSDLNode(value) {\n  return !Array.isArray(value) && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));\n}","map":{"version":3,"names":["didYouMean","suggestionList","GraphQLError","isTypeDefinitionNode","isTypeSystemDefinitionNode","isTypeSystemExtensionNode","specifiedScalarTypes","introspectionTypes","KnownTypeNamesRule","context","schema","getSchema","existingTypesMap","getTypeMap","Object","create","definedTypes","_i2","_context$getDocument$2","getDocument","definitions","length","def","name","value","typeNames","keys","concat","NamedType","node","_1","parent","_2","ancestors","typeName","_ancestors$","definitionNode","isSDL","isSDLNode","isStandardTypeName","suggestedTypes","standardTypeNames","reportError","map","type","indexOf","Array","isArray"],"sources":["/data/stackhub-web/plugins/myapps/node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs"],"sourcesContent":["import didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isTypeDefinitionNode, isTypeSystemDefinitionNode, isTypeSystemExtensionNode } from \"../../language/predicates.mjs\";\nimport { specifiedScalarTypes } from \"../../type/scalars.mjs\";\nimport { introspectionTypes } from \"../../type/introspection.mjs\";\n\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n */\nexport function KnownTypeNamesRule(context) {\n  var schema = context.getSchema();\n  var existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  var definedTypes = Object.create(null);\n\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\n    var def = _context$getDocument$2[_i2];\n\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n\n  var typeNames = Object.keys(existingTypesMap).concat(Object.keys(definedTypes));\n  return {\n    NamedType: function NamedType(node, _1, parent, _2, ancestors) {\n      var typeName = node.name.value;\n\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var _ancestors$;\n\n        var definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;\n        var isSDL = definitionNode != null && isSDLNode(definitionNode);\n\n        if (isSDL && isStandardTypeName(typeName)) {\n          return;\n        }\n\n        var suggestedTypes = suggestionList(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);\n        context.reportError(new GraphQLError(\"Unknown type \\\"\".concat(typeName, \"\\\".\") + didYouMean(suggestedTypes), node));\n      }\n    }\n  };\n}\nvar standardTypeNames = [].concat(specifiedScalarTypes, introspectionTypes).map(function (type) {\n  return type.name;\n});\n\nfunction isStandardTypeName(typeName) {\n  return standardTypeNames.indexOf(typeName) !== -1;\n}\n\nfunction isSDLNode(value) {\n  return !Array.isArray(value) && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}