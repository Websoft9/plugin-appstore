{"ast":null,"code":"import objectValues from \"../polyfills/objectValues.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport keyValMap from \"../jsutils/keyValMap.mjs\";\nimport isObjectLike from \"../jsutils/isObjectLike.mjs\";\nimport { parseValue } from \"../language/parser.mjs\";\nimport { GraphQLSchema } from \"../type/schema.mjs\";\nimport { GraphQLDirective } from \"../type/directives.mjs\";\nimport { specifiedScalarTypes } from \"../type/scalars.mjs\";\nimport { introspectionTypes, TypeKind } from \"../type/introspection.mjs\";\nimport { isInputType, isOutputType, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, assertNullableType, assertObjectType, assertInterfaceType } from \"../type/definition.mjs\";\nimport { valueFromAST } from \"./valueFromAST.mjs\";\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\n\nexport function buildClientSchema(introspection, options) {\n  isObjectLike(introspection) && isObjectLike(introspection.__schema) || devAssert(0, \"Invalid or incomplete introspection result. Ensure that you are passing \\\"data\\\" property of introspection response and no \\\"errors\\\" was returned alongside: \".concat(inspect(introspection), \".\")); // Get the schema from the introspection result.\n\n  var schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  var typeMap = keyValMap(schemaIntrospection.types, function (typeIntrospection) {\n    return typeIntrospection.name;\n  }, function (typeIntrospection) {\n    return buildType(typeIntrospection);\n  }); // Include standard types only if they are used.\n\n  for (var _i2 = 0, _ref2 = [].concat(specifiedScalarTypes, introspectionTypes); _i2 < _ref2.length; _i2++) {\n    var stdType = _ref2[_i2];\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    description: schemaIntrospection.description,\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: objectValues(typeMap),\n    directives: directives,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      var itemRef = typeRef.ofType;\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n      return new GraphQLList(getType(itemRef));\n    }\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      var nullableRef = typeRef.ofType;\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n      var nullableType = getType(nullableRef);\n      return new GraphQLNonNull(assertNullableType(nullableType));\n    }\n    return getNamedType(typeRef);\n  }\n  function getNamedType(typeRef) {\n    var typeName = typeRef.name;\n    if (!typeName) {\n      throw new Error(\"Unknown type reference: \".concat(inspect(typeRef), \".\"));\n    }\n    var type = typeMap[typeName];\n    if (!type) {\n      throw new Error(\"Invalid or incomplete schema, unknown type: \".concat(typeName, \". Ensure that a full introspection query is used in order to build a client schema.\"));\n    }\n    return type;\n  }\n  function getObjectType(typeRef) {\n    return assertObjectType(getNamedType(typeRef));\n  }\n  function getInterfaceType(typeRef) {\n    return assertInterfaceType(getNamedType(typeRef));\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n  function buildType(type) {\n    if (type != null && type.name != null && type.kind != null) {\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n    var typeStr = inspect(type);\n    throw new Error(\"Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: \".concat(typeStr, \".\"));\n  }\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      specifiedByUrl: scalarIntrospection.specifiedByUrl\n    });\n  }\n  function buildImplementationsList(implementingIntrospection) {\n    // TODO: Temporary workaround until GraphQL ecosystem will fully support\n    // 'interfaces' on interface types.\n    if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === TypeKind.INTERFACE) {\n      return [];\n    }\n    if (!implementingIntrospection.interfaces) {\n      var implementingIntrospectionStr = inspect(implementingIntrospection);\n      throw new Error(\"Introspection result missing interfaces: \".concat(implementingIntrospectionStr, \".\"));\n    }\n    return implementingIntrospection.interfaces.map(getInterfaceType);\n  }\n  function buildObjectDef(objectIntrospection) {\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: function interfaces() {\n        return buildImplementationsList(objectIntrospection);\n      },\n      fields: function fields() {\n        return buildFieldDefMap(objectIntrospection);\n      }\n    });\n  }\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      interfaces: function interfaces() {\n        return buildImplementationsList(interfaceIntrospection);\n      },\n      fields: function fields() {\n        return buildFieldDefMap(interfaceIntrospection);\n      }\n    });\n  }\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      var unionIntrospectionStr = inspect(unionIntrospection);\n      throw new Error(\"Introspection result missing possibleTypes: \".concat(unionIntrospectionStr, \".\"));\n    }\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: function types() {\n        return unionIntrospection.possibleTypes.map(getObjectType);\n      }\n    });\n  }\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      var enumIntrospectionStr = inspect(enumIntrospection);\n      throw new Error(\"Introspection result missing enumValues: \".concat(enumIntrospectionStr, \".\"));\n    }\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(enumIntrospection.enumValues, function (valueIntrospection) {\n        return valueIntrospection.name;\n      }, function (valueIntrospection) {\n        return {\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason\n        };\n      })\n    });\n  }\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      var inputObjectIntrospectionStr = inspect(inputObjectIntrospection);\n      throw new Error(\"Introspection result missing inputFields: \".concat(inputObjectIntrospectionStr, \".\"));\n    }\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: function fields() {\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n      }\n    });\n  }\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error(\"Introspection result missing fields: \".concat(inspect(typeIntrospection), \".\"));\n    }\n    return keyValMap(typeIntrospection.fields, function (fieldIntrospection) {\n      return fieldIntrospection.name;\n    }, buildField);\n  }\n  function buildField(fieldIntrospection) {\n    var type = getType(fieldIntrospection.type);\n    if (!isOutputType(type)) {\n      var typeStr = inspect(type);\n      throw new Error(\"Introspection must provide output type for fields, but received: \".concat(typeStr, \".\"));\n    }\n    if (!fieldIntrospection.args) {\n      var fieldIntrospectionStr = inspect(fieldIntrospection);\n      throw new Error(\"Introspection result missing field args: \".concat(fieldIntrospectionStr, \".\"));\n    }\n    return {\n      description: fieldIntrospection.description,\n      deprecationReason: fieldIntrospection.deprecationReason,\n      type: type,\n      args: buildInputValueDefMap(fieldIntrospection.args)\n    };\n  }\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(inputValueIntrospections, function (inputValue) {\n      return inputValue.name;\n    }, buildInputValue);\n  }\n  function buildInputValue(inputValueIntrospection) {\n    var type = getType(inputValueIntrospection.type);\n    if (!isInputType(type)) {\n      var typeStr = inspect(type);\n      throw new Error(\"Introspection must provide input type for arguments, but received: \".concat(typeStr, \".\"));\n    }\n    var defaultValue = inputValueIntrospection.defaultValue != null ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type: type,\n      defaultValue: defaultValue,\n      deprecationReason: inputValueIntrospection.deprecationReason\n    };\n  }\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      var directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(\"Introspection result missing directive args: \".concat(directiveIntrospectionStr, \".\"));\n    }\n    if (!directiveIntrospection.locations) {\n      var _directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(\"Introspection result missing directive locations: \".concat(_directiveIntrospectionStr, \".\"));\n    }\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      isRepeatable: directiveIntrospection.isRepeatable,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  }\n}","map":{"version":3,"names":["objectValues","inspect","devAssert","keyValMap","isObjectLike","parseValue","GraphQLSchema","GraphQLDirective","specifiedScalarTypes","introspectionTypes","TypeKind","isInputType","isOutputType","GraphQLList","GraphQLNonNull","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","assertNullableType","assertObjectType","assertInterfaceType","valueFromAST","buildClientSchema","introspection","options","__schema","concat","schemaIntrospection","typeMap","types","typeIntrospection","name","buildType","_i2","_ref2","length","stdType","queryType","getObjectType","mutationType","subscriptionType","directives","map","buildDirective","description","query","mutation","subscription","assumeValid","getType","typeRef","kind","LIST","itemRef","ofType","Error","NON_NULL","nullableRef","nullableType","getNamedType","typeName","type","getInterfaceType","SCALAR","buildScalarDef","OBJECT","buildObjectDef","INTERFACE","buildInterfaceDef","UNION","buildUnionDef","ENUM","buildEnumDef","INPUT_OBJECT","buildInputObjectDef","typeStr","scalarIntrospection","specifiedByUrl","buildImplementationsList","implementingIntrospection","interfaces","implementingIntrospectionStr","objectIntrospection","fields","buildFieldDefMap","interfaceIntrospection","unionIntrospection","possibleTypes","unionIntrospectionStr","enumIntrospection","enumValues","enumIntrospectionStr","values","valueIntrospection","deprecationReason","inputObjectIntrospection","inputFields","inputObjectIntrospectionStr","buildInputValueDefMap","fieldIntrospection","buildField","args","fieldIntrospectionStr","inputValueIntrospections","inputValue","buildInputValue","inputValueIntrospection","defaultValue","undefined","directiveIntrospection","directiveIntrospectionStr","locations","_directiveIntrospectionStr","isRepeatable","slice"],"sources":["/data/stackhub-web/plugins/myapps/node_modules/graphql/utilities/buildClientSchema.mjs"],"sourcesContent":["import objectValues from \"../polyfills/objectValues.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport keyValMap from \"../jsutils/keyValMap.mjs\";\nimport isObjectLike from \"../jsutils/isObjectLike.mjs\";\nimport { parseValue } from \"../language/parser.mjs\";\nimport { GraphQLSchema } from \"../type/schema.mjs\";\nimport { GraphQLDirective } from \"../type/directives.mjs\";\nimport { specifiedScalarTypes } from \"../type/scalars.mjs\";\nimport { introspectionTypes, TypeKind } from \"../type/introspection.mjs\";\nimport { isInputType, isOutputType, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, assertNullableType, assertObjectType, assertInterfaceType } from \"../type/definition.mjs\";\nimport { valueFromAST } from \"./valueFromAST.mjs\";\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\n\nexport function buildClientSchema(introspection, options) {\n  isObjectLike(introspection) && isObjectLike(introspection.__schema) || devAssert(0, \"Invalid or incomplete introspection result. Ensure that you are passing \\\"data\\\" property of introspection response and no \\\"errors\\\" was returned alongside: \".concat(inspect(introspection), \".\")); // Get the schema from the introspection result.\n\n  var schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  var typeMap = keyValMap(schemaIntrospection.types, function (typeIntrospection) {\n    return typeIntrospection.name;\n  }, function (typeIntrospection) {\n    return buildType(typeIntrospection);\n  }); // Include standard types only if they are used.\n\n  for (var _i2 = 0, _ref2 = [].concat(specifiedScalarTypes, introspectionTypes); _i2 < _ref2.length; _i2++) {\n    var stdType = _ref2[_i2];\n\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n\n  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    description: schemaIntrospection.description,\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: objectValues(typeMap),\n    directives: directives,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      var itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return new GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      var nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      var nullableType = getType(nullableRef);\n      return new GraphQLNonNull(assertNullableType(nullableType));\n    }\n\n    return getNamedType(typeRef);\n  }\n\n  function getNamedType(typeRef) {\n    var typeName = typeRef.name;\n\n    if (!typeName) {\n      throw new Error(\"Unknown type reference: \".concat(inspect(typeRef), \".\"));\n    }\n\n    var type = typeMap[typeName];\n\n    if (!type) {\n      throw new Error(\"Invalid or incomplete schema, unknown type: \".concat(typeName, \". Ensure that a full introspection query is used in order to build a client schema.\"));\n    }\n\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    return assertObjectType(getNamedType(typeRef));\n  }\n\n  function getInterfaceType(typeRef) {\n    return assertInterfaceType(getNamedType(typeRef));\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function buildType(type) {\n    if (type != null && type.name != null && type.kind != null) {\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    var typeStr = inspect(type);\n    throw new Error(\"Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: \".concat(typeStr, \".\"));\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      specifiedByUrl: scalarIntrospection.specifiedByUrl\n    });\n  }\n\n  function buildImplementationsList(implementingIntrospection) {\n    // TODO: Temporary workaround until GraphQL ecosystem will fully support\n    // 'interfaces' on interface types.\n    if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === TypeKind.INTERFACE) {\n      return [];\n    }\n\n    if (!implementingIntrospection.interfaces) {\n      var implementingIntrospectionStr = inspect(implementingIntrospection);\n      throw new Error(\"Introspection result missing interfaces: \".concat(implementingIntrospectionStr, \".\"));\n    }\n\n    return implementingIntrospection.interfaces.map(getInterfaceType);\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: function interfaces() {\n        return buildImplementationsList(objectIntrospection);\n      },\n      fields: function fields() {\n        return buildFieldDefMap(objectIntrospection);\n      }\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      interfaces: function interfaces() {\n        return buildImplementationsList(interfaceIntrospection);\n      },\n      fields: function fields() {\n        return buildFieldDefMap(interfaceIntrospection);\n      }\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      var unionIntrospectionStr = inspect(unionIntrospection);\n      throw new Error(\"Introspection result missing possibleTypes: \".concat(unionIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: function types() {\n        return unionIntrospection.possibleTypes.map(getObjectType);\n      }\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      var enumIntrospectionStr = inspect(enumIntrospection);\n      throw new Error(\"Introspection result missing enumValues: \".concat(enumIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(enumIntrospection.enumValues, function (valueIntrospection) {\n        return valueIntrospection.name;\n      }, function (valueIntrospection) {\n        return {\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason\n        };\n      })\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      var inputObjectIntrospectionStr = inspect(inputObjectIntrospection);\n      throw new Error(\"Introspection result missing inputFields: \".concat(inputObjectIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: function fields() {\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n      }\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error(\"Introspection result missing fields: \".concat(inspect(typeIntrospection), \".\"));\n    }\n\n    return keyValMap(typeIntrospection.fields, function (fieldIntrospection) {\n      return fieldIntrospection.name;\n    }, buildField);\n  }\n\n  function buildField(fieldIntrospection) {\n    var type = getType(fieldIntrospection.type);\n\n    if (!isOutputType(type)) {\n      var typeStr = inspect(type);\n      throw new Error(\"Introspection must provide output type for fields, but received: \".concat(typeStr, \".\"));\n    }\n\n    if (!fieldIntrospection.args) {\n      var fieldIntrospectionStr = inspect(fieldIntrospection);\n      throw new Error(\"Introspection result missing field args: \".concat(fieldIntrospectionStr, \".\"));\n    }\n\n    return {\n      description: fieldIntrospection.description,\n      deprecationReason: fieldIntrospection.deprecationReason,\n      type: type,\n      args: buildInputValueDefMap(fieldIntrospection.args)\n    };\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(inputValueIntrospections, function (inputValue) {\n      return inputValue.name;\n    }, buildInputValue);\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    var type = getType(inputValueIntrospection.type);\n\n    if (!isInputType(type)) {\n      var typeStr = inspect(type);\n      throw new Error(\"Introspection must provide input type for arguments, but received: \".concat(typeStr, \".\"));\n    }\n\n    var defaultValue = inputValueIntrospection.defaultValue != null ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type: type,\n      defaultValue: defaultValue,\n      deprecationReason: inputValueIntrospection.deprecationReason\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      var directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(\"Introspection result missing directive args: \".concat(directiveIntrospectionStr, \".\"));\n    }\n\n    if (!directiveIntrospection.locations) {\n      var _directiveIntrospectionStr = inspect(directiveIntrospection);\n\n      throw new Error(\"Introspection result missing directive locations: \".concat(_directiveIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      isRepeatable: directiveIntrospection.isRepeatable,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}