{"ast":null,"code":"import { isReference, isField, DeepMerger, resultKeyNameFromField, shouldInclude, isNonNullObject, compact, createFragmentMap, getFragmentDefinitions, isArray } from \"../../utilities/index.js\";\nexport var hasOwn = Object.prototype.hasOwnProperty;\nexport function isNullish(value) {\n  return value === null || value === void 0;\n}\nexport { isArray };\nexport function defaultDataIdFromObject(_a, context) {\n  var __typename = _a.__typename,\n    id = _a.id,\n    _id = _a._id;\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject = !isNullish(id) ? {\n        id: id\n      } : !isNullish(_id) ? {\n        _id: _id\n      } : void 0;\n    }\n    if (isNullish(id) && !isNullish(_id)) {\n      id = _id;\n    }\n    if (!isNullish(id)) {\n      return \"\".concat(__typename, \":\").concat(typeof id === \"number\" || typeof id === \"string\" ? id : JSON.stringify(id));\n    }\n  }\n}\nvar defaultConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  canonizeResults: false\n};\nexport function normalizeConfig(config) {\n  return compact(defaultConfig, config);\n}\nexport function shouldCanonizeResults(config) {\n  var value = config.canonizeResults;\n  return value === void 0 ? defaultConfig.canonizeResults : value;\n}\nexport function getTypenameFromStoreObject(store, objectOrReference) {\n  return isReference(objectOrReference) ? store.get(objectOrReference.__ref, \"__typename\") : objectOrReference && objectOrReference.__typename;\n}\nexport var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\nexport function fieldNameFromStoreName(storeFieldName) {\n  var match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\nexport function selectionSetMatchesResult(selectionSet, result, variables) {\n  if (isNonNullObject(result)) {\n    return isArray(result) ? result.every(function (item) {\n      return selectionSetMatchesResult(selectionSet, item, variables);\n    }) : selectionSet.selections.every(function (field) {\n      if (isField(field) && shouldInclude(field, variables)) {\n        var key = resultKeyNameFromField(field);\n        return hasOwn.call(result, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result[key], variables));\n      }\n      return true;\n    });\n  }\n  return false;\n}\nexport function storeValueIsStoreObject(value) {\n  return isNonNullObject(value) && !isReference(value) && !isArray(value);\n}\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger();\n}\nexport function extractFragmentContext(document, fragments) {\n  var fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n  return {\n    fragmentMap: fragmentMap,\n    lookupFragment: function lookupFragment(name) {\n      var def = fragmentMap[name];\n      if (!def && fragments) {\n        def = fragments.lookup(name);\n      }\n      return def || null;\n    }\n  };\n}","map":{"version":3,"names":["isReference","isField","DeepMerger","resultKeyNameFromField","shouldInclude","isNonNullObject","compact","createFragmentMap","getFragmentDefinitions","isArray","hasOwn","Object","prototype","hasOwnProperty","isNullish","value","defaultDataIdFromObject","_a","context","__typename","id","_id","keyObject","concat","JSON","stringify","defaultConfig","dataIdFromObject","addTypename","resultCaching","canonizeResults","normalizeConfig","config","shouldCanonizeResults","getTypenameFromStoreObject","store","objectOrReference","get","__ref","TypeOrFieldNameRegExp","fieldNameFromStoreName","storeFieldName","match","selectionSetMatchesResult","selectionSet","result","variables","every","item","selections","field","key","call","storeValueIsStoreObject","makeProcessedFieldsMerger","extractFragmentContext","document","fragments","fragmentMap","lookupFragment","name","def","lookup"],"sources":["/data/stackhub-web/plugins/myapps/node_modules/@apollo/src/cache/inmemory/helpers.ts"],"sourcesContent":["import { DocumentNode, FragmentDefinitionNode, SelectionSetNode } from 'graphql';\n\nimport {\n  NormalizedCache,\n  InMemoryCacheConfig,\n} from './types';\n\nimport { KeyFieldsContext } from './policies';\nimport { FragmentRegistryAPI } from './fragmentRegistry';\n\nimport {\n  Reference,\n  isReference,\n  StoreValue,\n  StoreObject,\n  isField,\n  DeepMerger,\n  resultKeyNameFromField,\n  shouldInclude,\n  isNonNullObject,\n  compact,\n  FragmentMap,\n  FragmentMapFunction,\n  createFragmentMap,\n  getFragmentDefinitions,\n  isArray,\n} from '../../utilities';\n\nexport const {\n  hasOwnProperty: hasOwn,\n} = Object.prototype;\n\nexport function isNullish(value: any): value is null | undefined {\n  return value === null || value === void 0;\n}\n\nexport { isArray };\n\nexport function defaultDataIdFromObject(\n  { __typename, id, _id }: Readonly<StoreObject>,\n  context?: KeyFieldsContext,\n): string | undefined {\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject =\n        !isNullish(id) ? { id } :\n        !isNullish(_id) ? { _id } :\n        void 0;\n    }\n\n    // If there is no object.id, fall back to object._id.\n    if (isNullish(id) && !isNullish(_id)) {\n      id = _id;\n    }\n\n    if (!isNullish(id)) {\n      return `${__typename}:${(\n        typeof id === \"number\" ||\n        typeof id === \"string\"\n      ) ? id : JSON.stringify(id)}`;\n    }\n  }\n}\n\nconst defaultConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  // Thanks to the shouldCanonizeResults helper, this should be the only line\n  // you have to change to reenable canonization by default in the future.\n  canonizeResults: false,\n};\n\nexport function normalizeConfig(config: InMemoryCacheConfig) {\n  return compact(defaultConfig, config);\n}\n\nexport function shouldCanonizeResults(\n  config: Pick<InMemoryCacheConfig, \"canonizeResults\">,\n): boolean {\n  const value = config.canonizeResults;\n  return value === void 0 ? defaultConfig.canonizeResults : value;\n}\n\nexport function getTypenameFromStoreObject(\n  store: NormalizedCache,\n  objectOrReference: StoreObject | Reference,\n): string | undefined {\n  return isReference(objectOrReference)\n    ? store.get(objectOrReference.__ref, \"__typename\") as string\n    : objectOrReference && objectOrReference.__typename;\n}\n\nexport const TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\n\nexport function fieldNameFromStoreName(storeFieldName: string): string {\n  const match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\n\nexport function selectionSetMatchesResult(\n  selectionSet: SelectionSetNode,\n  result: Record<string, any>,\n  variables?: Record<string, any>,\n): boolean {\n  if (isNonNullObject(result)) {\n    return isArray(result)\n      ? result.every(item => selectionSetMatchesResult(selectionSet, item, variables))\n      : selectionSet.selections.every(field => {\n        if (isField(field) && shouldInclude(field, variables)) {\n          const key = resultKeyNameFromField(field);\n          return hasOwn.call(result, key) &&\n            (!field.selectionSet ||\n             selectionSetMatchesResult(field.selectionSet, result[key], variables));\n        }\n        // If the selection has been skipped with @skip(true) or\n        // @include(false), it should not count against the matching. If\n        // the selection is not a field, it must be a fragment (inline or\n        // named). We will determine if selectionSetMatchesResult for that\n        // fragment when we get to it, so for now we return true.\n        return true;\n      });\n  }\n  return false;\n}\n\nexport function storeValueIsStoreObject(\n  value: StoreValue,\n): value is StoreObject {\n  return isNonNullObject(value) &&\n    !isReference(value) &&\n    !isArray(value);\n}\n\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger;\n}\n\nexport function extractFragmentContext(\n  document: DocumentNode,\n  fragments?: FragmentRegistryAPI,\n): {\n  fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n} {\n  // FragmentMap consisting only of fragments defined directly in document, not\n  // including other fragments registered in the FragmentRegistry.\n  const fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n  return {\n    fragmentMap,\n    lookupFragment(name) {\n      let def: FragmentDefinitionNode | null = fragmentMap[name];\n      if (!def && fragments) {\n        def = fragments.lookup(name);\n      }\n      return def || null;\n    },\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}