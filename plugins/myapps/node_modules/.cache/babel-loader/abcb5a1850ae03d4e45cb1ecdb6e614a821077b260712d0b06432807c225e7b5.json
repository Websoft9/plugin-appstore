{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport objectValues from \"../polyfills/objectValues.mjs\";\nimport keyMap from \"../jsutils/keyMap.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport mapValue from \"../jsutils/mapValue.mjs\";\nimport invariant from \"../jsutils/invariant.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { TokenKind } from \"../language/tokenKind.mjs\";\nimport { dedentBlockStringValue } from \"../language/blockString.mjs\";\nimport { isTypeDefinitionNode, isTypeExtensionNode } from \"../language/predicates.mjs\";\nimport { assertValidSDLExtension } from \"../validation/validate.mjs\";\nimport { getDirectiveValues } from \"../execution/values.mjs\";\nimport { assertSchema, GraphQLSchema } from \"../type/schema.mjs\";\nimport { specifiedScalarTypes, isSpecifiedScalarType } from \"../type/scalars.mjs\";\nimport { introspectionTypes, isIntrospectionType } from \"../type/introspection.mjs\";\nimport { GraphQLDirective, GraphQLDeprecatedDirective, GraphQLSpecifiedByDirective } from \"../type/directives.mjs\";\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isListType, isNonNullType, isEnumType, isInputObjectType, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType } from \"../type/definition.mjs\";\nimport { valueFromAST } from \"./valueFromAST.mjs\";\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n *\n * Accepts options as a third argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function extendSchema(schema, documentAST, options) {\n  assertSchema(schema);\n  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST.');\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    assertValidSDLExtension(documentAST, schema);\n  }\n  var schemaConfig = schema.toConfig();\n  var extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);\n  return schemaConfig === extendedConfig ? schema : new GraphQLSchema(extendedConfig);\n}\n/**\n * @internal\n */\n\nexport function extendSchemaImpl(schemaConfig, documentAST, options) {\n  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;\n\n  // Collect the type definitions and extensions found in the document.\n  var typeDefs = [];\n  var typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefs = [];\n  var schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  var schemaExtensions = [];\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var def = _documentAST$definiti2[_i2];\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(def);\n    } else if (isTypeDefinitionNode(def)) {\n      typeDefs.push(def);\n    } else if (isTypeExtensionNode(def)) {\n      var extendedTypeName = def.name.value;\n      var existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n  if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {\n    return schemaConfig;\n  }\n  var typeMap = Object.create(null);\n  for (var _i4 = 0, _schemaConfig$types2 = schemaConfig.types; _i4 < _schemaConfig$types2.length; _i4++) {\n    var existingType = _schemaConfig$types2[_i4];\n    typeMap[existingType.name] = extendNamedType(existingType);\n  }\n  for (var _i6 = 0; _i6 < typeDefs.length; _i6++) {\n    var _stdTypeMap$name;\n    var typeNode = typeDefs[_i6];\n    var name = typeNode.name.value;\n    typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);\n  }\n  var operationTypes = _objectSpread(_objectSpread({\n    // Get the extended root operation types.\n    query: schemaConfig.query && replaceNamedType(schemaConfig.query),\n    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),\n    subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription)\n  }, schemaDef && getOperationTypes([schemaDef])), getOperationTypes(schemaExtensions)); // Then produce and return a Schema config with these types.\n\n  return _objectSpread(_objectSpread({\n    description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value\n  }, operationTypes), {}, {\n    types: objectValues(typeMap),\n    directives: [].concat(schemaConfig.directives.map(replaceDirective), directiveDefs.map(buildDirective)),\n    extensions: undefined,\n    astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),\n    assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false\n  }); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      // $FlowFixMe[incompatible-return]\n      return new GraphQLList(replaceType(type.ofType));\n    }\n    if (isNonNullType(type)) {\n      // $FlowFixMe[incompatible-return]\n      return new GraphQLNonNull(replaceType(type.ofType));\n    }\n    return replaceNamedType(type);\n  }\n  function replaceNamedType(type) {\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    return typeMap[type.name];\n  }\n  function replaceDirective(directive) {\n    var config = directive.toConfig();\n    return new GraphQLDirective(_objectSpread(_objectSpread({}, config), {}, {\n      args: mapValue(config.args, extendArg)\n    }));\n  }\n  function extendNamedType(type) {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    }\n    if (isScalarType(type)) {\n      return extendScalarType(type);\n    }\n    if (isObjectType(type)) {\n      return extendObjectType(type);\n    }\n    if (isInterfaceType(type)) {\n      return extendInterfaceType(type);\n    }\n    if (isUnionType(type)) {\n      return extendUnionType(type);\n    }\n    if (isEnumType(type)) {\n      return extendEnumType(type);\n    } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n    if (isInputObjectType(type)) {\n      return extendInputObjectType(type);\n    } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n    false || invariant(0, 'Unexpected type: ' + inspect(type));\n  }\n  function extendInputObjectType(type) {\n    var _typeExtensionsMap$co;\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];\n    return new GraphQLInputObjectType(_objectSpread(_objectSpread({}, config), {}, {\n      fields: function fields() {\n        return _objectSpread(_objectSpread({}, mapValue(config.fields, function (field) {\n          return _objectSpread(_objectSpread({}, field), {}, {\n            type: replaceType(field.type)\n          });\n        })), buildInputFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n  function extendEnumType(type) {\n    var _typeExtensionsMap$ty;\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];\n    return new GraphQLEnumType(_objectSpread(_objectSpread({}, config), {}, {\n      values: _objectSpread(_objectSpread({}, config.values), buildEnumValueMap(extensions)),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n  function extendScalarType(type) {\n    var _typeExtensionsMap$co2;\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];\n    var specifiedByUrl = config.specifiedByUrl;\n    for (var _i8 = 0; _i8 < extensions.length; _i8++) {\n      var _getSpecifiedByUrl;\n      var extensionNode = extensions[_i8];\n      specifiedByUrl = (_getSpecifiedByUrl = getSpecifiedByUrl(extensionNode)) !== null && _getSpecifiedByUrl !== void 0 ? _getSpecifiedByUrl : specifiedByUrl;\n    }\n    return new GraphQLScalarType(_objectSpread(_objectSpread({}, config), {}, {\n      specifiedByUrl: specifiedByUrl,\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n  function extendObjectType(type) {\n    var _typeExtensionsMap$co3;\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];\n    return new GraphQLObjectType(_objectSpread(_objectSpread({}, config), {}, {\n      interfaces: function interfaces() {\n        return [].concat(type.getInterfaces().map(replaceNamedType), buildInterfaces(extensions));\n      },\n      fields: function fields() {\n        return _objectSpread(_objectSpread({}, mapValue(config.fields, extendField)), buildFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n  function extendInterfaceType(type) {\n    var _typeExtensionsMap$co4;\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];\n    return new GraphQLInterfaceType(_objectSpread(_objectSpread({}, config), {}, {\n      interfaces: function interfaces() {\n        return [].concat(type.getInterfaces().map(replaceNamedType), buildInterfaces(extensions));\n      },\n      fields: function fields() {\n        return _objectSpread(_objectSpread({}, mapValue(config.fields, extendField)), buildFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n  function extendUnionType(type) {\n    var _typeExtensionsMap$co5;\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];\n    return new GraphQLUnionType(_objectSpread(_objectSpread({}, config), {}, {\n      types: function types() {\n        return [].concat(type.getTypes().map(replaceNamedType), buildUnionTypes(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n  function extendField(field) {\n    return _objectSpread(_objectSpread({}, field), {}, {\n      type: replaceType(field.type),\n      // $FlowFixMe[incompatible-call]\n      args: mapValue(field.args, extendArg)\n    });\n  }\n  function extendArg(arg) {\n    return _objectSpread(_objectSpread({}, arg), {}, {\n      type: replaceType(arg.type)\n    });\n  }\n  function getOperationTypes(nodes) {\n    var opTypes = {};\n    for (var _i10 = 0; _i10 < nodes.length; _i10++) {\n      var _node$operationTypes;\n      var node = nodes[_i10];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];\n      for (var _i12 = 0; _i12 < operationTypesNodes.length; _i12++) {\n        var operationType = operationTypesNodes[_i12];\n        opTypes[operationType.operation] = getNamedType(operationType.type);\n      }\n    } // Note: While this could make early assertions to get the correctly\n    // typed values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n\n    return opTypes;\n  }\n  function getNamedType(node) {\n    var _stdTypeMap$name2;\n    var name = node.name.value;\n    var type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];\n    if (type === undefined) {\n      throw new Error(\"Unknown type: \\\"\".concat(name, \"\\\".\"));\n    }\n    return type;\n  }\n  function getWrappedType(node) {\n    if (node.kind === Kind.LIST_TYPE) {\n      return new GraphQLList(getWrappedType(node.type));\n    }\n    if (node.kind === Kind.NON_NULL_TYPE) {\n      return new GraphQLNonNull(getWrappedType(node.type));\n    }\n    return getNamedType(node);\n  }\n  function buildDirective(node) {\n    var locations = node.locations.map(function (_ref) {\n      var value = _ref.value;\n      return value;\n    });\n    return new GraphQLDirective({\n      name: node.name.value,\n      description: getDescription(node, options),\n      locations: locations,\n      isRepeatable: node.repeatable,\n      args: buildArgumentMap(node.arguments),\n      astNode: node\n    });\n  }\n  function buildFieldMap(nodes) {\n    var fieldConfigMap = Object.create(null);\n    for (var _i14 = 0; _i14 < nodes.length; _i14++) {\n      var _node$fields;\n      var node = nodes[_i14];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var nodeFields = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];\n      for (var _i16 = 0; _i16 < nodeFields.length; _i16++) {\n        var field = nodeFields[_i16];\n        fieldConfigMap[field.name.value] = {\n          // Note: While this could make assertions to get the correctly typed\n          // value, that would throw immediately while type system validation\n          // with validateSchema() will produce more actionable results.\n          type: getWrappedType(field.type),\n          description: getDescription(field, options),\n          args: buildArgumentMap(field.arguments),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field\n        };\n      }\n    }\n    return fieldConfigMap;\n  }\n  function buildArgumentMap(args) {\n    // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n    var argsNodes = args !== null && args !== void 0 ? args : [];\n    var argConfigMap = Object.create(null);\n    for (var _i18 = 0; _i18 < argsNodes.length; _i18++) {\n      var arg = argsNodes[_i18];\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      var type = getWrappedType(arg.type);\n      argConfigMap[arg.name.value] = {\n        type: type,\n        description: getDescription(arg, options),\n        defaultValue: valueFromAST(arg.defaultValue, type),\n        deprecationReason: getDeprecationReason(arg),\n        astNode: arg\n      };\n    }\n    return argConfigMap;\n  }\n  function buildInputFieldMap(nodes) {\n    var inputFieldMap = Object.create(null);\n    for (var _i20 = 0; _i20 < nodes.length; _i20++) {\n      var _node$fields2;\n      var node = nodes[_i20];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var fieldsNodes = (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : [];\n      for (var _i22 = 0; _i22 < fieldsNodes.length; _i22++) {\n        var field = fieldsNodes[_i22];\n        // Note: While this could make assertions to get the correctly typed\n        // value, that would throw immediately while type system validation\n        // with validateSchema() will produce more actionable results.\n        var type = getWrappedType(field.type);\n        inputFieldMap[field.name.value] = {\n          type: type,\n          description: getDescription(field, options),\n          defaultValue: valueFromAST(field.defaultValue, type),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field\n        };\n      }\n    }\n    return inputFieldMap;\n  }\n  function buildEnumValueMap(nodes) {\n    var enumValueMap = Object.create(null);\n    for (var _i24 = 0; _i24 < nodes.length; _i24++) {\n      var _node$values;\n      var node = nodes[_i24];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var valuesNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];\n      for (var _i26 = 0; _i26 < valuesNodes.length; _i26++) {\n        var value = valuesNodes[_i26];\n        enumValueMap[value.name.value] = {\n          description: getDescription(value, options),\n          deprecationReason: getDeprecationReason(value),\n          astNode: value\n        };\n      }\n    }\n    return enumValueMap;\n  }\n  function buildInterfaces(nodes) {\n    var interfaces = [];\n    for (var _i28 = 0; _i28 < nodes.length; _i28++) {\n      var _node$interfaces;\n      var node = nodes[_i28];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var interfacesNodes = (_node$interfaces = node.interfaces) !== null && _node$interfaces !== void 0 ? _node$interfaces : [];\n      for (var _i30 = 0; _i30 < interfacesNodes.length; _i30++) {\n        var type = interfacesNodes[_i30];\n        // Note: While this could make assertions to get the correctly typed\n        // values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable\n        // results.\n        interfaces.push(getNamedType(type));\n      }\n    }\n    return interfaces;\n  }\n  function buildUnionTypes(nodes) {\n    var types = [];\n    for (var _i32 = 0; _i32 < nodes.length; _i32++) {\n      var _node$types;\n      var node = nodes[_i32];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var typeNodes = (_node$types = node.types) !== null && _node$types !== void 0 ? _node$types : [];\n      for (var _i34 = 0; _i34 < typeNodes.length; _i34++) {\n        var type = typeNodes[_i34];\n        // Note: While this could make assertions to get the correctly typed\n        // values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable\n        // results.\n        types.push(getNamedType(type));\n      }\n    }\n    return types;\n  }\n  function buildType(astNode) {\n    var _typeExtensionsMap$na;\n    var name = astNode.name.value;\n    var description = getDescription(astNode, options);\n    var extensionNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];\n    switch (astNode.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        {\n          var extensionASTNodes = extensionNodes;\n          var allNodes = [astNode].concat(extensionASTNodes);\n          return new GraphQLObjectType({\n            name: name,\n            description: description,\n            interfaces: function interfaces() {\n              return buildInterfaces(allNodes);\n            },\n            fields: function fields() {\n              return buildFieldMap(allNodes);\n            },\n            astNode: astNode,\n            extensionASTNodes: extensionASTNodes\n          });\n        }\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes = extensionNodes;\n          var _allNodes = [astNode].concat(_extensionASTNodes);\n          return new GraphQLInterfaceType({\n            name: name,\n            description: description,\n            interfaces: function interfaces() {\n              return buildInterfaces(_allNodes);\n            },\n            fields: function fields() {\n              return buildFieldMap(_allNodes);\n            },\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes\n          });\n        }\n      case Kind.ENUM_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes2 = extensionNodes;\n          var _allNodes2 = [astNode].concat(_extensionASTNodes2);\n          return new GraphQLEnumType({\n            name: name,\n            description: description,\n            values: buildEnumValueMap(_allNodes2),\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes2\n          });\n        }\n      case Kind.UNION_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes3 = extensionNodes;\n          var _allNodes3 = [astNode].concat(_extensionASTNodes3);\n          return new GraphQLUnionType({\n            name: name,\n            description: description,\n            types: function types() {\n              return buildUnionTypes(_allNodes3);\n            },\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes3\n          });\n        }\n      case Kind.SCALAR_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes4 = extensionNodes;\n          return new GraphQLScalarType({\n            name: name,\n            description: description,\n            specifiedByUrl: getSpecifiedByUrl(astNode),\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes4\n          });\n        }\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes5 = extensionNodes;\n          var _allNodes4 = [astNode].concat(_extensionASTNodes5);\n          return new GraphQLInputObjectType({\n            name: name,\n            description: description,\n            fields: function fields() {\n              return buildInputFieldMap(_allNodes4);\n            },\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes5\n          });\n        }\n    } // istanbul ignore next (Not reachable. All possible type definition nodes have been considered)\n\n    false || invariant(0, 'Unexpected type definition node: ' + inspect(astNode));\n  }\n}\nvar stdTypeMap = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n  return type.name;\n});\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  var deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);\n  return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;\n}\n/**\n * Given a scalar node, returns the string value for the specifiedByUrl.\n */\n\nfunction getSpecifiedByUrl(node) {\n  var specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node);\n  return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;\n}\n/**\n * Given an ast node, returns its string description.\n * @deprecated: provided to ease adoption and will be removed in v16.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\nexport function getDescription(node, options) {\n  if (node.description) {\n    return node.description.value;\n  }\n  if ((options === null || options === void 0 ? void 0 : options.commentDescriptions) === true) {\n    var rawValue = getLeadingCommentBlock(node);\n    if (rawValue !== undefined) {\n      return dedentBlockStringValue('\\n' + rawValue);\n    }\n  }\n}\nfunction getLeadingCommentBlock(node) {\n  var loc = node.loc;\n  if (!loc) {\n    return;\n  }\n  var comments = [];\n  var token = loc.startToken.prev;\n  while (token != null && token.kind === TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n  return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}","map":{"version":3,"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","objectValues","keyMap","inspect","mapValue","invariant","devAssert","Kind","TokenKind","dedentBlockStringValue","isTypeDefinitionNode","isTypeExtensionNode","assertValidSDLExtension","getDirectiveValues","assertSchema","GraphQLSchema","specifiedScalarTypes","isSpecifiedScalarType","introspectionTypes","isIntrospectionType","GraphQLDirective","GraphQLDeprecatedDirective","GraphQLSpecifiedByDirective","isScalarType","isObjectType","isInterfaceType","isUnionType","isListType","isNonNullType","isEnumType","isInputObjectType","GraphQLList","GraphQLNonNull","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","valueFromAST","extendSchema","schema","documentAST","options","kind","DOCUMENT","assumeValid","assumeValidSDL","schemaConfig","toConfig","extendedConfig","extendSchemaImpl","_schemaDef","_schemaDef$descriptio","_schemaDef2","_options$assumeValid","typeDefs","typeExtensionsMap","create","directiveDefs","schemaDef","schemaExtensions","_i2","_documentAST$definiti2","definitions","def","SCHEMA_DEFINITION","SCHEMA_EXTENSION","extendedTypeName","name","existingTypeExtensions","concat","DIRECTIVE_DEFINITION","typeMap","_i4","_schemaConfig$types2","types","existingType","extendNamedType","_i6","_stdTypeMap$name","typeNode","stdTypeMap","buildType","operationTypes","query","replaceNamedType","mutation","subscription","getOperationTypes","description","directives","map","replaceDirective","buildDirective","extensions","undefined","astNode","extensionASTNodes","replaceType","type","ofType","directive","config","args","extendArg","extendScalarType","extendObjectType","extendInterfaceType","extendUnionType","extendEnumType","extendInputObjectType","_typeExtensionsMap$co","fields","field","buildInputFieldMap","_typeExtensionsMap$ty","values","buildEnumValueMap","_typeExtensionsMap$co2","specifiedByUrl","_i8","_getSpecifiedByUrl","extensionNode","getSpecifiedByUrl","_typeExtensionsMap$co3","interfaces","getInterfaces","buildInterfaces","extendField","buildFieldMap","_typeExtensionsMap$co4","_typeExtensionsMap$co5","getTypes","buildUnionTypes","arg","nodes","opTypes","_i10","_node$operationTypes","node","operationTypesNodes","_i12","operationType","operation","getNamedType","_stdTypeMap$name2","Error","getWrappedType","LIST_TYPE","NON_NULL_TYPE","locations","_ref","getDescription","isRepeatable","repeatable","buildArgumentMap","fieldConfigMap","_i14","_node$fields","nodeFields","_i16","deprecationReason","getDeprecationReason","argsNodes","argConfigMap","_i18","defaultValue","inputFieldMap","_i20","_node$fields2","fieldsNodes","_i22","enumValueMap","_i24","_node$values","valuesNodes","_i26","_i28","_node$interfaces","interfacesNodes","_i30","_i32","_node$types","typeNodes","_i34","_typeExtensionsMap$na","extensionNodes","OBJECT_TYPE_DEFINITION","allNodes","INTERFACE_TYPE_DEFINITION","_extensionASTNodes","_allNodes","ENUM_TYPE_DEFINITION","_extensionASTNodes2","_allNodes2","UNION_TYPE_DEFINITION","_extensionASTNodes3","_allNodes3","SCALAR_TYPE_DEFINITION","_extensionASTNodes4","INPUT_OBJECT_TYPE_DEFINITION","_extensionASTNodes5","_allNodes4","deprecated","reason","specifiedBy","url","commentDescriptions","rawValue","getLeadingCommentBlock","loc","comments","token","startToken","prev","COMMENT","next","line","String","reverse","join"],"sources":["/data/stackhub-web/plugins/myapps/node_modules/graphql/utilities/extendSchema.mjs"],"sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport objectValues from \"../polyfills/objectValues.mjs\";\nimport keyMap from \"../jsutils/keyMap.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport mapValue from \"../jsutils/mapValue.mjs\";\nimport invariant from \"../jsutils/invariant.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { TokenKind } from \"../language/tokenKind.mjs\";\nimport { dedentBlockStringValue } from \"../language/blockString.mjs\";\nimport { isTypeDefinitionNode, isTypeExtensionNode } from \"../language/predicates.mjs\";\nimport { assertValidSDLExtension } from \"../validation/validate.mjs\";\nimport { getDirectiveValues } from \"../execution/values.mjs\";\nimport { assertSchema, GraphQLSchema } from \"../type/schema.mjs\";\nimport { specifiedScalarTypes, isSpecifiedScalarType } from \"../type/scalars.mjs\";\nimport { introspectionTypes, isIntrospectionType } from \"../type/introspection.mjs\";\nimport { GraphQLDirective, GraphQLDeprecatedDirective, GraphQLSpecifiedByDirective } from \"../type/directives.mjs\";\nimport { isScalarType, isObjectType, isInterfaceType, isUnionType, isListType, isNonNullType, isEnumType, isInputObjectType, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType } from \"../type/definition.mjs\";\nimport { valueFromAST } from \"./valueFromAST.mjs\";\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n *\n * Accepts options as a third argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function extendSchema(schema, documentAST, options) {\n  assertSchema(schema);\n  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST.');\n\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    assertValidSDLExtension(documentAST, schema);\n  }\n\n  var schemaConfig = schema.toConfig();\n  var extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);\n  return schemaConfig === extendedConfig ? schema : new GraphQLSchema(extendedConfig);\n}\n/**\n * @internal\n */\n\nexport function extendSchemaImpl(schemaConfig, documentAST, options) {\n  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;\n\n  // Collect the type definitions and extensions found in the document.\n  var typeDefs = [];\n  var typeExtensionsMap = Object.create(null); // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n\n  var directiveDefs = [];\n  var schemaDef; // Schema extensions are collected which may add additional operation types.\n\n  var schemaExtensions = [];\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var def = _documentAST$definiti2[_i2];\n\n    if (def.kind === Kind.SCHEMA_DEFINITION) {\n      schemaDef = def;\n    } else if (def.kind === Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(def);\n    } else if (isTypeDefinitionNode(def)) {\n      typeDefs.push(def);\n    } else if (isTypeExtensionNode(def)) {\n      var extendedTypeName = def.name.value;\n      var existingTypeExtensions = typeExtensionsMap[extendedTypeName];\n      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];\n    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      directiveDefs.push(def);\n    }\n  } // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n\n\n  if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {\n    return schemaConfig;\n  }\n\n  var typeMap = Object.create(null);\n\n  for (var _i4 = 0, _schemaConfig$types2 = schemaConfig.types; _i4 < _schemaConfig$types2.length; _i4++) {\n    var existingType = _schemaConfig$types2[_i4];\n    typeMap[existingType.name] = extendNamedType(existingType);\n  }\n\n  for (var _i6 = 0; _i6 < typeDefs.length; _i6++) {\n    var _stdTypeMap$name;\n\n    var typeNode = typeDefs[_i6];\n    var name = typeNode.name.value;\n    typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);\n  }\n\n  var operationTypes = _objectSpread(_objectSpread({\n    // Get the extended root operation types.\n    query: schemaConfig.query && replaceNamedType(schemaConfig.query),\n    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),\n    subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription)\n  }, schemaDef && getOperationTypes([schemaDef])), getOperationTypes(schemaExtensions)); // Then produce and return a Schema config with these types.\n\n\n  return _objectSpread(_objectSpread({\n    description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value\n  }, operationTypes), {}, {\n    types: objectValues(typeMap),\n    directives: [].concat(schemaConfig.directives.map(replaceDirective), directiveDefs.map(buildDirective)),\n    extensions: undefined,\n    astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,\n    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),\n    assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false\n  }); // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function replaceType(type) {\n    if (isListType(type)) {\n      // $FlowFixMe[incompatible-return]\n      return new GraphQLList(replaceType(type.ofType));\n    }\n\n    if (isNonNullType(type)) {\n      // $FlowFixMe[incompatible-return]\n      return new GraphQLNonNull(replaceType(type.ofType));\n    }\n\n    return replaceNamedType(type);\n  }\n\n  function replaceNamedType(type) {\n    // Note: While this could make early assertions to get the correctly\n    // typed values, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n    return typeMap[type.name];\n  }\n\n  function replaceDirective(directive) {\n    var config = directive.toConfig();\n    return new GraphQLDirective(_objectSpread(_objectSpread({}, config), {}, {\n      args: mapValue(config.args, extendArg)\n    }));\n  }\n\n  function extendNamedType(type) {\n    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {\n      // Builtin types are not extended.\n      return type;\n    }\n\n    if (isScalarType(type)) {\n      return extendScalarType(type);\n    }\n\n    if (isObjectType(type)) {\n      return extendObjectType(type);\n    }\n\n    if (isInterfaceType(type)) {\n      return extendInterfaceType(type);\n    }\n\n    if (isUnionType(type)) {\n      return extendUnionType(type);\n    }\n\n    if (isEnumType(type)) {\n      return extendEnumType(type);\n    } // istanbul ignore else (See: 'https://github.com/graphql/graphql-js/issues/2618')\n\n\n    if (isInputObjectType(type)) {\n      return extendInputObjectType(type);\n    } // istanbul ignore next (Not reachable. All possible types have been considered)\n\n\n    false || invariant(0, 'Unexpected type: ' + inspect(type));\n  }\n\n  function extendInputObjectType(type) {\n    var _typeExtensionsMap$co;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];\n    return new GraphQLInputObjectType(_objectSpread(_objectSpread({}, config), {}, {\n      fields: function fields() {\n        return _objectSpread(_objectSpread({}, mapValue(config.fields, function (field) {\n          return _objectSpread(_objectSpread({}, field), {}, {\n            type: replaceType(field.type)\n          });\n        })), buildInputFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendEnumType(type) {\n    var _typeExtensionsMap$ty;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];\n    return new GraphQLEnumType(_objectSpread(_objectSpread({}, config), {}, {\n      values: _objectSpread(_objectSpread({}, config.values), buildEnumValueMap(extensions)),\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendScalarType(type) {\n    var _typeExtensionsMap$co2;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];\n    var specifiedByUrl = config.specifiedByUrl;\n\n    for (var _i8 = 0; _i8 < extensions.length; _i8++) {\n      var _getSpecifiedByUrl;\n\n      var extensionNode = extensions[_i8];\n      specifiedByUrl = (_getSpecifiedByUrl = getSpecifiedByUrl(extensionNode)) !== null && _getSpecifiedByUrl !== void 0 ? _getSpecifiedByUrl : specifiedByUrl;\n    }\n\n    return new GraphQLScalarType(_objectSpread(_objectSpread({}, config), {}, {\n      specifiedByUrl: specifiedByUrl,\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendObjectType(type) {\n    var _typeExtensionsMap$co3;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];\n    return new GraphQLObjectType(_objectSpread(_objectSpread({}, config), {}, {\n      interfaces: function interfaces() {\n        return [].concat(type.getInterfaces().map(replaceNamedType), buildInterfaces(extensions));\n      },\n      fields: function fields() {\n        return _objectSpread(_objectSpread({}, mapValue(config.fields, extendField)), buildFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendInterfaceType(type) {\n    var _typeExtensionsMap$co4;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];\n    return new GraphQLInterfaceType(_objectSpread(_objectSpread({}, config), {}, {\n      interfaces: function interfaces() {\n        return [].concat(type.getInterfaces().map(replaceNamedType), buildInterfaces(extensions));\n      },\n      fields: function fields() {\n        return _objectSpread(_objectSpread({}, mapValue(config.fields, extendField)), buildFieldMap(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendUnionType(type) {\n    var _typeExtensionsMap$co5;\n\n    var config = type.toConfig();\n    var extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];\n    return new GraphQLUnionType(_objectSpread(_objectSpread({}, config), {}, {\n      types: function types() {\n        return [].concat(type.getTypes().map(replaceNamedType), buildUnionTypes(extensions));\n      },\n      extensionASTNodes: config.extensionASTNodes.concat(extensions)\n    }));\n  }\n\n  function extendField(field) {\n    return _objectSpread(_objectSpread({}, field), {}, {\n      type: replaceType(field.type),\n      // $FlowFixMe[incompatible-call]\n      args: mapValue(field.args, extendArg)\n    });\n  }\n\n  function extendArg(arg) {\n    return _objectSpread(_objectSpread({}, arg), {}, {\n      type: replaceType(arg.type)\n    });\n  }\n\n  function getOperationTypes(nodes) {\n    var opTypes = {};\n\n    for (var _i10 = 0; _i10 < nodes.length; _i10++) {\n      var _node$operationTypes;\n\n      var node = nodes[_i10];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];\n\n      for (var _i12 = 0; _i12 < operationTypesNodes.length; _i12++) {\n        var operationType = operationTypesNodes[_i12];\n        opTypes[operationType.operation] = getNamedType(operationType.type);\n      }\n    } // Note: While this could make early assertions to get the correctly\n    // typed values below, that would throw immediately while type system\n    // validation with validateSchema() will produce more actionable results.\n\n\n    return opTypes;\n  }\n\n  function getNamedType(node) {\n    var _stdTypeMap$name2;\n\n    var name = node.name.value;\n    var type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];\n\n    if (type === undefined) {\n      throw new Error(\"Unknown type: \\\"\".concat(name, \"\\\".\"));\n    }\n\n    return type;\n  }\n\n  function getWrappedType(node) {\n    if (node.kind === Kind.LIST_TYPE) {\n      return new GraphQLList(getWrappedType(node.type));\n    }\n\n    if (node.kind === Kind.NON_NULL_TYPE) {\n      return new GraphQLNonNull(getWrappedType(node.type));\n    }\n\n    return getNamedType(node);\n  }\n\n  function buildDirective(node) {\n    var locations = node.locations.map(function (_ref) {\n      var value = _ref.value;\n      return value;\n    });\n    return new GraphQLDirective({\n      name: node.name.value,\n      description: getDescription(node, options),\n      locations: locations,\n      isRepeatable: node.repeatable,\n      args: buildArgumentMap(node.arguments),\n      astNode: node\n    });\n  }\n\n  function buildFieldMap(nodes) {\n    var fieldConfigMap = Object.create(null);\n\n    for (var _i14 = 0; _i14 < nodes.length; _i14++) {\n      var _node$fields;\n\n      var node = nodes[_i14];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var nodeFields = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];\n\n      for (var _i16 = 0; _i16 < nodeFields.length; _i16++) {\n        var field = nodeFields[_i16];\n        fieldConfigMap[field.name.value] = {\n          // Note: While this could make assertions to get the correctly typed\n          // value, that would throw immediately while type system validation\n          // with validateSchema() will produce more actionable results.\n          type: getWrappedType(field.type),\n          description: getDescription(field, options),\n          args: buildArgumentMap(field.arguments),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field\n        };\n      }\n    }\n\n    return fieldConfigMap;\n  }\n\n  function buildArgumentMap(args) {\n    // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n    var argsNodes = args !== null && args !== void 0 ? args : [];\n    var argConfigMap = Object.create(null);\n\n    for (var _i18 = 0; _i18 < argsNodes.length; _i18++) {\n      var arg = argsNodes[_i18];\n      // Note: While this could make assertions to get the correctly typed\n      // value, that would throw immediately while type system validation\n      // with validateSchema() will produce more actionable results.\n      var type = getWrappedType(arg.type);\n      argConfigMap[arg.name.value] = {\n        type: type,\n        description: getDescription(arg, options),\n        defaultValue: valueFromAST(arg.defaultValue, type),\n        deprecationReason: getDeprecationReason(arg),\n        astNode: arg\n      };\n    }\n\n    return argConfigMap;\n  }\n\n  function buildInputFieldMap(nodes) {\n    var inputFieldMap = Object.create(null);\n\n    for (var _i20 = 0; _i20 < nodes.length; _i20++) {\n      var _node$fields2;\n\n      var node = nodes[_i20];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var fieldsNodes = (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : [];\n\n      for (var _i22 = 0; _i22 < fieldsNodes.length; _i22++) {\n        var field = fieldsNodes[_i22];\n        // Note: While this could make assertions to get the correctly typed\n        // value, that would throw immediately while type system validation\n        // with validateSchema() will produce more actionable results.\n        var type = getWrappedType(field.type);\n        inputFieldMap[field.name.value] = {\n          type: type,\n          description: getDescription(field, options),\n          defaultValue: valueFromAST(field.defaultValue, type),\n          deprecationReason: getDeprecationReason(field),\n          astNode: field\n        };\n      }\n    }\n\n    return inputFieldMap;\n  }\n\n  function buildEnumValueMap(nodes) {\n    var enumValueMap = Object.create(null);\n\n    for (var _i24 = 0; _i24 < nodes.length; _i24++) {\n      var _node$values;\n\n      var node = nodes[_i24];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var valuesNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];\n\n      for (var _i26 = 0; _i26 < valuesNodes.length; _i26++) {\n        var value = valuesNodes[_i26];\n        enumValueMap[value.name.value] = {\n          description: getDescription(value, options),\n          deprecationReason: getDeprecationReason(value),\n          astNode: value\n        };\n      }\n    }\n\n    return enumValueMap;\n  }\n\n  function buildInterfaces(nodes) {\n    var interfaces = [];\n\n    for (var _i28 = 0; _i28 < nodes.length; _i28++) {\n      var _node$interfaces;\n\n      var node = nodes[_i28];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var interfacesNodes = (_node$interfaces = node.interfaces) !== null && _node$interfaces !== void 0 ? _node$interfaces : [];\n\n      for (var _i30 = 0; _i30 < interfacesNodes.length; _i30++) {\n        var type = interfacesNodes[_i30];\n        // Note: While this could make assertions to get the correctly typed\n        // values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable\n        // results.\n        interfaces.push(getNamedType(type));\n      }\n    }\n\n    return interfaces;\n  }\n\n  function buildUnionTypes(nodes) {\n    var types = [];\n\n    for (var _i32 = 0; _i32 < nodes.length; _i32++) {\n      var _node$types;\n\n      var node = nodes[_i32];\n      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n      var typeNodes = (_node$types = node.types) !== null && _node$types !== void 0 ? _node$types : [];\n\n      for (var _i34 = 0; _i34 < typeNodes.length; _i34++) {\n        var type = typeNodes[_i34];\n        // Note: While this could make assertions to get the correctly typed\n        // values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable\n        // results.\n        types.push(getNamedType(type));\n      }\n    }\n\n    return types;\n  }\n\n  function buildType(astNode) {\n    var _typeExtensionsMap$na;\n\n    var name = astNode.name.value;\n    var description = getDescription(astNode, options);\n    var extensionNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];\n\n    switch (astNode.kind) {\n      case Kind.OBJECT_TYPE_DEFINITION:\n        {\n          var extensionASTNodes = extensionNodes;\n          var allNodes = [astNode].concat(extensionASTNodes);\n          return new GraphQLObjectType({\n            name: name,\n            description: description,\n            interfaces: function interfaces() {\n              return buildInterfaces(allNodes);\n            },\n            fields: function fields() {\n              return buildFieldMap(allNodes);\n            },\n            astNode: astNode,\n            extensionASTNodes: extensionASTNodes\n          });\n        }\n\n      case Kind.INTERFACE_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes = extensionNodes;\n\n          var _allNodes = [astNode].concat(_extensionASTNodes);\n\n          return new GraphQLInterfaceType({\n            name: name,\n            description: description,\n            interfaces: function interfaces() {\n              return buildInterfaces(_allNodes);\n            },\n            fields: function fields() {\n              return buildFieldMap(_allNodes);\n            },\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes\n          });\n        }\n\n      case Kind.ENUM_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes2 = extensionNodes;\n\n          var _allNodes2 = [astNode].concat(_extensionASTNodes2);\n\n          return new GraphQLEnumType({\n            name: name,\n            description: description,\n            values: buildEnumValueMap(_allNodes2),\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes2\n          });\n        }\n\n      case Kind.UNION_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes3 = extensionNodes;\n\n          var _allNodes3 = [astNode].concat(_extensionASTNodes3);\n\n          return new GraphQLUnionType({\n            name: name,\n            description: description,\n            types: function types() {\n              return buildUnionTypes(_allNodes3);\n            },\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes3\n          });\n        }\n\n      case Kind.SCALAR_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes4 = extensionNodes;\n          return new GraphQLScalarType({\n            name: name,\n            description: description,\n            specifiedByUrl: getSpecifiedByUrl(astNode),\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes4\n          });\n        }\n\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        {\n          var _extensionASTNodes5 = extensionNodes;\n\n          var _allNodes4 = [astNode].concat(_extensionASTNodes5);\n\n          return new GraphQLInputObjectType({\n            name: name,\n            description: description,\n            fields: function fields() {\n              return buildInputFieldMap(_allNodes4);\n            },\n            astNode: astNode,\n            extensionASTNodes: _extensionASTNodes5\n          });\n        }\n    } // istanbul ignore next (Not reachable. All possible type definition nodes have been considered)\n\n\n    false || invariant(0, 'Unexpected type definition node: ' + inspect(astNode));\n  }\n}\nvar stdTypeMap = keyMap(specifiedScalarTypes.concat(introspectionTypes), function (type) {\n  return type.name;\n});\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\n\nfunction getDeprecationReason(node) {\n  var deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);\n  return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;\n}\n/**\n * Given a scalar node, returns the string value for the specifiedByUrl.\n */\n\n\nfunction getSpecifiedByUrl(node) {\n  var specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node);\n  return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;\n}\n/**\n * Given an ast node, returns its string description.\n * @deprecated: provided to ease adoption and will be removed in v16.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\n\nexport function getDescription(node, options) {\n  if (node.description) {\n    return node.description.value;\n  }\n\n  if ((options === null || options === void 0 ? void 0 : options.commentDescriptions) === true) {\n    var rawValue = getLeadingCommentBlock(node);\n\n    if (rawValue !== undefined) {\n      return dedentBlockStringValue('\\n' + rawValue);\n    }\n  }\n}\n\nfunction getLeadingCommentBlock(node) {\n  var loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  var comments = [];\n  var token = loc.startToken.prev;\n\n  while (token != null && token.kind === TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}