{"ast":null,"code":"import naturalCompare from \"./naturalCompare.mjs\";\n/**\n * Given an invalid input string and a list of valid options, returns a filtered\n * list of valid options sorted based on their similarity with the input.\n */\n\nexport default function suggestionList(input, options) {\n  var optionsByDistance = Object.create(null);\n  var lexicalDistance = new LexicalDistance(input);\n  var threshold = Math.floor(input.length * 0.4) + 1;\n  for (var _i2 = 0; _i2 < options.length; _i2++) {\n    var option = options[_i2];\n    var distance = lexicalDistance.measure(option, threshold);\n    if (distance !== undefined) {\n      optionsByDistance[option] = distance;\n    }\n  }\n  return Object.keys(optionsByDistance).sort(function (a, b) {\n    var distanceDiff = optionsByDistance[a] - optionsByDistance[b];\n    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a, b);\n  });\n}\n/**\n * Computes the lexical distance between strings A and B.\n *\n * The \"distance\" between two strings is given by counting the minimum number\n * of edits needed to transform string A into string B. An edit can be an\n * insertion, deletion, or substitution of a single character, or a swap of two\n * adjacent characters.\n *\n * Includes a custom alteration from Damerau-Levenshtein to treat case changes\n * as a single edit which helps identify mis-cased values with an edit distance\n * of 1.\n *\n * This distance can be useful for detecting typos in input or sorting\n */\n\nvar LexicalDistance = /*#__PURE__*/function () {\n  function LexicalDistance(input) {\n    this._input = input;\n    this._inputLowerCase = input.toLowerCase();\n    this._inputArray = stringToArray(this._inputLowerCase);\n    this._rows = [new Array(input.length + 1).fill(0), new Array(input.length + 1).fill(0), new Array(input.length + 1).fill(0)];\n  }\n  var _proto = LexicalDistance.prototype;\n  _proto.measure = function measure(option, threshold) {\n    if (this._input === option) {\n      return 0;\n    }\n    var optionLowerCase = option.toLowerCase(); // Any case change counts as a single edit\n\n    if (this._inputLowerCase === optionLowerCase) {\n      return 1;\n    }\n    var a = stringToArray(optionLowerCase);\n    var b = this._inputArray;\n    if (a.length < b.length) {\n      var tmp = a;\n      a = b;\n      b = tmp;\n    }\n    var aLength = a.length;\n    var bLength = b.length;\n    if (aLength - bLength > threshold) {\n      return undefined;\n    }\n    var rows = this._rows;\n    for (var j = 0; j <= bLength; j++) {\n      rows[0][j] = j;\n    }\n    for (var i = 1; i <= aLength; i++) {\n      var upRow = rows[(i - 1) % 3];\n      var currentRow = rows[i % 3];\n      var smallestCell = currentRow[0] = i;\n      for (var _j = 1; _j <= bLength; _j++) {\n        var cost = a[i - 1] === b[_j - 1] ? 0 : 1;\n        var currentCell = Math.min(upRow[_j] + 1,\n        // delete\n        currentRow[_j - 1] + 1,\n        // insert\n        upRow[_j - 1] + cost // substitute\n        );\n\n        if (i > 1 && _j > 1 && a[i - 1] === b[_j - 2] && a[i - 2] === b[_j - 1]) {\n          // transposition\n          var doubleDiagonalCell = rows[(i - 2) % 3][_j - 2];\n          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);\n        }\n        if (currentCell < smallestCell) {\n          smallestCell = currentCell;\n        }\n        currentRow[_j] = currentCell;\n      } // Early exit, since distance can't go smaller than smallest element of the previous row.\n\n      if (smallestCell > threshold) {\n        return undefined;\n      }\n    }\n    var distance = rows[aLength % 3][bLength];\n    return distance <= threshold ? distance : undefined;\n  };\n  return LexicalDistance;\n}();\nfunction stringToArray(str) {\n  var strLength = str.length;\n  var array = new Array(strLength);\n  for (var i = 0; i < strLength; ++i) {\n    array[i] = str.charCodeAt(i);\n  }\n  return array;\n}","map":{"version":3,"names":["naturalCompare","suggestionList","input","options","optionsByDistance","Object","create","lexicalDistance","LexicalDistance","threshold","Math","floor","length","_i2","option","distance","measure","undefined","keys","sort","a","b","distanceDiff","_input","_inputLowerCase","toLowerCase","_inputArray","stringToArray","_rows","Array","fill","_proto","prototype","optionLowerCase","tmp","aLength","bLength","rows","j","i","upRow","currentRow","smallestCell","_j","cost","currentCell","min","doubleDiagonalCell","str","strLength","array","charCodeAt"],"sources":["/data/stackhub-web/plugins/myapps/node_modules/graphql/jsutils/suggestionList.mjs"],"sourcesContent":["import naturalCompare from \"./naturalCompare.mjs\";\n/**\n * Given an invalid input string and a list of valid options, returns a filtered\n * list of valid options sorted based on their similarity with the input.\n */\n\nexport default function suggestionList(input, options) {\n  var optionsByDistance = Object.create(null);\n  var lexicalDistance = new LexicalDistance(input);\n  var threshold = Math.floor(input.length * 0.4) + 1;\n\n  for (var _i2 = 0; _i2 < options.length; _i2++) {\n    var option = options[_i2];\n    var distance = lexicalDistance.measure(option, threshold);\n\n    if (distance !== undefined) {\n      optionsByDistance[option] = distance;\n    }\n  }\n\n  return Object.keys(optionsByDistance).sort(function (a, b) {\n    var distanceDiff = optionsByDistance[a] - optionsByDistance[b];\n    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a, b);\n  });\n}\n/**\n * Computes the lexical distance between strings A and B.\n *\n * The \"distance\" between two strings is given by counting the minimum number\n * of edits needed to transform string A into string B. An edit can be an\n * insertion, deletion, or substitution of a single character, or a swap of two\n * adjacent characters.\n *\n * Includes a custom alteration from Damerau-Levenshtein to treat case changes\n * as a single edit which helps identify mis-cased values with an edit distance\n * of 1.\n *\n * This distance can be useful for detecting typos in input or sorting\n */\n\nvar LexicalDistance = /*#__PURE__*/function () {\n  function LexicalDistance(input) {\n    this._input = input;\n    this._inputLowerCase = input.toLowerCase();\n    this._inputArray = stringToArray(this._inputLowerCase);\n    this._rows = [new Array(input.length + 1).fill(0), new Array(input.length + 1).fill(0), new Array(input.length + 1).fill(0)];\n  }\n\n  var _proto = LexicalDistance.prototype;\n\n  _proto.measure = function measure(option, threshold) {\n    if (this._input === option) {\n      return 0;\n    }\n\n    var optionLowerCase = option.toLowerCase(); // Any case change counts as a single edit\n\n    if (this._inputLowerCase === optionLowerCase) {\n      return 1;\n    }\n\n    var a = stringToArray(optionLowerCase);\n    var b = this._inputArray;\n\n    if (a.length < b.length) {\n      var tmp = a;\n      a = b;\n      b = tmp;\n    }\n\n    var aLength = a.length;\n    var bLength = b.length;\n\n    if (aLength - bLength > threshold) {\n      return undefined;\n    }\n\n    var rows = this._rows;\n\n    for (var j = 0; j <= bLength; j++) {\n      rows[0][j] = j;\n    }\n\n    for (var i = 1; i <= aLength; i++) {\n      var upRow = rows[(i - 1) % 3];\n      var currentRow = rows[i % 3];\n      var smallestCell = currentRow[0] = i;\n\n      for (var _j = 1; _j <= bLength; _j++) {\n        var cost = a[i - 1] === b[_j - 1] ? 0 : 1;\n        var currentCell = Math.min(upRow[_j] + 1, // delete\n        currentRow[_j - 1] + 1, // insert\n        upRow[_j - 1] + cost // substitute\n        );\n\n        if (i > 1 && _j > 1 && a[i - 1] === b[_j - 2] && a[i - 2] === b[_j - 1]) {\n          // transposition\n          var doubleDiagonalCell = rows[(i - 2) % 3][_j - 2];\n          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);\n        }\n\n        if (currentCell < smallestCell) {\n          smallestCell = currentCell;\n        }\n\n        currentRow[_j] = currentCell;\n      } // Early exit, since distance can't go smaller than smallest element of the previous row.\n\n\n      if (smallestCell > threshold) {\n        return undefined;\n      }\n    }\n\n    var distance = rows[aLength % 3][bLength];\n    return distance <= threshold ? distance : undefined;\n  };\n\n  return LexicalDistance;\n}();\n\nfunction stringToArray(str) {\n  var strLength = str.length;\n  var array = new Array(strLength);\n\n  for (var i = 0; i < strLength; ++i) {\n    array[i] = str.charCodeAt(i);\n  }\n\n  return array;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}