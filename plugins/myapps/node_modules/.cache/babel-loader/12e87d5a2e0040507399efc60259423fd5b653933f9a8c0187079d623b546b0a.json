{"ast":null,"code":"import devAssert from \"../jsutils/devAssert.mjs\";\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\nimport { visit, visitInParallel } from \"../language/visitor.mjs\";\nimport { assertValidSchema } from \"../type/validate.mjs\";\nimport { TypeInfo, visitWithTypeInfo } from \"../utilities/TypeInfo.mjs\";\nimport { specifiedRules, specifiedSDLRules } from \"./specifiedRules.mjs\";\nimport { SDLValidationContext, ValidationContext } from \"./ValidationContext.mjs\";\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\n\nexport function validate(schema, documentAST) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedRules;\n  var typeInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new TypeInfo(schema);\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n    maxErrors: undefined\n  };\n  documentAST || devAssert(0, 'Must provide document.'); // If the schema used for validation is invalid, throw an error.\n\n  assertValidSchema(schema);\n  var abortObj = Object.freeze({});\n  var errors = [];\n  var context = new ValidationContext(schema, documentAST, typeInfo, function (error) {\n    if (options.maxErrors != null && errors.length >= options.maxErrors) {\n      errors.push(new GraphQLError('Too many validation errors, error limit reached. Validation aborted.'));\n      throw abortObj;\n    }\n    errors.push(error);\n  }); // This uses a specialized visitor which runs multiple visitors in parallel,\n  // while maintaining the visitor skip and break API.\n\n  var visitor = visitInParallel(rules.map(function (rule) {\n    return rule(context);\n  })); // Visit the whole document with each instance of all provided rules.\n\n  try {\n    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));\n  } catch (e) {\n    if (e !== abortObj) {\n      throw e;\n    }\n  }\n  return errors;\n}\n/**\n * @internal\n */\n\nexport function validateSDL(documentAST, schemaToExtend) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedSDLRules;\n  var errors = [];\n  var context = new SDLValidationContext(documentAST, schemaToExtend, function (error) {\n    errors.push(error);\n  });\n  var visitors = rules.map(function (rule) {\n    return rule(context);\n  });\n  visit(documentAST, visitInParallel(visitors));\n  return errors;\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDL(documentAST) {\n  var errors = validateSDL(documentAST);\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDLExtension(documentAST, schema) {\n  var errors = validateSDL(documentAST, schema);\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}","map":{"version":3,"names":["devAssert","GraphQLError","visit","visitInParallel","assertValidSchema","TypeInfo","visitWithTypeInfo","specifiedRules","specifiedSDLRules","SDLValidationContext","ValidationContext","validate","schema","documentAST","rules","arguments","length","undefined","typeInfo","options","maxErrors","abortObj","Object","freeze","errors","context","error","push","visitor","map","rule","e","validateSDL","schemaToExtend","visitors","assertValidSDL","Error","message","join","assertValidSDLExtension"],"sources":["/data/stackhub-web/plugins/myapps/node_modules/graphql/validation/validate.mjs"],"sourcesContent":["import devAssert from \"../jsutils/devAssert.mjs\";\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\nimport { visit, visitInParallel } from \"../language/visitor.mjs\";\nimport { assertValidSchema } from \"../type/validate.mjs\";\nimport { TypeInfo, visitWithTypeInfo } from \"../utilities/TypeInfo.mjs\";\nimport { specifiedRules, specifiedSDLRules } from \"./specifiedRules.mjs\";\nimport { SDLValidationContext, ValidationContext } from \"./ValidationContext.mjs\";\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\n\nexport function validate(schema, documentAST) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedRules;\n  var typeInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new TypeInfo(schema);\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n    maxErrors: undefined\n  };\n  documentAST || devAssert(0, 'Must provide document.'); // If the schema used for validation is invalid, throw an error.\n\n  assertValidSchema(schema);\n  var abortObj = Object.freeze({});\n  var errors = [];\n  var context = new ValidationContext(schema, documentAST, typeInfo, function (error) {\n    if (options.maxErrors != null && errors.length >= options.maxErrors) {\n      errors.push(new GraphQLError('Too many validation errors, error limit reached. Validation aborted.'));\n      throw abortObj;\n    }\n\n    errors.push(error);\n  }); // This uses a specialized visitor which runs multiple visitors in parallel,\n  // while maintaining the visitor skip and break API.\n\n  var visitor = visitInParallel(rules.map(function (rule) {\n    return rule(context);\n  })); // Visit the whole document with each instance of all provided rules.\n\n  try {\n    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));\n  } catch (e) {\n    if (e !== abortObj) {\n      throw e;\n    }\n  }\n\n  return errors;\n}\n/**\n * @internal\n */\n\nexport function validateSDL(documentAST, schemaToExtend) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : specifiedSDLRules;\n  var errors = [];\n  var context = new SDLValidationContext(documentAST, schemaToExtend, function (error) {\n    errors.push(error);\n  });\n  var visitors = rules.map(function (rule) {\n    return rule(context);\n  });\n  visit(documentAST, visitInParallel(visitors));\n  return errors;\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDL(documentAST) {\n  var errors = validateSDL(documentAST);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDLExtension(documentAST, schema) {\n  var errors = validateSDL(documentAST, schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}