{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { responseIterator } from \"./responseIterator.js\";\nimport { throwServerError } from \"../utils/index.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../../errors/index.js\";\nimport { isApolloPayloadResult } from \"../../utilities/common/incrementalResult.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nexport function readMultipartBody(response, observer) {\n  var _a, _b, _c, _d, _e;\n  return __awaiter(this, void 0, void 0, function () {\n    var decoder, contentType, delimiter, boundaryVal, boundary, buffer, iterator, running, _f, value, done, chunk, searchFrom, bi, message, i, headers, contentType_1, body, result, next;\n    var _g, _h;\n    return __generator(this, function (_j) {\n      switch (_j.label) {\n        case 0:\n          if (TextDecoder === undefined) {\n            throw new Error(\"TextDecoder must be defined in the environment: please import a polyfill.\");\n          }\n          decoder = new TextDecoder(\"utf-8\");\n          contentType = (_a = response.headers) === null || _a === void 0 ? void 0 : _a.get(\"content-type\");\n          delimiter = \"boundary=\";\n          boundaryVal = (contentType === null || contentType === void 0 ? void 0 : contentType.includes(delimiter)) ? contentType === null || contentType === void 0 ? void 0 : contentType.substring((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(delimiter)) + delimiter.length).replace(/['\"]/g, \"\").replace(/\\;(.*)/gm, \"\").trim() : \"-\";\n          boundary = \"\\r\\n--\".concat(boundaryVal);\n          buffer = \"\";\n          iterator = responseIterator(response);\n          running = true;\n          _j.label = 1;\n        case 1:\n          if (!running) return [3, 3];\n          return [4, iterator.next()];\n        case 2:\n          _f = _j.sent(), value = _f.value, done = _f.done;\n          chunk = typeof value === \"string\" ? value : decoder.decode(value);\n          searchFrom = buffer.length - boundary.length + 1;\n          running = !done;\n          buffer += chunk;\n          bi = buffer.indexOf(boundary, searchFrom);\n          while (bi > -1) {\n            message = void 0;\n            _g = [buffer.slice(0, bi), buffer.slice(bi + boundary.length)], message = _g[0], buffer = _g[1];\n            i = message.indexOf(\"\\r\\n\\r\\n\");\n            headers = parseHeaders(message.slice(0, i));\n            contentType_1 = headers[\"content-type\"];\n            if (contentType_1 && contentType_1.toLowerCase().indexOf(\"application/json\") === -1) {\n              throw new Error(\"Unsupported patch content type: application/json is required.\");\n            }\n            body = message.slice(i);\n            if (body) {\n              try {\n                result = parseJsonBody(response, body);\n                if (Object.keys(result).length > 1 || \"data\" in result || \"incremental\" in result || \"errors\" in result || \"payload\" in result) {\n                  if (isApolloPayloadResult(result)) {\n                    next = {};\n                    if (\"payload\" in result) {\n                      next = __assign({}, result.payload);\n                    }\n                    if (\"errors\" in result) {\n                      next = __assign(__assign({}, next), {\n                        extensions: __assign(__assign({}, \"extensions\" in next ? next.extensions : null), (_h = {}, _h[PROTOCOL_ERRORS_SYMBOL] = result.errors, _h))\n                      });\n                    }\n                    (_b = observer.next) === null || _b === void 0 ? void 0 : _b.call(observer, next);\n                  } else {\n                    (_c = observer.next) === null || _c === void 0 ? void 0 : _c.call(observer, result);\n                  }\n                } else if (Object.keys(result).length === 1 && \"hasNext\" in result && !result.hasNext) {\n                  (_d = observer.complete) === null || _d === void 0 ? void 0 : _d.call(observer);\n                }\n              } catch (err) {\n                handleError(err, observer);\n              }\n            }\n            bi = buffer.indexOf(boundary);\n          }\n          return [3, 1];\n        case 3:\n          (_e = observer.complete) === null || _e === void 0 ? void 0 : _e.call(observer);\n          return [2];\n      }\n    });\n  });\n}\nexport function parseHeaders(headerText) {\n  var headersInit = {};\n  headerText.split(\"\\n\").forEach(function (line) {\n    var i = line.indexOf(\":\");\n    if (i > -1) {\n      var name_1 = line.slice(0, i).trim().toLowerCase();\n      var value = line.slice(i + 1).trim();\n      headersInit[name_1] = value;\n    }\n  });\n  return headersInit;\n}\nexport function parseJsonBody(response, bodyText) {\n  if (response.status >= 300) {\n    var getResult = function getResult() {\n      try {\n        return JSON.parse(bodyText);\n      } catch (err) {\n        return bodyText;\n      }\n    };\n    throwServerError(response, getResult(), \"Response not successful: Received status code \".concat(response.status));\n  }\n  try {\n    return JSON.parse(bodyText);\n  } catch (err) {\n    var parseError = err;\n    parseError.name = \"ServerParseError\";\n    parseError.response = response;\n    parseError.statusCode = response.status;\n    parseError.bodyText = bodyText;\n    throw parseError;\n  }\n}\nexport function handleError(err, observer) {\n  var _a, _b;\n  if (err.name === \"AbortError\") return;\n  if (err.result && err.result.errors && err.result.data) {\n    (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, err.result);\n  }\n  (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, err);\n}\nexport function readJsonBody(response, operation, observer) {\n  parseAndCheckHttpResponse(operation)(response).then(function (result) {\n    var _a, _b;\n    (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, result);\n    (_b = observer.complete) === null || _b === void 0 ? void 0 : _b.call(observer);\n  }).catch(function (err) {\n    return handleError(err, observer);\n  });\n}\nexport function parseAndCheckHttpResponse(operations) {\n  return function (response) {\n    return response.text().then(function (bodyText) {\n      return parseJsonBody(response, bodyText);\n    }).then(function (result) {\n      if (response.status >= 300) {\n        throwServerError(response, result, \"Response not successful: Received status code \".concat(response.status));\n      }\n      if (!Array.isArray(result) && !hasOwnProperty.call(result, \"data\") && !hasOwnProperty.call(result, \"errors\")) {\n        throwServerError(response, result, \"Server response was missing for query '\".concat(Array.isArray(operations) ? operations.map(function (op) {\n          return op.operationName;\n        }) : operations.operationName, \"'.\"));\n      }\n      return result;\n    });\n  };\n}","map":{"version":3,"names":["responseIterator","throwServerError","PROTOCOL_ERRORS_SYMBOL","isApolloPayloadResult","hasOwnProperty","Object","prototype","readMultipartBody","response","observer","TextDecoder","undefined","Error","decoder","contentType","_a","headers","get","delimiter","boundaryVal","includes","substring","indexOf","length","replace","trim","boundary","concat","buffer","iterator","running","next","_f","_j","sent","value","done","chunk","decode","searchFrom","bi","message","_g","slice","i","parseHeaders","contentType_1","toLowerCase","body","result","parseJsonBody","keys","__assign","payload","extensions","_h","errors","_b","call","_c","hasNext","_d","complete","err","handleError","_e","headerText","headersInit","split","forEach","line","name_1","bodyText","status","getResult","JSON","parse","parseError","name","statusCode","data","error","readJsonBody","operation","parseAndCheckHttpResponse","then","catch","operations","text","Array","isArray","map","op","operationName"],"sources":["/data/stackhub-web/plugins/myapps/node_modules/@apollo/src/link/http/parseAndCheckHttpResponse.ts"],"sourcesContent":["import { responseIterator } from \"./responseIterator\";\nimport { Operation } from \"../core\";\nimport { throwServerError } from \"../utils\";\nimport { PROTOCOL_ERRORS_SYMBOL } from '../../errors';\nimport { Observer } from \"../../utilities\";\nimport {\n  isApolloPayloadResult\n} from '../../utilities/common/incrementalResult';\n\nconst { hasOwnProperty } = Object.prototype;\n\nexport type ServerParseError = Error & {\n  response: Response;\n  statusCode: number;\n  bodyText: string;\n};\n\nexport async function readMultipartBody<\n  T extends object = Record<string, unknown>\n>(response: Response, observer: Observer<T>) {\n  if (TextDecoder === undefined) {\n    throw new Error(\n      \"TextDecoder must be defined in the environment: please import a polyfill.\"\n    );\n  }\n  const decoder = new TextDecoder(\"utf-8\");\n  const contentType = response.headers?.get(\"content-type\");\n  const delimiter = \"boundary=\";\n\n  // parse boundary value and ignore any subsequent name/value pairs after ;\n  // https://www.rfc-editor.org/rfc/rfc9110.html#name-parameters\n  // e.g. multipart/mixed;boundary=\"graphql\";deferSpec=20220824\n  // if no boundary is specified, default to -\n  const boundaryVal = contentType?.includes(delimiter)\n    ? contentType\n        ?.substring(contentType?.indexOf(delimiter) + delimiter.length)\n        .replace(/['\"]/g, \"\")\n        .replace(/\\;(.*)/gm, \"\")\n        .trim()\n    : \"-\";\n\n  const boundary = `\\r\\n--${boundaryVal}`;\n  let buffer = \"\";\n  const iterator = responseIterator(response);\n  let running = true;\n\n  while (running) {\n    const { value, done } = await iterator.next();\n    const chunk = typeof value === \"string\" ? value : decoder.decode(value);\n    const searchFrom = buffer.length - boundary.length + 1;\n    running = !done;\n    buffer += chunk;\n    let bi = buffer.indexOf(boundary, searchFrom);\n\n    while (bi > -1) {\n      let message: string;\n      [message, buffer] = [\n        buffer.slice(0, bi),\n        buffer.slice(bi + boundary.length),\n      ];\n      const i = message.indexOf(\"\\r\\n\\r\\n\");\n      const headers = parseHeaders(message.slice(0, i));\n      const contentType = headers[\"content-type\"];\n      if (\n        contentType &&\n        contentType.toLowerCase().indexOf(\"application/json\") === -1\n      ) {\n        throw new Error(\n          \"Unsupported patch content type: application/json is required.\"\n        );\n      }\n      // nb: Technically you'd want to slice off the beginning \"\\r\\n\" but since\n      // this is going to be `JSON.parse`d there is no need.\n      const body = message.slice(i);\n\n      if (body) {\n        try {\n          const result = parseJsonBody<T>(response, body);\n          if (\n            Object.keys(result).length > 1 ||\n            \"data\" in result ||\n            \"incremental\" in result ||\n            \"errors\" in result ||\n            \"payload\" in result\n          ) {\n            if (isApolloPayloadResult(result)) {\n              let next = {};\n              if (\"payload\" in result) {\n                next = { ...result.payload };\n              }\n              if (\"errors\" in result) {\n                next = {\n                  ...next,\n                  extensions: {\n                    ...(\"extensions\" in next ? next.extensions : null as any),\n                    [PROTOCOL_ERRORS_SYMBOL]: result.errors\n                  },\n                };\n              }\n              observer.next?.(next as T);\n            } else {\n              // for the last chunk with only `hasNext: false`\n              // we don't need to call observer.next as there is no data/errors\n              observer.next?.(result);\n            }\n          } else if (\n            // If the chunk contains only a \"hasNext: false\", we can call\n            // observer.complete() immediately.\n            Object.keys(result).length === 1 &&\n            \"hasNext\" in result &&\n            !result.hasNext\n          ) {\n            observer.complete?.();\n          }\n        } catch (err) {\n          handleError(err, observer);\n        }\n      }\n      bi = buffer.indexOf(boundary);\n    }\n  }\n  observer.complete?.();\n}\n\nexport function parseHeaders(headerText: string): Record<string, string> {\n  const headersInit: Record<string, string> = {};\n  headerText.split(\"\\n\").forEach((line) => {\n    const i = line.indexOf(\":\");\n    if (i > -1) {\n      // normalize headers to lowercase\n      const name = line.slice(0, i).trim().toLowerCase();\n      const value = line.slice(i + 1).trim();\n      headersInit[name] = value;\n    }\n  });\n  return headersInit;\n}\n\nexport function parseJsonBody<T>(response: Response, bodyText: string): T {\n  if (response.status >= 300) {\n    // Network error\n    const getResult = (): Record<string, unknown> | string => {\n      try {\n        return JSON.parse(bodyText);\n      } catch (err) {\n        return bodyText;\n      }\n    };\n    throwServerError(\n      response,\n      getResult(),\n      `Response not successful: Received status code ${response.status}`\n    );\n  }\n\n  try {\n    return JSON.parse(bodyText) as T;\n  } catch (err) {\n    const parseError = err as ServerParseError;\n    parseError.name = \"ServerParseError\";\n    parseError.response = response;\n    parseError.statusCode = response.status;\n    parseError.bodyText = bodyText;\n    throw parseError;\n  }\n}\n\nexport function handleError(err: any, observer: Observer<any>) {\n  if (err.name === \"AbortError\") return;\n  // if it is a network error, BUT there is graphql result info fire\n  // the next observer before calling error this gives apollo-client\n  // (and react-apollo) the `graphqlErrors` and `networkErrors` to\n  // pass to UI this should only happen if we *also* have data as\n  // part of the response key per the spec\n  if (err.result && err.result.errors && err.result.data) {\n    // if we don't call next, the UI can only show networkError\n    // because AC didn't get any graphqlErrors this is graphql\n    // execution result info (i.e errors and possibly data) this is\n    // because there is no formal spec how errors should translate to\n    // http status codes. So an auth error (401) could have both data\n    // from a public field, errors from a private field, and a status\n    // of 401\n    // {\n    //  user { // this will have errors\n    //    firstName\n    //  }\n    //  products { // this is public so will have data\n    //    cost\n    //  }\n    // }\n    //\n    // the result of above *could* look like this:\n    // {\n    //   data: { products: [{ cost: \"$10\" }] },\n    //   errors: [{\n    //      message: 'your session has timed out',\n    //      path: []\n    //   }]\n    // }\n    // status code of above would be a 401\n    // in the UI you want to show data where you can, errors as data where you can\n    // and use correct http status codes\n    observer.next?.(err.result);\n  }\n\n  observer.error?.(err);\n}\n\nexport function readJsonBody<T = Record<string, unknown>>(\n  response: Response,\n  operation: Operation,\n  observer: Observer<T>\n) {\n  parseAndCheckHttpResponse(operation)(response)\n    .then((result) => {\n      observer.next?.(result);\n      observer.complete?.();\n    })\n    .catch((err) => handleError(err, observer));\n}\n\nexport function parseAndCheckHttpResponse(operations: Operation | Operation[]) {\n  return (response: Response) =>\n    response\n      .text()\n      .then((bodyText) => parseJsonBody(response, bodyText))\n      .then((result: any) => {\n        if (response.status >= 300) {\n          // Network error\n          throwServerError(\n            response,\n            result,\n            `Response not successful: Received status code ${response.status}`\n          );\n        }\n        if (\n          !Array.isArray(result) &&\n          !hasOwnProperty.call(result, \"data\") &&\n          !hasOwnProperty.call(result, \"errors\")\n        ) {\n          // Data error\n          throwServerError(\n            response,\n            result,\n            `Server response was missing for query '${\n              Array.isArray(operations)\n                ? operations.map((op) => op.operationName)\n                : operations.operationName\n            }'.`\n          );\n        }\n        return result;\n      });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}