{"ast":null,"code":"import _classCallCheck from \"/data/stackhub-web/plugins/myapps/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/data/stackhub-web/plugins/myapps/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/data/stackhub-web/plugins/myapps/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/data/stackhub-web/plugins/myapps/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport * as React from 'react';\nimport { canUseDOM } from './util';\n/**\n * This function is a helper for handling basic arrow keyboard interactions. If a component already has its own key handler and event start up/tear down, this function may be easier to integrate in over the full component.\n *\n * @param {event} event Event triggered by the keyboard\n * @param {element[]} navigableElements Valid traversable elements of the container\n * @param {function} isActiveElement Callback to determine if a given element from the navigable elements array is the active element of the page\n * @param {function} getFocusableElement Callback returning the focusable element of a given element from the navigable elements array\n * @param {string[]} validSiblingTags Valid sibling tags that horizontal arrow handling will focus\n * @param {boolean} noVerticalArrowHandling Flag indicating that the included vertical arrow key handling should be ignored\n * @param {boolean} noHorizontalArrowHandling Flag indicating that the included horizontal arrow key handling should be ignored\n * @param {boolean} updateTabIndex Flag indicating that the tabIndex of the currently focused element and next focused element should be updated, in the case of using a roving tabIndex\n * @param {boolean} onlyTraverseSiblings Flag indicating that next focusable element of a horizontal movement will be this element's sibling\n */\nexport var handleArrows = function handleArrows(event, navigableElements) {\n  var isActiveElement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (element) {\n    return document.activeElement.contains(element);\n  };\n  var getFocusableElement = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (element) {\n    return element;\n  };\n  var validSiblingTags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ['A', 'BUTTON', 'INPUT'];\n  var noVerticalArrowHandling = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var noHorizontalArrowHandling = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  var updateTabIndex = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : true;\n  var onlyTraverseSiblings = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : true;\n  var activeElement = document.activeElement;\n  var key = event.key;\n  var moveTarget = null;\n  // Handle vertical arrow keys. If noVerticalArrowHandling is passed, skip this block\n  if (!noVerticalArrowHandling) {\n    if (['ArrowUp', 'ArrowDown'].includes(key)) {\n      event.preventDefault();\n      event.stopImmediatePropagation(); // For menus in menus\n      // Traverse navigableElements to find the element which is currently active\n      var currentIndex = -1;\n      // while (currentIndex === -1) {\n      navigableElements.forEach(function (element, index) {\n        if (isActiveElement(element)) {\n          // Once found, move up or down the array by 1. Determined by the vertical arrow key direction\n          var increment = 0;\n          // keep increasing the increment until you've tried the whole navigableElement\n          while (!moveTarget && increment < navigableElements.length && increment * -1 < navigableElements.length) {\n            key === 'ArrowUp' ? increment-- : increment++;\n            currentIndex = index + increment;\n            if (currentIndex >= navigableElements.length) {\n              currentIndex = 0;\n            }\n            if (currentIndex < 0) {\n              currentIndex = navigableElements.length - 1;\n            }\n            // Set the next target element (undefined if none found)\n            moveTarget = getFocusableElement(navigableElements[currentIndex]);\n          }\n        }\n      });\n      // }\n    }\n  }\n  // Handle horizontal arrow keys. If noHorizontalArrowHandling is passed, skip this block\n  if (!noHorizontalArrowHandling) {\n    if (['ArrowLeft', 'ArrowRight'].includes(key)) {\n      event.preventDefault();\n      event.stopImmediatePropagation(); // For menus in menus\n      var _currentIndex = -1;\n      navigableElements.forEach(function (element, index) {\n        if (isActiveElement(element)) {\n          var activeRow = navigableElements[index].querySelectorAll(validSiblingTags.join(',')); // all focusable elements in my row\n          if (!activeRow.length || onlyTraverseSiblings) {\n            var nextSibling = activeElement;\n            // While a sibling exists, check each sibling to determine if it should be focussed\n            while (nextSibling) {\n              // Set the next checked sibling, determined by the horizontal arrow key direction\n              nextSibling = key === 'ArrowLeft' ? nextSibling.previousElementSibling : nextSibling.nextElementSibling;\n              if (nextSibling) {\n                if (validSiblingTags.includes(nextSibling.tagName)) {\n                  // If the sibling's tag is included in validSiblingTags, set the next target element and break the loop\n                  moveTarget = nextSibling;\n                  break;\n                }\n                // If the sibling's tag is not valid, skip to the next sibling if possible\n              }\n            }\n          } else {\n            activeRow.forEach(function (focusableElement, index) {\n              if (event.target === focusableElement) {\n                // Once found, move up or down the array by 1. Determined by the vertical arrow key direction\n                var increment = key === 'ArrowLeft' ? -1 : 1;\n                _currentIndex = index + increment;\n                if (_currentIndex >= activeRow.length) {\n                  _currentIndex = 0;\n                }\n                if (_currentIndex < 0) {\n                  _currentIndex = activeRow.length - 1;\n                }\n                // Set the next target element\n                moveTarget = activeRow[_currentIndex];\n              }\n            });\n          }\n        }\n      });\n    }\n  }\n  if (moveTarget) {\n    // If updateTabIndex is true, set the previously focussed element's tabIndex to -1 and the next focussed element's tabIndex to 0\n    // This updates the tabIndex for a roving tabIndex\n    if (updateTabIndex) {\n      activeElement.tabIndex = -1;\n      moveTarget.tabIndex = 0;\n    }\n    // If a move target has been set by either arrow handler, focus that target\n    moveTarget.focus();\n  }\n};\n/**\n * This function is a helper for setting the initial tabIndexes in a roving tabIndex\n *\n * @param {HTMLElement[]} options Array of elements which should have a tabIndex of -1, except for the first element which will have a tabIndex of 0\n */\nexport var setTabIndex = function setTabIndex(options) {\n  if (options && options.length > 0) {\n    // Iterate the options and set the tabIndex to -1 on every option\n    options.forEach(function (option) {\n      option.tabIndex = -1;\n    });\n    // Manually set the tabIndex of the first option to 0\n    options[0].tabIndex = 0;\n  }\n};\nexport var KeyboardHandler = /*#__PURE__*/function (_React$Component) {\n  _inherits(KeyboardHandler, _React$Component);\n  var _super = _createSuper(KeyboardHandler);\n  function KeyboardHandler() {\n    var _this;\n    _classCallCheck(this, KeyboardHandler);\n    _this = _super.apply(this, arguments);\n    _this.keyHandler = function (event) {\n      var isEventFromContainer = _this.props.isEventFromContainer;\n      // If the passed keyboard event is not from the container, ignore the event by returning\n      if (isEventFromContainer ? !isEventFromContainer(event) : !_this._isEventFromContainer(event)) {\n        return;\n      }\n      var _this$props = _this.props,\n        isActiveElement = _this$props.isActiveElement,\n        getFocusableElement = _this$props.getFocusableElement,\n        noVerticalArrowHandling = _this$props.noVerticalArrowHandling,\n        noHorizontalArrowHandling = _this$props.noHorizontalArrowHandling,\n        noEnterHandling = _this$props.noEnterHandling,\n        noSpaceHandling = _this$props.noSpaceHandling,\n        updateTabIndex = _this$props.updateTabIndex,\n        validSiblingTags = _this$props.validSiblingTags,\n        additionalKeyHandler = _this$props.additionalKeyHandler,\n        createNavigableElements = _this$props.createNavigableElements,\n        onlyTraverseSiblings = _this$props.onlyTraverseSiblings;\n      // Pass the event off to be handled by any custom handler\n      additionalKeyHandler && additionalKeyHandler(event);\n      // Initalize navigableElements from the createNavigableElements callback\n      var navigableElements = createNavigableElements();\n      if (!navigableElements) {\n        // eslint-disable-next-line no-console\n        console.warn('No navigable elements have been passed to the KeyboardHandler. Keyboard navigation provided by this component will be ignored.');\n        return;\n      }\n      var key = event.key;\n      // Handle enter key. If noEnterHandling is passed, skip this block\n      if (!noEnterHandling) {\n        if (key === 'Enter') {\n          event.preventDefault();\n          event.stopImmediatePropagation(); // For menus in menus\n          document.activeElement.click();\n        }\n      }\n      // Handle space key. If noSpaceHandling is passed, skip this block\n      if (!noSpaceHandling) {\n        if (key === ' ') {\n          event.preventDefault();\n          event.stopImmediatePropagation(); // For menus in menus\n          document.activeElement.click();\n        }\n      }\n      // Inject helper handler for arrow navigation\n      handleArrows(event, navigableElements, isActiveElement, getFocusableElement, validSiblingTags, noVerticalArrowHandling, noHorizontalArrowHandling, updateTabIndex, onlyTraverseSiblings);\n    };\n    _this._isEventFromContainer = function (event) {\n      var containerRef = _this.props.containerRef;\n      return containerRef.current && containerRef.current.contains(event.target);\n    };\n    return _this;\n  }\n  _createClass(KeyboardHandler, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (canUseDOM) {\n        window.addEventListener('keydown', this.keyHandler);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (canUseDOM) {\n        window.removeEventListener('keydown', this.keyHandler);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return null;\n    }\n  }]);\n  return KeyboardHandler;\n}(React.Component);\nKeyboardHandler.displayName = 'KeyboardHandler';\nKeyboardHandler.defaultProps = {\n  containerRef: null,\n  createNavigableElements: function createNavigableElements() {\n    return null;\n  },\n  isActiveElement: function isActiveElement(navigableElement) {\n    return document.activeElement === navigableElement;\n  },\n  getFocusableElement: function getFocusableElement(navigableElement) {\n    return navigableElement;\n  },\n  validSiblingTags: ['BUTTON', 'A'],\n  onlyTraverseSiblings: true,\n  updateTabIndex: true,\n  noHorizontalArrowHandling: false,\n  noVerticalArrowHandling: false,\n  noEnterHandling: false,\n  noSpaceHandling: false\n};","map":{"version":3,"names":["React","canUseDOM","handleArrows","event","navigableElements","isActiveElement","arguments","length","undefined","element","document","activeElement","contains","getFocusableElement","validSiblingTags","noVerticalArrowHandling","noHorizontalArrowHandling","updateTabIndex","onlyTraverseSiblings","key","moveTarget","includes","preventDefault","stopImmediatePropagation","currentIndex","forEach","index","increment","activeRow","querySelectorAll","join","nextSibling","previousElementSibling","nextElementSibling","tagName","focusableElement","target","tabIndex","focus","setTabIndex","options","option","KeyboardHandler","_React$Component","_inherits","_super","_createSuper","_this","_classCallCheck","keyHandler","isEventFromContainer","props","_isEventFromContainer","_this$props","noEnterHandling","noSpaceHandling","additionalKeyHandler","createNavigableElements","console","warn","click","containerRef","current","_createClass","value","componentDidMount","window","addEventListener","componentWillUnmount","removeEventListener","render","Component","displayName","defaultProps","navigableElement"],"sources":["/data/stackhub-web/plugins/myapps/node_modules/@patternfly/react-core/src/helpers/KeyboardHandler.tsx"],"sourcesContent":["import * as React from 'react';\nimport { canUseDOM } from './util';\n\nexport interface KeyboardHandlerProps {\n  /** Reference of the container to apply keyboard interaction */\n  containerRef: React.RefObject<any>;\n  /** Callback returning an array of navigable elements to be traversable via vertical arrow keys. This array should not include non-navigable elements such as disabled elements. */\n  createNavigableElements: () => Element[];\n  /** Callback to determine if a given event is from the container. By default the function conducts a basic check to see if the containerRef contains the event target */\n  isEventFromContainer?: (event: KeyboardEvent) => boolean;\n  /** Additional key handling outside of the included arrow keys, enter, and space handling */\n  additionalKeyHandler?: (event: KeyboardEvent) => void;\n  /** Callback to determine if a given element from the navigable elements array is the active element of the page */\n  isActiveElement?: (navigableElement: Element) => boolean;\n  /** Callback returning the focusable element of a given element from the navigable elements array */\n  getFocusableElement?: (navigableElement: Element) => Element;\n  /** Valid sibling tags that horizontal arrow handling will focus */\n  validSiblingTags?: string[];\n  /** Flag indicating that the tabIndex of the currently focused element and next focused element should be updated, in the case of using a roving tabIndex */\n  updateTabIndex?: boolean;\n  /** Flag indicating that next focusable element of a horizontal movement will be this element's sibling */\n  onlyTraverseSiblings?: boolean;\n  /** Flag indicating that the included vertical arrow key handling should be ignored */\n  noVerticalArrowHandling?: boolean;\n  /** Flag indicating that the included horizontal arrow key handling should be ignored */\n  noHorizontalArrowHandling?: boolean;\n  /** Flag indicating that the included enter key handling should be ignored */\n  noEnterHandling?: boolean;\n  /** Flag indicating that the included space key handling should be ignored */\n  noSpaceHandling?: boolean;\n}\n\n/**\n * This function is a helper for handling basic arrow keyboard interactions. If a component already has its own key handler and event start up/tear down, this function may be easier to integrate in over the full component.\n *\n * @param {event} event Event triggered by the keyboard\n * @param {element[]} navigableElements Valid traversable elements of the container\n * @param {function} isActiveElement Callback to determine if a given element from the navigable elements array is the active element of the page\n * @param {function} getFocusableElement Callback returning the focusable element of a given element from the navigable elements array\n * @param {string[]} validSiblingTags Valid sibling tags that horizontal arrow handling will focus\n * @param {boolean} noVerticalArrowHandling Flag indicating that the included vertical arrow key handling should be ignored\n * @param {boolean} noHorizontalArrowHandling Flag indicating that the included horizontal arrow key handling should be ignored\n * @param {boolean} updateTabIndex Flag indicating that the tabIndex of the currently focused element and next focused element should be updated, in the case of using a roving tabIndex\n * @param {boolean} onlyTraverseSiblings Flag indicating that next focusable element of a horizontal movement will be this element's sibling\n */\nexport const handleArrows = (\n  event: KeyboardEvent,\n  navigableElements: Element[],\n  isActiveElement: (element: Element) => boolean = element => document.activeElement.contains(element),\n  getFocusableElement: (element: Element) => Element = element => element,\n  validSiblingTags: string[] = ['A', 'BUTTON', 'INPUT'],\n  noVerticalArrowHandling: boolean = false,\n  noHorizontalArrowHandling: boolean = false,\n  updateTabIndex: boolean = true,\n  onlyTraverseSiblings: boolean = true\n) => {\n  const activeElement = document.activeElement;\n  const key = event.key;\n  let moveTarget: Element = null;\n\n  // Handle vertical arrow keys. If noVerticalArrowHandling is passed, skip this block\n  if (!noVerticalArrowHandling) {\n    if (['ArrowUp', 'ArrowDown'].includes(key)) {\n      event.preventDefault();\n      event.stopImmediatePropagation(); // For menus in menus\n\n      // Traverse navigableElements to find the element which is currently active\n      let currentIndex = -1;\n      // while (currentIndex === -1) {\n      navigableElements.forEach((element, index) => {\n        if (isActiveElement(element)) {\n          // Once found, move up or down the array by 1. Determined by the vertical arrow key direction\n          let increment = 0;\n\n          // keep increasing the increment until you've tried the whole navigableElement\n          while (!moveTarget && increment < navigableElements.length && increment * -1 < navigableElements.length) {\n            key === 'ArrowUp' ? increment-- : increment++;\n            currentIndex = index + increment;\n\n            if (currentIndex >= navigableElements.length) {\n              currentIndex = 0;\n            }\n            if (currentIndex < 0) {\n              currentIndex = navigableElements.length - 1;\n            }\n\n            // Set the next target element (undefined if none found)\n            moveTarget = getFocusableElement(navigableElements[currentIndex]);\n          }\n        }\n      });\n      // }\n    }\n  }\n\n  // Handle horizontal arrow keys. If noHorizontalArrowHandling is passed, skip this block\n  if (!noHorizontalArrowHandling) {\n    if (['ArrowLeft', 'ArrowRight'].includes(key)) {\n      event.preventDefault();\n      event.stopImmediatePropagation(); // For menus in menus\n\n      let currentIndex = -1;\n      navigableElements.forEach((element, index) => {\n        if (isActiveElement(element)) {\n          const activeRow = navigableElements[index].querySelectorAll(validSiblingTags.join(',')); // all focusable elements in my row\n\n          if (!activeRow.length || onlyTraverseSiblings) {\n            let nextSibling = activeElement;\n            // While a sibling exists, check each sibling to determine if it should be focussed\n            while (nextSibling) {\n              // Set the next checked sibling, determined by the horizontal arrow key direction\n              nextSibling = key === 'ArrowLeft' ? nextSibling.previousElementSibling : nextSibling.nextElementSibling;\n              if (nextSibling) {\n                if (validSiblingTags.includes(nextSibling.tagName)) {\n                  // If the sibling's tag is included in validSiblingTags, set the next target element and break the loop\n                  moveTarget = nextSibling;\n                  break;\n                }\n                // If the sibling's tag is not valid, skip to the next sibling if possible\n              }\n            }\n          } else {\n            activeRow.forEach((focusableElement, index) => {\n              if (event.target === focusableElement) {\n                // Once found, move up or down the array by 1. Determined by the vertical arrow key direction\n                const increment = key === 'ArrowLeft' ? -1 : 1;\n                currentIndex = index + increment;\n                if (currentIndex >= activeRow.length) {\n                  currentIndex = 0;\n                }\n                if (currentIndex < 0) {\n                  currentIndex = activeRow.length - 1;\n                }\n\n                // Set the next target element\n                moveTarget = activeRow[currentIndex];\n              }\n            });\n          }\n        }\n      });\n    }\n  }\n\n  if (moveTarget) {\n    // If updateTabIndex is true, set the previously focussed element's tabIndex to -1 and the next focussed element's tabIndex to 0\n    // This updates the tabIndex for a roving tabIndex\n    if (updateTabIndex) {\n      (activeElement as HTMLElement).tabIndex = -1;\n      (moveTarget as HTMLElement).tabIndex = 0;\n    }\n    // If a move target has been set by either arrow handler, focus that target\n    (moveTarget as HTMLElement).focus();\n  }\n};\n\n/**\n * This function is a helper for setting the initial tabIndexes in a roving tabIndex\n *\n * @param {HTMLElement[]} options Array of elements which should have a tabIndex of -1, except for the first element which will have a tabIndex of 0\n */\nexport const setTabIndex = (options: HTMLElement[]) => {\n  if (options && options.length > 0) {\n    // Iterate the options and set the tabIndex to -1 on every option\n    options.forEach((option: HTMLElement) => {\n      option.tabIndex = -1;\n    });\n    // Manually set the tabIndex of the first option to 0\n    options[0].tabIndex = 0;\n  }\n};\n\nexport class KeyboardHandler extends React.Component<KeyboardHandlerProps> {\n  static displayName = 'KeyboardHandler';\n  static defaultProps: KeyboardHandlerProps = {\n    containerRef: null,\n    createNavigableElements: () => null as Element[],\n    isActiveElement: (navigableElement: Element) => document.activeElement === navigableElement,\n    getFocusableElement: (navigableElement: Element) => navigableElement,\n    validSiblingTags: ['BUTTON', 'A'],\n    onlyTraverseSiblings: true,\n    updateTabIndex: true,\n    noHorizontalArrowHandling: false,\n    noVerticalArrowHandling: false,\n    noEnterHandling: false,\n    noSpaceHandling: false\n  };\n\n  componentDidMount() {\n    if (canUseDOM) {\n      window.addEventListener('keydown', this.keyHandler);\n    }\n  }\n\n  componentWillUnmount() {\n    if (canUseDOM) {\n      window.removeEventListener('keydown', this.keyHandler);\n    }\n  }\n\n  keyHandler = (event: KeyboardEvent) => {\n    const { isEventFromContainer } = this.props;\n    // If the passed keyboard event is not from the container, ignore the event by returning\n    if (isEventFromContainer ? !isEventFromContainer(event) : !this._isEventFromContainer(event)) {\n      return;\n    }\n\n    const {\n      isActiveElement,\n      getFocusableElement,\n      noVerticalArrowHandling,\n      noHorizontalArrowHandling,\n      noEnterHandling,\n      noSpaceHandling,\n      updateTabIndex,\n      validSiblingTags,\n      additionalKeyHandler,\n      createNavigableElements,\n      onlyTraverseSiblings\n    } = this.props;\n\n    // Pass the event off to be handled by any custom handler\n    additionalKeyHandler && additionalKeyHandler(event);\n\n    // Initalize navigableElements from the createNavigableElements callback\n    const navigableElements = createNavigableElements();\n    if (!navigableElements) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'No navigable elements have been passed to the KeyboardHandler. Keyboard navigation provided by this component will be ignored.'\n      );\n      return;\n    }\n    const key = event.key;\n\n    // Handle enter key. If noEnterHandling is passed, skip this block\n    if (!noEnterHandling) {\n      if (key === 'Enter') {\n        event.preventDefault();\n        event.stopImmediatePropagation(); // For menus in menus\n        (document.activeElement as HTMLElement).click();\n      }\n    }\n\n    // Handle space key. If noSpaceHandling is passed, skip this block\n    if (!noSpaceHandling) {\n      if (key === ' ') {\n        event.preventDefault();\n        event.stopImmediatePropagation(); // For menus in menus\n        (document.activeElement as HTMLElement).click();\n      }\n    }\n\n    // Inject helper handler for arrow navigation\n    handleArrows(\n      event,\n      navigableElements,\n      isActiveElement,\n      getFocusableElement,\n      validSiblingTags,\n      noVerticalArrowHandling,\n      noHorizontalArrowHandling,\n      updateTabIndex,\n      onlyTraverseSiblings\n    );\n  };\n\n  _isEventFromContainer = (event: KeyboardEvent) => {\n    const { containerRef } = this.props;\n    return containerRef.current && containerRef.current.contains(event.target as HTMLElement);\n  };\n\n  render() {\n    return null as React.ReactNode;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}