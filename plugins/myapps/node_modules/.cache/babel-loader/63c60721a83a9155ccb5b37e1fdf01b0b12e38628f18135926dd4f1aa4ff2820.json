{"ast":null,"code":"import _toConsumableArray from \"/data/stackhub-web/plugins/myapps/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport getCompositeRect from './dom-utils/getCompositeRect';\nimport getLayoutRect from './dom-utils/getLayoutRect';\nimport listScrollParents from './dom-utils/listScrollParents';\nimport getOffsetParent from './dom-utils/getOffsetParent';\nimport getComputedStyle from './dom-utils/getComputedStyle';\nimport orderModifiers from './utils/orderModifiers';\nimport debounce from './utils/debounce';\nimport validateModifiers from './utils/validateModifiers';\nimport uniqueBy from './utils/uniqueBy';\nimport getBasePlacement from './utils/getBasePlacement';\nimport mergeByName from './utils/mergeByName';\nimport detectOverflow from './utils/detectOverflow';\nimport { isElement } from './dom-utils/instanceOf';\nimport { auto } from './enums';\nexport * from './types';\nexport * from './enums';\nvar INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';\nvar INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n/**\n * @param args\n */\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\n/**\n * @param generatorOptions\n */\nexport function popperGenerator() {\n  var generatorOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _generatorOptions$def = generatorOptions.defaultModifiers,\n    defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n    _generatorOptions$def2 = generatorOptions.defaultOptions,\n    defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOptions;\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign(Object.assign({}, DEFAULT_OPTIONS), defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(options) {\n        cleanupModifierEffects();\n        state.options = Object.assign(Object.assign(Object.assign({}, defaultOptions), state.options), options);\n        state.scrollParents = {\n          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n          popper: listScrollParents(popper)\n        };\n        // Orders the modifiers based on their dependencies and `phase`\n        // properties\n        var orderedModifiers = orderModifiers(mergeByName([].concat(_toConsumableArray(defaultModifiers), _toConsumableArray(state.options.modifiers))));\n        // Strip out disabled modifiers\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        });\n        // Validate the provided modifiers so that the consumer will get warned\n        // if one of the modifiers is invalid for any reason\n        if (false /* __DEV__*/) {\n          var modifiers = uniqueBy([].concat(_toConsumableArray(orderedModifiers), _toConsumableArray(state.options.modifiers)), function (_ref) {\n            var name = _ref.name;\n            return name;\n          });\n          validateModifiers(modifiers);\n          if (getBasePlacement(state.options.placement) === auto) {\n            var flipModifier = state.orderedModifiers.find(function (_ref2) {\n              var name = _ref2.name;\n              return name === 'flip';\n            });\n            if (!flipModifier) {\n              console.error(['Popper: \"auto\" placements require the \"flip\" modifier be', 'present and enabled to work.'].join(' '));\n            }\n          }\n          var _getComputedStyle = getComputedStyle(popper),\n            marginTop = _getComputedStyle.marginTop,\n            marginRight = _getComputedStyle.marginRight,\n            marginBottom = _getComputedStyle.marginBottom,\n            marginLeft = _getComputedStyle.marginLeft;\n          // We no longer take into account `margins` on the popper, and it can\n          // cause bugs with positioning, so we'll warn the consumer\n          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {\n            return parseFloat(margin);\n          })) {\n            console.warn(['Popper: CSS \"margin\" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));\n          }\n        }\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n        var _state$elements = state.elements,\n          reference = _state$elements.reference,\n          popper = _state$elements.popper;\n        // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n        if (!areValidElements(reference, popper)) {\n          if (false /* __DEV__*/) {\n            console.error(INVALID_ELEMENT_ERROR);\n          }\n          return;\n        }\n        // Store the reference and popper rects to be read by modifiers\n        state.rects = {\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n          popper: getLayoutRect(popper)\n        };\n        // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n        state.reset = false;\n        state.placement = state.options.placement;\n        // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n        var __debug_loops__ = 0;\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (false /* __DEV__*/) {\n            __debug_loops__ += 1;\n            if (__debug_loops__ > 100) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n          }\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n          var _state$orderedModifie = state.orderedModifiers[index],\n            fn = _state$orderedModifie.fn,\n            _state$orderedModifie2 = _state$orderedModifie.options,\n            _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n            name = _state$orderedModifie.name;\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n    if (!areValidElements(reference, popper)) {\n      if (false /* __DEV__*/) {\n        console.error(INVALID_ELEMENT_ERROR);\n      }\n      return instance;\n    }\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    });\n    // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n    /**\n     *\n     */\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref3) {\n        var name = _ref3.name,\n          _ref3$options = _ref3.options,\n          options = _ref3$options === void 0 ? {} : _ref3$options,\n          effect = _ref3.effect;\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n          var noopFn = function noopFn() {};\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n    /**\n     *\n     */\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n    return instance;\n  };\n}\nexport var createPopper = popperGenerator();\n// eslint-disable-next-line import/no-unused-modules\nexport { detectOverflow };","map":{"version":3,"names":["getCompositeRect","getLayoutRect","listScrollParents","getOffsetParent","getComputedStyle","orderModifiers","debounce","validateModifiers","uniqueBy","getBasePlacement","mergeByName","detectOverflow","isElement","auto","INVALID_ELEMENT_ERROR","INFINITE_LOOP_ERROR","DEFAULT_OPTIONS","placement","modifiers","strategy","areValidElements","_len","arguments","length","args","Array","_key","some","element","getBoundingClientRect","popperGenerator","generatorOptions","undefined","_generatorOptions$def","defaultModifiers","_generatorOptions$def2","defaultOptions","createPopper","reference","popper","options","state","orderedModifiers","Object","assign","modifiersData","elements","attributes","styles","effectCleanupFns","isDestroyed","instance","setOptions","cleanupModifierEffects","scrollParents","contextElement","concat","_toConsumableArray","filter","m","enabled","_ref","name","flipModifier","find","_ref2","console","error","join","_getComputedStyle","marginTop","marginRight","marginBottom","marginLeft","margin","parseFloat","warn","runModifierEffects","update","forceUpdate","_state$elements","rects","reset","forEach","modifier","data","__debug_loops__","index","_state$orderedModifie","fn","_state$orderedModifie2","Promise","resolve","destroy","then","onFirstUpdate","_ref3","_ref3$options","effect","cleanupFn","noopFn","push"],"sources":["/data/stackhub-web/plugins/myapps/node_modules/@patternfly/react-core/src/helpers/Popper/thirdparty/popper-core/index.ts"],"sourcesContent":["// @ts-nocheck\nimport { State, OptionsGeneric, Modifier, Instance, VirtualElement } from './types';\nimport getCompositeRect from './dom-utils/getCompositeRect';\nimport getLayoutRect from './dom-utils/getLayoutRect';\nimport listScrollParents from './dom-utils/listScrollParents';\nimport getOffsetParent from './dom-utils/getOffsetParent';\nimport getComputedStyle from './dom-utils/getComputedStyle';\nimport orderModifiers from './utils/orderModifiers';\nimport debounce from './utils/debounce';\nimport validateModifiers from './utils/validateModifiers';\nimport uniqueBy from './utils/uniqueBy';\nimport getBasePlacement from './utils/getBasePlacement';\nimport mergeByName from './utils/mergeByName';\nimport detectOverflow from './utils/detectOverflow';\nimport { isElement } from './dom-utils/instanceOf';\nimport { auto } from './enums';\n\nexport * from './types';\nexport * from './enums';\n\nconst INVALID_ELEMENT_ERROR =\n  'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';\nconst INFINITE_LOOP_ERROR =\n  'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\n\nconst DEFAULT_OPTIONS: OptionsGeneric<any> = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n\ninterface PopperGeneratorArgs {\n  defaultModifiers?: Modifier<any, any>[];\n  defaultOptions?: Partial<OptionsGeneric<any>>;\n}\n\n/**\n * @param args\n */\nfunction areValidElements(...args: any[]): boolean {\n  return !args.some(element => !(element && typeof element.getBoundingClientRect === 'function'));\n}\n\n/**\n * @param generatorOptions\n */\nexport function popperGenerator(generatorOptions: PopperGeneratorArgs = {}) {\n  const { defaultModifiers = [], defaultOptions = DEFAULT_OPTIONS } = generatorOptions;\n\n  return function createPopper<TModifier extends Partial<Modifier<any, any>>>(\n    reference: Element | VirtualElement,\n    popper: HTMLElement,\n    options: Partial<OptionsGeneric<TModifier>> = defaultOptions\n  ): Instance {\n    let state: Partial<State> = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: { ...DEFAULT_OPTIONS, ...defaultOptions },\n      modifiersData: {},\n      elements: {\n        reference,\n        popper\n      },\n      attributes: {},\n      styles: {}\n    };\n\n    let effectCleanupFns: (() => void)[] = [];\n    let isDestroyed = false;\n\n    const instance = {\n      state,\n      setOptions(options) {\n        cleanupModifierEffects();\n\n        state.options = {\n          // $FlowFixMe\n          ...defaultOptions,\n          ...state.options,\n          ...options\n        };\n\n        state.scrollParents = {\n          reference: isElement(reference)\n            ? listScrollParents(reference)\n            : reference.contextElement\n            ? listScrollParents(reference.contextElement)\n            : [],\n          popper: listScrollParents(popper)\n        };\n\n        // Orders the modifiers based on their dependencies and `phase`\n        // properties\n        const orderedModifiers = orderModifiers(mergeByName([...defaultModifiers, ...state.options.modifiers]));\n\n        // Strip out disabled modifiers\n        state.orderedModifiers = orderedModifiers.filter(m => m.enabled);\n\n        // Validate the provided modifiers so that the consumer will get warned\n        // if one of the modifiers is invalid for any reason\n        if (false /* __DEV__*/) {\n          const modifiers = uniqueBy([...orderedModifiers, ...state.options.modifiers], ({ name }) => name);\n\n          validateModifiers(modifiers);\n\n          if (getBasePlacement(state.options.placement) === auto) {\n            const flipModifier = state.orderedModifiers.find(({ name }) => name === 'flip');\n\n            if (!flipModifier) {\n              console.error(\n                ['Popper: \"auto\" placements require the \"flip\" modifier be', 'present and enabled to work.'].join(' ')\n              );\n            }\n          }\n\n          const { marginTop, marginRight, marginBottom, marginLeft } = getComputedStyle(popper);\n\n          // We no longer take into account `margins` on the popper, and it can\n          // cause bugs with positioning, so we'll warn the consumer\n          if ([marginTop, marginRight, marginBottom, marginLeft].some(margin => parseFloat(margin))) {\n            console.warn(\n              [\n                'Popper: CSS \"margin\" styles cannot be used to apply padding',\n                'between the popper and its reference element or boundary.',\n                'To replicate margin, use the `offset` modifier, as well as',\n                'the `padding` option in the `preventOverflow` and `flip`',\n                'modifiers.'\n              ].join(' ')\n            );\n          }\n        }\n\n        runModifierEffects();\n\n        return instance.update();\n      },\n\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        const { reference, popper } = state.elements;\n\n        // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n        if (!areValidElements(reference, popper)) {\n          if (false /* __DEV__*/) {\n            console.error(INVALID_ELEMENT_ERROR);\n          }\n          return;\n        }\n\n        // Store the reference and popper rects to be read by modifiers\n        state.rects = {\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n          popper: getLayoutRect(popper)\n        };\n\n        // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n        state.reset = false;\n\n        state.placement = state.options.placement;\n\n        // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n        state.orderedModifiers.forEach(\n          modifier =>\n            (state.modifiersData[modifier.name] = {\n              ...modifier.data\n            })\n        );\n\n        let __debug_loops__ = 0;\n        for (let index = 0; index < state.orderedModifiers.length; index++) {\n          if (false /* __DEV__*/) {\n            __debug_loops__ += 1;\n            if (__debug_loops__ > 100) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n          }\n\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          const { fn, options = {}, name } = state.orderedModifiers[index];\n\n          if (typeof fn === 'function') {\n            state = fn({ state, options, name, instance }) || state;\n          }\n        }\n      },\n\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce<Partial<State>>(\n        () =>\n          new Promise<Partial<State>>(resolve => {\n            instance.forceUpdate();\n            resolve(state);\n          })\n      ),\n\n      destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      if (false /* __DEV__*/) {\n        console.error(INVALID_ELEMENT_ERROR);\n      }\n      return instance;\n    }\n\n    instance.setOptions(options).then(state => {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    });\n\n    // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n    /**\n     *\n     */\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(({ name, options = {}, effect }) => {\n        if (typeof effect === 'function') {\n          const cleanupFn = effect({ state, name, instance, options });\n          const noopFn = () => {};\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    /**\n     *\n     */\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(fn => fn());\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\n\nexport const createPopper = popperGenerator();\n\n// eslint-disable-next-line import/no-unused-modules\nexport { detectOverflow };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}