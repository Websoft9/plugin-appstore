{"ast":null,"code":"import { InvariantError } from \"../globals/index.js\";\nimport { isNonNullObject } from \"../common/objects.js\";\nimport { getFragmentFromSelection } from \"./fragments.js\";\nexport function makeReference(id) {\n  return {\n    __ref: String(id)\n  };\n}\nexport function isReference(obj) {\n  return Boolean(obj && typeof obj === 'object' && typeof obj.__ref === 'string');\n}\nexport function isDocumentNode(value) {\n  return isNonNullObject(value) && value.kind === \"Document\" && Array.isArray(value.definitions);\n}\nfunction isStringValue(value) {\n  return value.kind === 'StringValue';\n}\nfunction isBooleanValue(value) {\n  return value.kind === 'BooleanValue';\n}\nfunction isIntValue(value) {\n  return value.kind === 'IntValue';\n}\nfunction isFloatValue(value) {\n  return value.kind === 'FloatValue';\n}\nfunction isVariable(value) {\n  return value.kind === 'Variable';\n}\nfunction isObjectValue(value) {\n  return value.kind === 'ObjectValue';\n}\nfunction isListValue(value) {\n  return value.kind === 'ListValue';\n}\nfunction isEnumValue(value) {\n  return value.kind === 'EnumValue';\n}\nfunction isNullValue(value) {\n  return value.kind === 'NullValue';\n}\nexport function valueToObjectRepresentation(argObj, name, value, variables) {\n  if (isIntValue(value) || isFloatValue(value)) {\n    argObj[name.value] = Number(value.value);\n  } else if (isBooleanValue(value) || isStringValue(value)) {\n    argObj[name.value] = value.value;\n  } else if (isObjectValue(value)) {\n    var nestedArgObj_1 = {};\n    value.fields.map(function (obj) {\n      return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);\n    });\n    argObj[name.value] = nestedArgObj_1;\n  } else if (isVariable(value)) {\n    var variableValue = (variables || {})[value.name.value];\n    argObj[name.value] = variableValue;\n  } else if (isListValue(value)) {\n    argObj[name.value] = value.values.map(function (listValue) {\n      var nestedArgArrayObj = {};\n      valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);\n      return nestedArgArrayObj[name.value];\n    });\n  } else if (isEnumValue(value)) {\n    argObj[name.value] = value.value;\n  } else if (isNullValue(value)) {\n    argObj[name.value] = null;\n  } else {\n    throw __DEV__ ? new InvariantError(\"The inline argument \\\"\".concat(name.value, \"\\\" of kind \\\"\").concat(value.kind, \"\\\"\") + 'is not supported. Use variables instead of inline arguments to ' + 'overcome this limitation.') : new InvariantError(55);\n  }\n}\nexport function storeKeyNameFromField(field, variables) {\n  var directivesObj = null;\n  if (field.directives) {\n    directivesObj = {};\n    field.directives.forEach(function (directive) {\n      directivesObj[directive.name.value] = {};\n      if (directive.arguments) {\n        directive.arguments.forEach(function (_a) {\n          var name = _a.name,\n            value = _a.value;\n          return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);\n        });\n      }\n    });\n  }\n  var argObj = null;\n  if (field.arguments && field.arguments.length) {\n    argObj = {};\n    field.arguments.forEach(function (_a) {\n      var name = _a.name,\n        value = _a.value;\n      return valueToObjectRepresentation(argObj, name, value, variables);\n    });\n  }\n  return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\nvar KNOWN_DIRECTIVES = ['connection', 'include', 'skip', 'client', 'rest', 'export'];\nexport var getStoreKeyName = Object.assign(function (fieldName, args, directives) {\n  if (args && directives && directives['connection'] && directives['connection']['key']) {\n    if (directives['connection']['filter'] && directives['connection']['filter'].length > 0) {\n      var filterKeys = directives['connection']['filter'] ? directives['connection']['filter'] : [];\n      filterKeys.sort();\n      var filteredArgs_1 = {};\n      filterKeys.forEach(function (key) {\n        filteredArgs_1[key] = args[key];\n      });\n      return \"\".concat(directives['connection']['key'], \"(\").concat(stringify(filteredArgs_1), \")\");\n    } else {\n      return directives['connection']['key'];\n    }\n  }\n  var completeFieldName = fieldName;\n  if (args) {\n    var stringifiedArgs = stringify(args);\n    completeFieldName += \"(\".concat(stringifiedArgs, \")\");\n  }\n  if (directives) {\n    Object.keys(directives).forEach(function (key) {\n      if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;\n      if (directives[key] && Object.keys(directives[key]).length) {\n        completeFieldName += \"@\".concat(key, \"(\").concat(stringify(directives[key]), \")\");\n      } else {\n        completeFieldName += \"@\".concat(key);\n      }\n    });\n  }\n  return completeFieldName;\n}, {\n  setStringify: function setStringify(s) {\n    var previous = stringify;\n    stringify = s;\n    return previous;\n  }\n});\nvar stringify = function defaultStringify(value) {\n  return JSON.stringify(value, stringifyReplacer);\n};\nfunction stringifyReplacer(_key, value) {\n  if (isNonNullObject(value) && !Array.isArray(value)) {\n    value = Object.keys(value).sort().reduce(function (copy, key) {\n      copy[key] = value[key];\n      return copy;\n    }, {});\n  }\n  return value;\n}\nexport function argumentsObjectFromField(field, variables) {\n  if (field.arguments && field.arguments.length) {\n    var argObj_1 = {};\n    field.arguments.forEach(function (_a) {\n      var name = _a.name,\n        value = _a.value;\n      return valueToObjectRepresentation(argObj_1, name, value, variables);\n    });\n    return argObj_1;\n  }\n  return null;\n}\nexport function resultKeyNameFromField(field) {\n  return field.alias ? field.alias.value : field.name.value;\n}\nexport function getTypenameFromResult(result, selectionSet, fragmentMap) {\n  var fragments;\n  for (var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++) {\n    var selection = _a[_i];\n    if (isField(selection)) {\n      if (selection.name.value === '__typename') {\n        return result[resultKeyNameFromField(selection)];\n      }\n    } else if (fragments) {\n      fragments.push(selection);\n    } else {\n      fragments = [selection];\n    }\n  }\n  if (typeof result.__typename === 'string') {\n    return result.__typename;\n  }\n  if (fragments) {\n    for (var _b = 0, fragments_1 = fragments; _b < fragments_1.length; _b++) {\n      var selection = fragments_1[_b];\n      var typename = getTypenameFromResult(result, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);\n      if (typeof typename === 'string') {\n        return typename;\n      }\n    }\n  }\n}\nexport function isField(selection) {\n  return selection.kind === 'Field';\n}\nexport function isInlineFragment(selection) {\n  return selection.kind === 'InlineFragment';\n}","map":{"version":3,"names":["InvariantError","isNonNullObject","getFragmentFromSelection","makeReference","id","__ref","String","isReference","obj","Boolean","isDocumentNode","value","kind","Array","isArray","definitions","isStringValue","isBooleanValue","isIntValue","isFloatValue","isVariable","isObjectValue","isListValue","isEnumValue","isNullValue","valueToObjectRepresentation","argObj","name","variables","Number","nestedArgObj_1","fields","map","variableValue","values","listValue","nestedArgArrayObj","__DEV__","concat","storeKeyNameFromField","field","directivesObj","directives","forEach","directive","arguments","_a","length","getStoreKeyName","KNOWN_DIRECTIVES","Object","assign","fieldName","args","filterKeys","sort","filteredArgs_1","key","stringify","completeFieldName","stringifiedArgs","keys","indexOf","setStringify","s","previous","defaultStringify","JSON","stringifyReplacer","_key","reduce","copy","argumentsObjectFromField","argObj_1","resultKeyNameFromField","alias","getTypenameFromResult","result","selectionSet","fragmentMap","fragments","_i","selections","selection","isField","push","__typename","_b","fragments_1","typename","isInlineFragment"],"sources":["/data/stackhub-web/plugins/myapps/node_modules/@apollo/src/utilities/graphql/storeUtils.ts"],"sourcesContent":["import { InvariantError } from '../globals';\n\nimport {\n  DirectiveNode,\n  FieldNode,\n  IntValueNode,\n  FloatValueNode,\n  StringValueNode,\n  BooleanValueNode,\n  ObjectValueNode,\n  ListValueNode,\n  EnumValueNode,\n  NullValueNode,\n  VariableNode,\n  InlineFragmentNode,\n  ValueNode,\n  SelectionNode,\n  NameNode,\n  SelectionSetNode,\n  DocumentNode,\n  FragmentSpreadNode,\n} from 'graphql';\n\nimport { isNonNullObject } from '../common/objects';\nimport { FragmentMap, getFragmentFromSelection } from './fragments';\n\nexport interface Reference {\n  readonly __ref: string;\n}\n\nexport function makeReference(id: string): Reference {\n  return { __ref: String(id) };\n}\n\nexport function isReference(obj: any): obj is Reference {\n  return Boolean(obj && typeof obj === 'object' && typeof obj.__ref === 'string');\n}\n\nexport type StoreValue =\n  | number\n  | string\n  | string[]\n  | Reference\n  | Reference[]\n  | null\n  | undefined\n  | void\n  | Object;\n\nexport interface StoreObject {\n  __typename?: string;\n  [storeFieldName: string]: StoreValue;\n}\n\nexport function isDocumentNode(value: any): value is DocumentNode {\n  return (\n    isNonNullObject(value) &&\n    (value as DocumentNode).kind === \"Document\" &&\n    Array.isArray((value as DocumentNode).definitions)\n  );\n}\n\nfunction isStringValue(value: ValueNode): value is StringValueNode {\n  return value.kind === 'StringValue';\n}\n\nfunction isBooleanValue(value: ValueNode): value is BooleanValueNode {\n  return value.kind === 'BooleanValue';\n}\n\nfunction isIntValue(value: ValueNode): value is IntValueNode {\n  return value.kind === 'IntValue';\n}\n\nfunction isFloatValue(value: ValueNode): value is FloatValueNode {\n  return value.kind === 'FloatValue';\n}\n\nfunction isVariable(value: ValueNode): value is VariableNode {\n  return value.kind === 'Variable';\n}\n\nfunction isObjectValue(value: ValueNode): value is ObjectValueNode {\n  return value.kind === 'ObjectValue';\n}\n\nfunction isListValue(value: ValueNode): value is ListValueNode {\n  return value.kind === 'ListValue';\n}\n\nfunction isEnumValue(value: ValueNode): value is EnumValueNode {\n  return value.kind === 'EnumValue';\n}\n\nfunction isNullValue(value: ValueNode): value is NullValueNode {\n  return value.kind === 'NullValue';\n}\n\nexport function valueToObjectRepresentation(\n  argObj: any,\n  name: NameNode,\n  value: ValueNode,\n  variables?: Object,\n) {\n  if (isIntValue(value) || isFloatValue(value)) {\n    argObj[name.value] = Number(value.value);\n  } else if (isBooleanValue(value) || isStringValue(value)) {\n    argObj[name.value] = value.value;\n  } else if (isObjectValue(value)) {\n    const nestedArgObj = {};\n    value.fields.map(obj =>\n      valueToObjectRepresentation(nestedArgObj, obj.name, obj.value, variables),\n    );\n    argObj[name.value] = nestedArgObj;\n  } else if (isVariable(value)) {\n    const variableValue = (variables || ({} as any))[value.name.value];\n    argObj[name.value] = variableValue;\n  } else if (isListValue(value)) {\n    argObj[name.value] = value.values.map(listValue => {\n      const nestedArgArrayObj = {};\n      valueToObjectRepresentation(\n        nestedArgArrayObj,\n        name,\n        listValue,\n        variables,\n      );\n      return (nestedArgArrayObj as any)[name.value];\n    });\n  } else if (isEnumValue(value)) {\n    argObj[name.value] = (value as EnumValueNode).value;\n  } else if (isNullValue(value)) {\n    argObj[name.value] = null;\n  } else {\n    throw new InvariantError(\n      `The inline argument \"${name.value}\" of kind \"${(value as any).kind}\"` +\n        'is not supported. Use variables instead of inline arguments to ' +\n        'overcome this limitation.',\n    );\n  }\n}\n\nexport function storeKeyNameFromField(\n  field: FieldNode,\n  variables?: Object,\n): string {\n  let directivesObj: any = null;\n  if (field.directives) {\n    directivesObj = {};\n    field.directives.forEach(directive => {\n      directivesObj[directive.name.value] = {};\n\n      if (directive.arguments) {\n        directive.arguments.forEach(({ name, value }) =>\n          valueToObjectRepresentation(\n            directivesObj[directive.name.value],\n            name,\n            value,\n            variables,\n          ),\n        );\n      }\n    });\n  }\n\n  let argObj: any = null;\n  if (field.arguments && field.arguments.length) {\n    argObj = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables),\n    );\n  }\n\n  return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\n\nexport type Directives = {\n  [directiveName: string]: {\n    [argName: string]: any;\n  };\n};\n\nconst KNOWN_DIRECTIVES: string[] = [\n  'connection',\n  'include',\n  'skip',\n  'client',\n  'rest',\n  'export',\n];\n\nexport const getStoreKeyName = Object.assign(function (\n  fieldName: string,\n  args?: Record<string, any> | null,\n  directives?: Directives,\n): string {\n  if (\n    args &&\n    directives &&\n    directives['connection'] &&\n    directives['connection']['key']\n  ) {\n    if (\n      directives['connection']['filter'] &&\n      (directives['connection']['filter'] as string[]).length > 0\n    ) {\n      const filterKeys = directives['connection']['filter']\n        ? (directives['connection']['filter'] as string[])\n        : [];\n      filterKeys.sort();\n\n      const filteredArgs = {} as { [key: string]: any };\n      filterKeys.forEach(key => {\n        filteredArgs[key] = args[key];\n      });\n\n      return `${directives['connection']['key']}(${stringify(\n        filteredArgs,\n      )})`;\n    } else {\n      return directives['connection']['key'];\n    }\n  }\n\n  let completeFieldName: string = fieldName;\n\n  if (args) {\n    // We can't use `JSON.stringify` here since it's non-deterministic,\n    // and can lead to different store key names being created even though\n    // the `args` object used during creation has the same properties/values.\n    const stringifiedArgs: string = stringify(args);\n    completeFieldName += `(${stringifiedArgs})`;\n  }\n\n  if (directives) {\n    Object.keys(directives).forEach(key => {\n      if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;\n      if (directives[key] && Object.keys(directives[key]).length) {\n        completeFieldName += `@${key}(${stringify(directives[key])})`;\n      } else {\n        completeFieldName += `@${key}`;\n      }\n    });\n  }\n\n  return completeFieldName;\n}, {\n  setStringify(s: typeof stringify) {\n    const previous = stringify;\n    stringify = s;\n    return previous;\n  },\n});\n\n// Default stable JSON.stringify implementation. Can be updated/replaced with\n// something better by calling getStoreKeyName.setStringify.\nlet stringify = function defaultStringify(value: any): string {\n  return JSON.stringify(value, stringifyReplacer);\n};\n\nfunction stringifyReplacer(_key: string, value: any): any {\n  if (isNonNullObject(value) && !Array.isArray(value)) {\n    value = Object.keys(value).sort().reduce((copy, key) => {\n      copy[key] = value[key];\n      return copy;\n    }, {} as Record<string, any>);\n  }\n  return value;\n}\n\nexport function argumentsObjectFromField(\n  field: FieldNode | DirectiveNode,\n  variables?: Record<string, any>,\n): Object | null {\n  if (field.arguments && field.arguments.length) {\n    const argObj: Object = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables),\n    );\n    return argObj;\n  }\n  return null;\n}\n\nexport function resultKeyNameFromField(field: FieldNode): string {\n  return field.alias ? field.alias.value : field.name.value;\n}\n\nexport function getTypenameFromResult(\n  result: Record<string, any>,\n  selectionSet: SelectionSetNode,\n  fragmentMap?: FragmentMap,\n): string | undefined {\n  let fragments: undefined | Array<InlineFragmentNode | FragmentSpreadNode>;\n  for (const selection of selectionSet.selections) {\n    if (isField(selection)) {\n      if (selection.name.value === '__typename') {\n        return result[resultKeyNameFromField(selection)];\n      }\n    } else if (fragments) {\n      fragments.push(selection);\n    } else {\n      fragments = [selection];\n    }\n  }\n  if (typeof result.__typename === 'string') {\n    return result.__typename;\n  }\n  if (fragments) {\n    for (const selection of fragments) {\n      const typename = getTypenameFromResult(\n        result,\n        getFragmentFromSelection(selection, fragmentMap)!.selectionSet,\n        fragmentMap,\n      );\n      if (typeof typename === 'string') {\n        return typename;\n      }\n    }\n  }\n}\n\nexport function isField(selection: SelectionNode): selection is FieldNode {\n  return selection.kind === 'Field';\n}\n\nexport function isInlineFragment(\n  selection: SelectionNode,\n): selection is InlineFragmentNode {\n  return selection.kind === 'InlineFragment';\n}\n\nexport type VariableValue = (node: VariableNode) => any;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}