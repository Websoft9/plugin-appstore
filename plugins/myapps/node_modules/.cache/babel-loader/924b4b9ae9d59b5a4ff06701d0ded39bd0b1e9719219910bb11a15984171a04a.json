{"ast":null,"code":"import find from \"../polyfills/find.mjs\";\nimport objectValues from \"../polyfills/objectValues.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\nimport { locatedError } from \"../error/locatedError.mjs\";\nimport { isValidNameError } from \"../utilities/assertValidName.mjs\";\nimport { isEqualType, isTypeSubTypeOf } from \"../utilities/typeComparators.mjs\";\nimport { assertSchema } from \"./schema.mjs\";\nimport { isIntrospectionType } from \"./introspection.mjs\";\nimport { isDirective, GraphQLDeprecatedDirective } from \"./directives.mjs\";\nimport { isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNamedType, isNonNullType, isInputType, isOutputType, isRequiredArgument, isRequiredInputField } from \"./definition.mjs\";\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  assertSchema(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n  var context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  var errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  var errors = validateSchema(schema);\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\nvar SchemaValidationContext = /*#__PURE__*/function () {\n  function SchemaValidationContext(schema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n  var _proto = SchemaValidationContext.prototype;\n  _proto.reportError = function reportError(message, nodes) {\n    var _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n    this.addError(new GraphQLError(message, _nodes));\n  };\n  _proto.addError = function addError(error) {\n    this._errors.push(error);\n  };\n  _proto.getErrors = function getErrors() {\n    return this._errors;\n  };\n  return SchemaValidationContext;\n}();\nfunction validateRootTypes(context) {\n  var schema = context.schema;\n  var queryType = schema.getQueryType();\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    var _getOperationTypeNode;\n    context.reportError(\"Query root type must be Object type, it cannot be \".concat(inspect(queryType), \".\"), (_getOperationTypeNode = getOperationTypeNode(schema, 'query')) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode);\n  }\n  var mutationType = schema.getMutationType();\n  if (mutationType && !isObjectType(mutationType)) {\n    var _getOperationTypeNode2;\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(mutationType), \".\"), (_getOperationTypeNode2 = getOperationTypeNode(schema, 'mutation')) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode);\n  }\n  var subscriptionType = schema.getSubscriptionType();\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    var _getOperationTypeNode3;\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(subscriptionType), \".\"), (_getOperationTypeNode3 = getOperationTypeNode(schema, 'subscription')) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode);\n  }\n}\nfunction getOperationTypeNode(schema, operation) {\n  var operationNodes = getAllSubNodes(schema, function (node) {\n    return node.operationTypes;\n  });\n  for (var _i2 = 0; _i2 < operationNodes.length; _i2++) {\n    var node = operationNodes[_i2];\n    if (node.operation === operation) {\n      return node.type;\n    }\n  }\n  return undefined;\n}\nfunction validateDirectives(context) {\n  for (var _i4 = 0, _context$schema$getDi2 = context.schema.getDirectives(); _i4 < _context$schema$getDi2.length; _i4++) {\n    var directive = _context$schema$getDi2[_i4];\n\n    // Ensure all directives are in fact GraphQL directives.\n    if (!isDirective(directive)) {\n      context.reportError(\"Expected directive but got: \".concat(inspect(directive), \".\"), directive === null || directive === void 0 ? void 0 : directive.astNode);\n      continue;\n    } // Ensure they are named correctly.\n\n    validateName(context, directive); // TODO: Ensure proper locations.\n    // Ensure the arguments are valid.\n\n    for (var _i6 = 0, _directive$args2 = directive.args; _i6 < _directive$args2.length; _i6++) {\n      var arg = _directive$args2[_i6];\n      // Ensure they are named correctly.\n      validateName(context, arg); // Ensure the type is an input type.\n\n      if (!isInputType(arg.type)) {\n        context.reportError(\"The type of @\".concat(directive.name, \"(\").concat(arg.name, \":) must be Input Type \") + \"but got: \".concat(inspect(arg.type), \".\"), arg.astNode);\n      }\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode;\n        context.reportError(\"Required argument @\".concat(directive.name, \"(\").concat(arg.name, \":) cannot be deprecated.\"), [getDeprecatedDirectiveNode(arg.astNode),\n        // istanbul ignore next (TODO need to write coverage tests)\n        (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type]);\n      }\n    }\n  }\n}\nfunction validateName(context, node) {\n  // Ensure names are valid, however introspection types opt out.\n  var error = isValidNameError(node.name);\n  if (error) {\n    context.addError(locatedError(error, node.astNode));\n  }\n}\nfunction validateTypes(context) {\n  var validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);\n  var typeMap = context.schema.getTypeMap();\n  for (var _i8 = 0, _objectValues2 = objectValues(typeMap); _i8 < _objectValues2.length; _i8++) {\n    var type = _objectValues2[_i8];\n\n    // Ensure all provided types are in fact GraphQL type.\n    if (!isNamedType(type)) {\n      context.reportError(\"Expected GraphQL named type but got: \".concat(inspect(type), \".\"), type.astNode);\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n    if (!isIntrospectionType(type)) {\n      validateName(context, type);\n    }\n    if (isObjectType(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isInterfaceType(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type); // Ensure interfaces implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isUnionType(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if (isEnumType(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if (isInputObjectType(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\nfunction validateFields(context, type) {\n  var fields = objectValues(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(\"Type \".concat(type.name, \" must define one or more fields.\"), getAllNodes(type));\n  }\n  for (var _i10 = 0; _i10 < fields.length; _i10++) {\n    var field = fields[_i10];\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!isOutputType(field.type)) {\n      var _field$astNode;\n      context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \" must be Output Type \") + \"but got: \".concat(inspect(field.type), \".\"), (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type);\n    } // Ensure the arguments are valid\n\n    for (var _i12 = 0, _field$args2 = field.args; _i12 < _field$args2.length; _i12++) {\n      var arg = _field$args2[_i12];\n      var argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure the type is an input type\n\n      if (!isInputType(arg.type)) {\n        var _arg$astNode2;\n        context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) must be Input \") + \"Type but got: \".concat(inspect(arg.type), \".\"), (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type);\n      }\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode3;\n        context.reportError(\"Required argument \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) cannot be deprecated.\"), [getDeprecatedDirectiveNode(arg.astNode),\n        // istanbul ignore next (TODO need to write coverage tests)\n        (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type]);\n      }\n    }\n  }\n}\nfunction validateInterfaces(context, type) {\n  var ifaceTypeNames = Object.create(null);\n  for (var _i14 = 0, _type$getInterfaces2 = type.getInterfaces(); _i14 < _type$getInterfaces2.length; _i14++) {\n    var iface = _type$getInterfaces2[_i14];\n    if (!isInterfaceType(iface)) {\n      context.reportError(\"Type \".concat(inspect(type), \" must only implement Interface types, \") + \"it cannot implement \".concat(inspect(iface), \".\"), getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n    if (type === iface) {\n      context.reportError(\"Type \".concat(type.name, \" cannot implement itself because it would create a circular reference.\"), getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n    if (ifaceTypeNames[iface.name]) {\n      context.reportError(\"Type \".concat(type.name, \" can only implement \").concat(iface.name, \" once.\"), getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n    ifaceTypeNames[iface.name] = true;\n    validateTypeImplementsAncestors(context, type, iface);\n    validateTypeImplementsInterface(context, type, iface);\n  }\n}\nfunction validateTypeImplementsInterface(context, type, iface) {\n  var typeFieldMap = type.getFields(); // Assert each interface field is implemented.\n\n  for (var _i16 = 0, _objectValues4 = objectValues(iface.getFields()); _i16 < _objectValues4.length; _i16++) {\n    var ifaceField = _objectValues4[_i16];\n    var fieldName = ifaceField.name;\n    var typeField = typeFieldMap[fieldName]; // Assert interface field exists on type.\n\n    if (!typeField) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expected but \").concat(type.name, \" does not provide it.\"), [ifaceField.astNode].concat(getAllNodes(type)));\n      continue;\n    } // Assert interface field type is satisfied by type field type, by being\n    // a valid subtype. (covariant)\n\n    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {\n      var _ifaceField$astNode, _typeField$astNode;\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expects type \") + \"\".concat(inspect(ifaceField.type), \" but \").concat(type.name, \".\").concat(fieldName, \" \") + \"is type \".concat(inspect(typeField.type), \".\"), [\n      // istanbul ignore next (TODO need to write coverage tests)\n      (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,\n      // istanbul ignore next (TODO need to write coverage tests)\n      (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type]);\n    } // Assert each interface field arg is implemented.\n\n    var _loop = function _loop(_i18, _ifaceField$args2) {\n      var ifaceArg = _ifaceField$args2[_i18];\n      var argName = ifaceArg.name;\n      var typeArg = find(typeField.args, function (arg) {\n        return arg.name === argName;\n      }); // Assert interface field arg exists on object field.\n\n      if (!typeArg) {\n        context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) expected but \").concat(type.name, \".\").concat(fieldName, \" does not provide it.\"), [ifaceArg.astNode, typeField.astNode]);\n        return \"continue\";\n      } // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n\n      if (!isEqualType(ifaceArg.type, typeArg.type)) {\n        var _ifaceArg$astNode, _typeArg$astNode;\n        context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expects type \".concat(inspect(ifaceArg.type), \" but \") + \"\".concat(type.name, \".\").concat(fieldName, \"(\").concat(argName, \":) is type \") + \"\".concat(inspect(typeArg.type), \".\"), [\n        // istanbul ignore next (TODO need to write coverage tests)\n        (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,\n        // istanbul ignore next (TODO need to write coverage tests)\n        (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type]);\n      } // TODO: validate default values?\n    };\n\n    for (var _i18 = 0, _ifaceField$args2 = ifaceField.args; _i18 < _ifaceField$args2.length; _i18++) {\n      var _ret = _loop(_i18, _ifaceField$args2);\n      if (_ret === \"continue\") continue;\n    } // Assert additional arguments must not be required.\n\n    var _loop2 = function _loop2(_i20, _typeField$args2) {\n      var typeArg = _typeField$args2[_i20];\n      var argName = typeArg.name;\n      var ifaceArg = find(ifaceField.args, function (arg) {\n        return arg.name === argName;\n      });\n      if (!ifaceArg && isRequiredArgument(typeArg)) {\n        context.reportError(\"Object field \".concat(type.name, \".\").concat(fieldName, \" includes required argument \").concat(argName, \" that is missing from the Interface field \").concat(iface.name, \".\").concat(fieldName, \".\"), [typeArg.astNode, ifaceField.astNode]);\n      }\n    };\n    for (var _i20 = 0, _typeField$args2 = typeField.args; _i20 < _typeField$args2.length; _i20++) {\n      _loop2(_i20, _typeField$args2);\n    }\n  }\n}\nfunction validateTypeImplementsAncestors(context, type, iface) {\n  var ifaceInterfaces = type.getInterfaces();\n  for (var _i22 = 0, _iface$getInterfaces2 = iface.getInterfaces(); _i22 < _iface$getInterfaces2.length; _i22++) {\n    var transitive = _iface$getInterfaces2[_i22];\n    if (ifaceInterfaces.indexOf(transitive) === -1) {\n      context.reportError(transitive === type ? \"Type \".concat(type.name, \" cannot implement \").concat(iface.name, \" because it would create a circular reference.\") : \"Type \".concat(type.name, \" must implement \").concat(transitive.name, \" because it is implemented by \").concat(iface.name, \".\"), [].concat(getAllImplementsInterfaceNodes(iface, transitive), getAllImplementsInterfaceNodes(type, iface)));\n    }\n  }\n}\nfunction validateUnionMembers(context, union) {\n  var memberTypes = union.getTypes();\n  if (memberTypes.length === 0) {\n    context.reportError(\"Union type \".concat(union.name, \" must define one or more member types.\"), getAllNodes(union));\n  }\n  var includedTypeNames = Object.create(null);\n  for (var _i24 = 0; _i24 < memberTypes.length; _i24++) {\n    var memberType = memberTypes[_i24];\n    if (includedTypeNames[memberType.name]) {\n      context.reportError(\"Union type \".concat(union.name, \" can only include type \").concat(memberType.name, \" once.\"), getUnionMemberTypeNodes(union, memberType.name));\n      continue;\n    }\n    includedTypeNames[memberType.name] = true;\n    if (!isObjectType(memberType)) {\n      context.reportError(\"Union type \".concat(union.name, \" can only include Object types, \") + \"it cannot include \".concat(inspect(memberType), \".\"), getUnionMemberTypeNodes(union, String(memberType)));\n    }\n  }\n}\nfunction validateEnumValues(context, enumType) {\n  var enumValues = enumType.getValues();\n  if (enumValues.length === 0) {\n    context.reportError(\"Enum type \".concat(enumType.name, \" must define one or more values.\"), getAllNodes(enumType));\n  }\n  for (var _i26 = 0; _i26 < enumValues.length; _i26++) {\n    var enumValue = enumValues[_i26];\n    var valueName = enumValue.name; // Ensure valid name.\n\n    validateName(context, enumValue);\n    if (valueName === 'true' || valueName === 'false' || valueName === 'null') {\n      context.reportError(\"Enum type \".concat(enumType.name, \" cannot include value: \").concat(valueName, \".\"), enumValue.astNode);\n    }\n  }\n}\nfunction validateInputFields(context, inputObj) {\n  var fields = objectValues(inputObj.getFields());\n  if (fields.length === 0) {\n    context.reportError(\"Input Object type \".concat(inputObj.name, \" must define one or more fields.\"), getAllNodes(inputObj));\n  } // Ensure the arguments are valid\n\n  for (var _i28 = 0; _i28 < fields.length; _i28++) {\n    var field = fields[_i28];\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!isInputType(field.type)) {\n      var _field$astNode2;\n      context.reportError(\"The type of \".concat(inputObj.name, \".\").concat(field.name, \" must be Input Type \") + \"but got: \".concat(inspect(field.type), \".\"), (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type);\n    }\n    if (isRequiredInputField(field) && field.deprecationReason != null) {\n      var _field$astNode3;\n      context.reportError(\"Required input field \".concat(inputObj.name, \".\").concat(field.name, \" cannot be deprecated.\"), [getDeprecatedDirectiveNode(field.astNode),\n      // istanbul ignore next (TODO need to write coverage tests)\n      (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type]);\n    }\n  }\n}\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  var fieldPath = []; // Position in the type path\n\n  var fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    var fields = objectValues(inputObj.getFields());\n    for (var _i30 = 0; _i30 < fields.length; _i30++) {\n      var field = fields[_i30];\n      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {\n        var fieldType = field.type.ofType;\n        var cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          var cyclePath = fieldPath.slice(cycleIndex);\n          var pathStr = cyclePath.map(function (fieldObj) {\n            return fieldObj.name;\n          }).join('.');\n          context.reportError(\"Cannot reference Input Object \\\"\".concat(fieldType.name, \"\\\" within itself through a series of non-null fields: \\\"\").concat(pathStr, \"\\\".\"), cyclePath.map(function (fieldObj) {\n            return fieldObj.astNode;\n          }));\n        }\n        fieldPath.pop();\n      }\n    }\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\nfunction getAllNodes(object) {\n  var astNode = object.astNode,\n    extensionASTNodes = object.extensionASTNodes;\n  return astNode ? extensionASTNodes ? [astNode].concat(extensionASTNodes) : [astNode] : extensionASTNodes !== null && extensionASTNodes !== void 0 ? extensionASTNodes : [];\n}\nfunction getAllSubNodes(object, getter) {\n  var subNodes = [];\n  for (var _i32 = 0, _getAllNodes2 = getAllNodes(object); _i32 < _getAllNodes2.length; _i32++) {\n    var _getter;\n    var node = _getAllNodes2[_i32];\n    // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n    subNodes = subNodes.concat((_getter = getter(node)) !== null && _getter !== void 0 ? _getter : []);\n  }\n  return subNodes;\n}\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  return getAllSubNodes(type, function (typeNode) {\n    return typeNode.interfaces;\n  }).filter(function (ifaceNode) {\n    return ifaceNode.name.value === iface.name;\n  });\n}\nfunction getUnionMemberTypeNodes(union, typeName) {\n  return getAllSubNodes(union, function (unionNode) {\n    return unionNode.types;\n  }).filter(function (typeNode) {\n    return typeNode.name.value === typeName;\n  });\n}\nfunction getDeprecatedDirectiveNode(definitionNode) {\n  var _definitionNode$direc;\n\n  // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n  return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(function (node) {\n    return node.name.value === GraphQLDeprecatedDirective.name;\n  });\n}","map":{"version":3,"names":["find","objectValues","inspect","GraphQLError","locatedError","isValidNameError","isEqualType","isTypeSubTypeOf","assertSchema","isIntrospectionType","isDirective","GraphQLDeprecatedDirective","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","isNamedType","isNonNullType","isInputType","isOutputType","isRequiredArgument","isRequiredInputField","validateSchema","schema","__validationErrors","context","SchemaValidationContext","validateRootTypes","validateDirectives","validateTypes","errors","getErrors","assertValidSchema","length","Error","map","error","message","join","_errors","_proto","prototype","reportError","nodes","_nodes","Array","isArray","filter","Boolean","addError","push","queryType","getQueryType","astNode","_getOperationTypeNode","concat","getOperationTypeNode","mutationType","getMutationType","_getOperationTypeNode2","subscriptionType","getSubscriptionType","_getOperationTypeNode3","operation","operationNodes","getAllSubNodes","node","operationTypes","_i2","type","undefined","_i4","_context$schema$getDi2","getDirectives","directive","validateName","_i6","_directive$args2","args","arg","name","deprecationReason","_arg$astNode","getDeprecatedDirectiveNode","validateInputObjectCircularRefs","createInputObjectCircularRefsValidator","typeMap","getTypeMap","_i8","_objectValues2","validateFields","validateInterfaces","validateUnionMembers","validateEnumValues","validateInputFields","fields","getFields","getAllNodes","_i10","field","_field$astNode","_i12","_field$args2","argName","_arg$astNode2","_arg$astNode3","ifaceTypeNames","Object","create","_i14","_type$getInterfaces2","getInterfaces","iface","getAllImplementsInterfaceNodes","validateTypeImplementsAncestors","validateTypeImplementsInterface","typeFieldMap","_i16","_objectValues4","ifaceField","fieldName","typeField","_ifaceField$astNode","_typeField$astNode","_loop","_i18","_ifaceField$args2","ifaceArg","typeArg","_ifaceArg$astNode","_typeArg$astNode","_ret","_loop2","_i20","_typeField$args2","ifaceInterfaces","_i22","_iface$getInterfaces2","transitive","indexOf","union","memberTypes","getTypes","includedTypeNames","_i24","memberType","getUnionMemberTypeNodes","String","enumType","enumValues","getValues","_i26","enumValue","valueName","inputObj","_i28","_field$astNode2","_field$astNode3","visitedTypes","fieldPath","fieldPathIndexByTypeName","detectCycleRecursive","_i30","ofType","fieldType","cycleIndex","cyclePath","slice","pathStr","fieldObj","pop","object","extensionASTNodes","getter","subNodes","_i32","_getAllNodes2","_getter","typeNode","interfaces","ifaceNode","value","typeName","unionNode","types","definitionNode","_definitionNode$direc","directives"],"sources":["/data/stackhub-web/plugins/myapps/node_modules/graphql/type/validate.mjs"],"sourcesContent":["import find from \"../polyfills/find.mjs\";\nimport objectValues from \"../polyfills/objectValues.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\nimport { locatedError } from \"../error/locatedError.mjs\";\nimport { isValidNameError } from \"../utilities/assertValidName.mjs\";\nimport { isEqualType, isTypeSubTypeOf } from \"../utilities/typeComparators.mjs\";\nimport { assertSchema } from \"./schema.mjs\";\nimport { isIntrospectionType } from \"./introspection.mjs\";\nimport { isDirective, GraphQLDeprecatedDirective } from \"./directives.mjs\";\nimport { isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNamedType, isNonNullType, isInputType, isOutputType, isRequiredArgument, isRequiredInputField } from \"./definition.mjs\";\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  assertSchema(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n\n  var context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  var errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  var errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n\nvar SchemaValidationContext = /*#__PURE__*/function () {\n  function SchemaValidationContext(schema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  var _proto = SchemaValidationContext.prototype;\n\n  _proto.reportError = function reportError(message, nodes) {\n    var _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n\n    this.addError(new GraphQLError(message, _nodes));\n  };\n\n  _proto.addError = function addError(error) {\n    this._errors.push(error);\n  };\n\n  _proto.getErrors = function getErrors() {\n    return this._errors;\n  };\n\n  return SchemaValidationContext;\n}();\n\nfunction validateRootTypes(context) {\n  var schema = context.schema;\n  var queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    var _getOperationTypeNode;\n\n    context.reportError(\"Query root type must be Object type, it cannot be \".concat(inspect(queryType), \".\"), (_getOperationTypeNode = getOperationTypeNode(schema, 'query')) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode);\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType && !isObjectType(mutationType)) {\n    var _getOperationTypeNode2;\n\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(mutationType), \".\"), (_getOperationTypeNode2 = getOperationTypeNode(schema, 'mutation')) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode);\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    var _getOperationTypeNode3;\n\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(subscriptionType), \".\"), (_getOperationTypeNode3 = getOperationTypeNode(schema, 'subscription')) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode);\n  }\n}\n\nfunction getOperationTypeNode(schema, operation) {\n  var operationNodes = getAllSubNodes(schema, function (node) {\n    return node.operationTypes;\n  });\n\n  for (var _i2 = 0; _i2 < operationNodes.length; _i2++) {\n    var node = operationNodes[_i2];\n\n    if (node.operation === operation) {\n      return node.type;\n    }\n  }\n\n  return undefined;\n}\n\nfunction validateDirectives(context) {\n  for (var _i4 = 0, _context$schema$getDi2 = context.schema.getDirectives(); _i4 < _context$schema$getDi2.length; _i4++) {\n    var directive = _context$schema$getDi2[_i4];\n\n    // Ensure all directives are in fact GraphQL directives.\n    if (!isDirective(directive)) {\n      context.reportError(\"Expected directive but got: \".concat(inspect(directive), \".\"), directive === null || directive === void 0 ? void 0 : directive.astNode);\n      continue;\n    } // Ensure they are named correctly.\n\n\n    validateName(context, directive); // TODO: Ensure proper locations.\n    // Ensure the arguments are valid.\n\n    for (var _i6 = 0, _directive$args2 = directive.args; _i6 < _directive$args2.length; _i6++) {\n      var arg = _directive$args2[_i6];\n      // Ensure they are named correctly.\n      validateName(context, arg); // Ensure the type is an input type.\n\n      if (!isInputType(arg.type)) {\n        context.reportError(\"The type of @\".concat(directive.name, \"(\").concat(arg.name, \":) must be Input Type \") + \"but got: \".concat(inspect(arg.type), \".\"), arg.astNode);\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode;\n\n        context.reportError(\"Required argument @\".concat(directive.name, \"(\").concat(arg.name, \":) cannot be deprecated.\"), [getDeprecatedDirectiveNode(arg.astNode), // istanbul ignore next (TODO need to write coverage tests)\n        (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type]);\n      }\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // Ensure names are valid, however introspection types opt out.\n  var error = isValidNameError(node.name);\n\n  if (error) {\n    context.addError(locatedError(error, node.astNode));\n  }\n}\n\nfunction validateTypes(context) {\n  var validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);\n  var typeMap = context.schema.getTypeMap();\n\n  for (var _i8 = 0, _objectValues2 = objectValues(typeMap); _i8 < _objectValues2.length; _i8++) {\n    var type = _objectValues2[_i8];\n\n    // Ensure all provided types are in fact GraphQL type.\n    if (!isNamedType(type)) {\n      context.reportError(\"Expected GraphQL named type but got: \".concat(inspect(type), \".\"), type.astNode);\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n\n    if (!isIntrospectionType(type)) {\n      validateName(context, type);\n    }\n\n    if (isObjectType(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isInterfaceType(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type); // Ensure interfaces implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isUnionType(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if (isEnumType(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if (isInputObjectType(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  var fields = objectValues(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(\"Type \".concat(type.name, \" must define one or more fields.\"), getAllNodes(type));\n  }\n\n  for (var _i10 = 0; _i10 < fields.length; _i10++) {\n    var field = fields[_i10];\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!isOutputType(field.type)) {\n      var _field$astNode;\n\n      context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \" must be Output Type \") + \"but got: \".concat(inspect(field.type), \".\"), (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type);\n    } // Ensure the arguments are valid\n\n\n    for (var _i12 = 0, _field$args2 = field.args; _i12 < _field$args2.length; _i12++) {\n      var arg = _field$args2[_i12];\n      var argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure the type is an input type\n\n      if (!isInputType(arg.type)) {\n        var _arg$astNode2;\n\n        context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) must be Input \") + \"Type but got: \".concat(inspect(arg.type), \".\"), (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type);\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode3;\n\n        context.reportError(\"Required argument \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) cannot be deprecated.\"), [getDeprecatedDirectiveNode(arg.astNode), // istanbul ignore next (TODO need to write coverage tests)\n        (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type]);\n      }\n    }\n  }\n}\n\nfunction validateInterfaces(context, type) {\n  var ifaceTypeNames = Object.create(null);\n\n  for (var _i14 = 0, _type$getInterfaces2 = type.getInterfaces(); _i14 < _type$getInterfaces2.length; _i14++) {\n    var iface = _type$getInterfaces2[_i14];\n\n    if (!isInterfaceType(iface)) {\n      context.reportError(\"Type \".concat(inspect(type), \" must only implement Interface types, \") + \"it cannot implement \".concat(inspect(iface), \".\"), getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    if (type === iface) {\n      context.reportError(\"Type \".concat(type.name, \" cannot implement itself because it would create a circular reference.\"), getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    if (ifaceTypeNames[iface.name]) {\n      context.reportError(\"Type \".concat(type.name, \" can only implement \").concat(iface.name, \" once.\"), getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    ifaceTypeNames[iface.name] = true;\n    validateTypeImplementsAncestors(context, type, iface);\n    validateTypeImplementsInterface(context, type, iface);\n  }\n}\n\nfunction validateTypeImplementsInterface(context, type, iface) {\n  var typeFieldMap = type.getFields(); // Assert each interface field is implemented.\n\n  for (var _i16 = 0, _objectValues4 = objectValues(iface.getFields()); _i16 < _objectValues4.length; _i16++) {\n    var ifaceField = _objectValues4[_i16];\n    var fieldName = ifaceField.name;\n    var typeField = typeFieldMap[fieldName]; // Assert interface field exists on type.\n\n    if (!typeField) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expected but \").concat(type.name, \" does not provide it.\"), [ifaceField.astNode].concat(getAllNodes(type)));\n      continue;\n    } // Assert interface field type is satisfied by type field type, by being\n    // a valid subtype. (covariant)\n\n\n    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {\n      var _ifaceField$astNode, _typeField$astNode;\n\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expects type \") + \"\".concat(inspect(ifaceField.type), \" but \").concat(type.name, \".\").concat(fieldName, \" \") + \"is type \".concat(inspect(typeField.type), \".\"), [// istanbul ignore next (TODO need to write coverage tests)\n      (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type, // istanbul ignore next (TODO need to write coverage tests)\n      (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type]);\n    } // Assert each interface field arg is implemented.\n\n\n    var _loop = function _loop(_i18, _ifaceField$args2) {\n      var ifaceArg = _ifaceField$args2[_i18];\n      var argName = ifaceArg.name;\n      var typeArg = find(typeField.args, function (arg) {\n        return arg.name === argName;\n      }); // Assert interface field arg exists on object field.\n\n      if (!typeArg) {\n        context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) expected but \").concat(type.name, \".\").concat(fieldName, \" does not provide it.\"), [ifaceArg.astNode, typeField.astNode]);\n        return \"continue\";\n      } // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n\n\n      if (!isEqualType(ifaceArg.type, typeArg.type)) {\n        var _ifaceArg$astNode, _typeArg$astNode;\n\n        context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expects type \".concat(inspect(ifaceArg.type), \" but \") + \"\".concat(type.name, \".\").concat(fieldName, \"(\").concat(argName, \":) is type \") + \"\".concat(inspect(typeArg.type), \".\"), [// istanbul ignore next (TODO need to write coverage tests)\n        (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type, // istanbul ignore next (TODO need to write coverage tests)\n        (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type]);\n      } // TODO: validate default values?\n\n    };\n\n    for (var _i18 = 0, _ifaceField$args2 = ifaceField.args; _i18 < _ifaceField$args2.length; _i18++) {\n      var _ret = _loop(_i18, _ifaceField$args2);\n\n      if (_ret === \"continue\") continue;\n    } // Assert additional arguments must not be required.\n\n\n    var _loop2 = function _loop2(_i20, _typeField$args2) {\n      var typeArg = _typeField$args2[_i20];\n      var argName = typeArg.name;\n      var ifaceArg = find(ifaceField.args, function (arg) {\n        return arg.name === argName;\n      });\n\n      if (!ifaceArg && isRequiredArgument(typeArg)) {\n        context.reportError(\"Object field \".concat(type.name, \".\").concat(fieldName, \" includes required argument \").concat(argName, \" that is missing from the Interface field \").concat(iface.name, \".\").concat(fieldName, \".\"), [typeArg.astNode, ifaceField.astNode]);\n      }\n    };\n\n    for (var _i20 = 0, _typeField$args2 = typeField.args; _i20 < _typeField$args2.length; _i20++) {\n      _loop2(_i20, _typeField$args2);\n    }\n  }\n}\n\nfunction validateTypeImplementsAncestors(context, type, iface) {\n  var ifaceInterfaces = type.getInterfaces();\n\n  for (var _i22 = 0, _iface$getInterfaces2 = iface.getInterfaces(); _i22 < _iface$getInterfaces2.length; _i22++) {\n    var transitive = _iface$getInterfaces2[_i22];\n\n    if (ifaceInterfaces.indexOf(transitive) === -1) {\n      context.reportError(transitive === type ? \"Type \".concat(type.name, \" cannot implement \").concat(iface.name, \" because it would create a circular reference.\") : \"Type \".concat(type.name, \" must implement \").concat(transitive.name, \" because it is implemented by \").concat(iface.name, \".\"), [].concat(getAllImplementsInterfaceNodes(iface, transitive), getAllImplementsInterfaceNodes(type, iface)));\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  var memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(\"Union type \".concat(union.name, \" must define one or more member types.\"), getAllNodes(union));\n  }\n\n  var includedTypeNames = Object.create(null);\n\n  for (var _i24 = 0; _i24 < memberTypes.length; _i24++) {\n    var memberType = memberTypes[_i24];\n\n    if (includedTypeNames[memberType.name]) {\n      context.reportError(\"Union type \".concat(union.name, \" can only include type \").concat(memberType.name, \" once.\"), getUnionMemberTypeNodes(union, memberType.name));\n      continue;\n    }\n\n    includedTypeNames[memberType.name] = true;\n\n    if (!isObjectType(memberType)) {\n      context.reportError(\"Union type \".concat(union.name, \" can only include Object types, \") + \"it cannot include \".concat(inspect(memberType), \".\"), getUnionMemberTypeNodes(union, String(memberType)));\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  var enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(\"Enum type \".concat(enumType.name, \" must define one or more values.\"), getAllNodes(enumType));\n  }\n\n  for (var _i26 = 0; _i26 < enumValues.length; _i26++) {\n    var enumValue = enumValues[_i26];\n    var valueName = enumValue.name; // Ensure valid name.\n\n    validateName(context, enumValue);\n\n    if (valueName === 'true' || valueName === 'false' || valueName === 'null') {\n      context.reportError(\"Enum type \".concat(enumType.name, \" cannot include value: \").concat(valueName, \".\"), enumValue.astNode);\n    }\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  var fields = objectValues(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(\"Input Object type \".concat(inputObj.name, \" must define one or more fields.\"), getAllNodes(inputObj));\n  } // Ensure the arguments are valid\n\n\n  for (var _i28 = 0; _i28 < fields.length; _i28++) {\n    var field = fields[_i28];\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!isInputType(field.type)) {\n      var _field$astNode2;\n\n      context.reportError(\"The type of \".concat(inputObj.name, \".\").concat(field.name, \" must be Input Type \") + \"but got: \".concat(inspect(field.type), \".\"), (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type);\n    }\n\n    if (isRequiredInputField(field) && field.deprecationReason != null) {\n      var _field$astNode3;\n\n      context.reportError(\"Required input field \".concat(inputObj.name, \".\").concat(field.name, \" cannot be deprecated.\"), [getDeprecatedDirectiveNode(field.astNode), // istanbul ignore next (TODO need to write coverage tests)\n      (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type]);\n    }\n  }\n}\n\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  var fieldPath = []; // Position in the type path\n\n  var fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    var fields = objectValues(inputObj.getFields());\n\n    for (var _i30 = 0; _i30 < fields.length; _i30++) {\n      var field = fields[_i30];\n\n      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {\n        var fieldType = field.type.ofType;\n        var cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          var cyclePath = fieldPath.slice(cycleIndex);\n          var pathStr = cyclePath.map(function (fieldObj) {\n            return fieldObj.name;\n          }).join('.');\n          context.reportError(\"Cannot reference Input Object \\\"\".concat(fieldType.name, \"\\\" within itself through a series of non-null fields: \\\"\").concat(pathStr, \"\\\".\"), cyclePath.map(function (fieldObj) {\n            return fieldObj.astNode;\n          }));\n        }\n\n        fieldPath.pop();\n      }\n    }\n\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\n\nfunction getAllNodes(object) {\n  var astNode = object.astNode,\n      extensionASTNodes = object.extensionASTNodes;\n  return astNode ? extensionASTNodes ? [astNode].concat(extensionASTNodes) : [astNode] : extensionASTNodes !== null && extensionASTNodes !== void 0 ? extensionASTNodes : [];\n}\n\nfunction getAllSubNodes(object, getter) {\n  var subNodes = [];\n\n  for (var _i32 = 0, _getAllNodes2 = getAllNodes(object); _i32 < _getAllNodes2.length; _i32++) {\n    var _getter;\n\n    var node = _getAllNodes2[_i32];\n    // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n    subNodes = subNodes.concat((_getter = getter(node)) !== null && _getter !== void 0 ? _getter : []);\n  }\n\n  return subNodes;\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  return getAllSubNodes(type, function (typeNode) {\n    return typeNode.interfaces;\n  }).filter(function (ifaceNode) {\n    return ifaceNode.name.value === iface.name;\n  });\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  return getAllSubNodes(union, function (unionNode) {\n    return unionNode.types;\n  }).filter(function (typeNode) {\n    return typeNode.name.value === typeName;\n  });\n}\n\nfunction getDeprecatedDirectiveNode(definitionNode) {\n  var _definitionNode$direc;\n\n  // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n  return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(function (node) {\n    return node.name.value === GraphQLDeprecatedDirective.name;\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}