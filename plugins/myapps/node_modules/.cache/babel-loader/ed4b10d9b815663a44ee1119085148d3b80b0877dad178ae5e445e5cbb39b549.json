{"ast":null,"code":"import { Slot } from \"./slot.js\";\nexport { Slot };\nvar bind = Slot.bind,\n  noContext = Slot.noContext;\n// Like global.setTimeout, except the callback runs with captured context.\nexport { bind, noContext };\nexport { setTimeoutWithContext as setTimeout };\nfunction setTimeoutWithContext(callback, delay) {\n  return setTimeout(bind(callback), delay);\n}\n// Turn any generator function into an async function (using yield instead\n// of await), with context automatically preserved across yields.\nexport function asyncFromGen(genFn) {\n  return function () {\n    var gen = genFn.apply(this, arguments);\n    var boundNext = bind(gen.next);\n    var boundThrow = bind(gen.throw);\n    return new Promise(function (resolve, reject) {\n      function invoke(method, argument) {\n        try {\n          var result = method.call(gen, argument);\n        } catch (error) {\n          return reject(error);\n        }\n        var next = result.done ? resolve : invokeNext;\n        if (isPromiseLike(result.value)) {\n          result.value.then(next, result.done ? reject : invokeThrow);\n        } else {\n          next(result.value);\n        }\n      }\n      var invokeNext = function invokeNext(value) {\n        return invoke(boundNext, value);\n      };\n      var invokeThrow = function invokeThrow(error) {\n        return invoke(boundThrow, error);\n      };\n      invokeNext();\n    });\n  };\n}\nfunction isPromiseLike(value) {\n  return value && typeof value.then === \"function\";\n}\n// If you use the fibers npm package to implement coroutines in Node.js,\n// you should call this function at least once to ensure context management\n// remains coherent across any yields.\nvar wrappedFibers = [];\nexport function wrapYieldingFiberMethods(Fiber) {\n  // There can be only one implementation of Fiber per process, so this array\n  // should never grow longer than one element.\n  if (wrappedFibers.indexOf(Fiber) < 0) {\n    var wrap = function wrap(obj, method) {\n      var fn = obj[method];\n      obj[method] = function () {\n        return noContext(fn, arguments, this);\n      };\n    };\n    // These methods can yield, according to\n    // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\n    wrap(Fiber, \"yield\");\n    wrap(Fiber.prototype, \"run\");\n    wrap(Fiber.prototype, \"throwInto\");\n    wrappedFibers.push(Fiber);\n  }\n  return Fiber;\n}","map":{"version":3,"names":["Slot","bind","noContext","setTimeoutWithContext","setTimeout","callback","delay","asyncFromGen","genFn","gen","apply","arguments","boundNext","next","boundThrow","throw","Promise","resolve","reject","invoke","method","argument","result","call","error","done","invokeNext","isPromiseLike","value","then","invokeThrow","wrappedFibers","wrapYieldingFiberMethods","Fiber","indexOf","wrap","obj","fn","prototype","push"],"sources":["/data/stackhub-web/plugins/myapps/node_modules/@wry/context/src/index.ts"],"sourcesContent":["import { Slot } from \"./slot.js\";\nexport { Slot }\nexport const { bind, noContext } = Slot;\n\n// Relying on the @types/node declaration of global.setTimeout can make\n// things tricky for dowstream projects (see PR #7).\ndeclare function setTimeout(\n  callback: (...args: any[]) => any,\n  ms?: number,\n  ...args: any[]\n): any;\n\n// Like global.setTimeout, except the callback runs with captured context.\nexport { setTimeoutWithContext as setTimeout };\nfunction setTimeoutWithContext(callback: () => any, delay: number) {\n  return setTimeout(bind(callback), delay);\n}\n\n// Turn any generator function into an async function (using yield instead\n// of await), with context automatically preserved across yields.\nexport function asyncFromGen<\n  TArgs extends any[],\n  TYield = any,\n  TReturn = any,\n  TNext = any,\n>(\n  genFn: (...args: TArgs) => Generator<TYield, TReturn, TNext>\n) {\n  return function (this: any) {\n    const gen = genFn.apply(this, arguments as any);\n\n    type Method = (\n      this: Generator<TYield, TReturn, TNext>,\n      arg: any,\n    ) => IteratorResult<TYield, TReturn>;\n\n    const boundNext: Method = bind(gen.next);\n    const boundThrow: Method = bind(gen.throw!);\n\n    return new Promise((resolve, reject) => {\n      function invoke(method: Method, argument: any) {\n        try {\n          var result: any = method.call(gen, argument);\n        } catch (error) {\n          return reject(error);\n        }\n        const next = result.done ? resolve : invokeNext;\n        if (isPromiseLike(result.value)) {\n          result.value.then(next, result.done ? reject : invokeThrow);\n        } else {\n          next(result.value);\n        }\n      }\n      const invokeNext = (value?: any) => invoke(boundNext, value);\n      const invokeThrow = (error: any) => invoke(boundThrow, error);\n      invokeNext();\n    });\n  } as (...args: TArgs) => Promise<any>;\n}\n\nfunction isPromiseLike(value: any): value is PromiseLike<any> {\n  return value && typeof value.then === \"function\";\n}\n\n// If you use the fibers npm package to implement coroutines in Node.js,\n// you should call this function at least once to ensure context management\n// remains coherent across any yields.\nconst wrappedFibers: Function[] = [];\nexport function wrapYieldingFiberMethods<F extends Function>(Fiber: F): F {\n  // There can be only one implementation of Fiber per process, so this array\n  // should never grow longer than one element.\n  if (wrappedFibers.indexOf(Fiber) < 0) {\n    const wrap = (obj: any, method: string) => {\n      const fn = obj[method];\n      obj[method] = function () {\n        return noContext(fn, arguments as any, this);\n      };\n    }\n    // These methods can yield, according to\n    // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\n    wrap(Fiber, \"yield\");\n    wrap(Fiber.prototype, \"run\");\n    wrap(Fiber.prototype, \"throwInto\");\n    wrappedFibers.push(Fiber);\n  }\n  return Fiber;\n}\n"],"mappings":"AAAA,SAASA,IAAI,QAAQ,WAAW;AAChC,SAASA,IAAI;AACN,IAAQC,IAAI,GAAgBD,IAAI,CAAxBC,IAAI;EAAEC,SAAS,GAAKF,IAAI,CAAlBE,SAAS;AAU9B;AAAA,SAAAD,IAAA,EAAAC,SAAA;AACA,SAASC,qBAAqB,IAAIC,UAAU;AAC5C,SAASD,qBAAqBA,CAACE,QAAmB,EAAEC,KAAa;EAC/D,OAAOF,UAAU,CAACH,IAAI,CAACI,QAAQ,CAAC,EAAEC,KAAK,CAAC;AAC1C;AAEA;AACA;AACA,OAAM,SAAUC,YAAYA,CAM1BC,KAA4D;EAE5D,OAAO;IACL,IAAMC,GAAG,GAAGD,KAAK,CAACE,KAAK,CAAC,IAAI,EAAEC,SAAgB,CAAC;IAO/C,IAAMC,SAAS,GAAWX,IAAI,CAACQ,GAAG,CAACI,IAAI,CAAC;IACxC,IAAMC,UAAU,GAAWb,IAAI,CAACQ,GAAG,CAACM,KAAM,CAAC;IAE3C,OAAO,IAAIC,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM,EAAI;MACrC,SAASC,MAAMA,CAACC,MAAc,EAAEC,QAAa;QAC3C,IAAI;UACF,IAAIC,MAAM,GAAQF,MAAM,CAACG,IAAI,CAACd,GAAG,EAAEY,QAAQ,CAAC;SAC7C,CAAC,OAAOG,KAAK,EAAE;UACd,OAAON,MAAM,CAACM,KAAK,CAAC;;QAEtB,IAAMX,IAAI,GAAGS,MAAM,CAACG,IAAI,GAAGR,OAAO,GAAGS,UAAU;QAC/C,IAAIC,aAAa,CAACL,MAAM,CAACM,KAAK,CAAC,EAAE;UAC/BN,MAAM,CAACM,KAAK,CAACC,IAAI,CAAChB,IAAI,EAAES,MAAM,CAACG,IAAI,GAAGP,MAAM,GAAGY,WAAW,CAAC;SAC5D,MAAM;UACLjB,IAAI,CAACS,MAAM,CAACM,KAAK,CAAC;;MAEtB;MACA,IAAMF,UAAU,GAAG,SAAbA,UAAUA,CAAIE,KAAW;QAAA,OAAKT,MAAM,CAACP,SAAS,EAAEgB,KAAK,CAAC;MAAA;MAC5D,IAAME,WAAW,GAAG,SAAdA,WAAWA,CAAIN,KAAU;QAAA,OAAKL,MAAM,CAACL,UAAU,EAAEU,KAAK,CAAC;MAAA;MAC7DE,UAAU,EAAE;IACd,CAAC,CAAC;EACJ,CAAqC;AACvC;AAEA,SAASC,aAAaA,CAACC,KAAU;EAC/B,OAAOA,KAAK,IAAI,OAAOA,KAAK,CAACC,IAAI,KAAK,UAAU;AAClD;AAEA;AACA;AACA;AACA,IAAME,aAAa,GAAe,EAAE;AACpC,OAAM,SAAUC,wBAAwBA,CAAqBC,KAAQ;EACnE;EACA;EACA,IAAIF,aAAa,CAACG,OAAO,CAACD,KAAK,CAAC,GAAG,CAAC,EAAE;IACpC,IAAME,IAAI,GAAG,SAAPA,IAAIA,CAAIC,GAAQ,EAAEhB,MAAc,EAAI;MACxC,IAAMiB,EAAE,GAAGD,GAAG,CAAChB,MAAM,CAAC;MACtBgB,GAAG,CAAChB,MAAM,CAAC,GAAG;QACZ,OAAOlB,SAAS,CAACmC,EAAE,EAAE1B,SAAgB,EAAE,IAAI,CAAC;MAC9C,CAAC;IACH,CAAC;IACD;IACA;IACAwB,IAAI,CAACF,KAAK,EAAE,OAAO,CAAC;IACpBE,IAAI,CAACF,KAAK,CAACK,SAAS,EAAE,KAAK,CAAC;IAC5BH,IAAI,CAACF,KAAK,CAACK,SAAS,EAAE,WAAW,CAAC;IAClCP,aAAa,CAACQ,IAAI,CAACN,KAAK,CAAC;;EAE3B,OAAOA,KAAK;AACd"},"metadata":{},"sourceType":"module","externalDependencies":[]}