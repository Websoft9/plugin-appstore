{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { invariant, InvariantError } from \"../../utilities/globals/index.js\";\nimport { storeKeyNameFromField, argumentsObjectFromField, isReference, getStoreKeyName, isNonNullObject, stringifyForDisplay } from \"../../utilities/index.js\";\nimport { hasOwn, fieldNameFromStoreName, storeValueIsStoreObject, selectionSetMatchesResult, TypeOrFieldNameRegExp, defaultDataIdFromObject, isArray } from \"./helpers.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\nimport { canonicalStringify } from \"./object-canon.js\";\nimport { keyArgsFnFromSpecifier, keyFieldsFnFromSpecifier } from \"./key-extractor.js\";\ngetStoreKeyName.setStringify(canonicalStringify);\nfunction argsFromFieldSpecifier(spec) {\n  return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;\n}\nvar nullKeyFieldsFn = function nullKeyFieldsFn() {\n  return void 0;\n};\nvar simpleKeyArgsFn = function simpleKeyArgsFn(_args, context) {\n  return context.fieldName;\n};\nvar mergeTrueFn = function mergeTrueFn(existing, incoming, _a) {\n  var mergeObjects = _a.mergeObjects;\n  return mergeObjects(existing, incoming);\n};\nvar mergeFalseFn = function mergeFalseFn(_, incoming) {\n  return incoming;\n};\nvar Policies = function () {\n  function Policies(config) {\n    this.config = config;\n    this.typePolicies = Object.create(null);\n    this.toBeAdded = Object.create(null);\n    this.supertypeMap = new Map();\n    this.fuzzySubtypes = new Map();\n    this.rootIdsByTypename = Object.create(null);\n    this.rootTypenamesById = Object.create(null);\n    this.usingPossibleTypes = false;\n    this.config = __assign({\n      dataIdFromObject: defaultDataIdFromObject\n    }, config);\n    this.cache = this.config.cache;\n    this.setRootTypename(\"Query\");\n    this.setRootTypename(\"Mutation\");\n    this.setRootTypename(\"Subscription\");\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n  Policies.prototype.identify = function (object, partialContext) {\n    var _a;\n    var policies = this;\n    var typename = partialContext && (partialContext.typename || ((_a = partialContext.storeObject) === null || _a === void 0 ? void 0 : _a.__typename)) || object.__typename;\n    if (typename === this.rootTypenamesById.ROOT_QUERY) {\n      return [\"ROOT_QUERY\"];\n    }\n    var storeObject = partialContext && partialContext.storeObject || object;\n    var context = __assign(__assign({}, partialContext), {\n      typename: typename,\n      storeObject: storeObject,\n      readField: partialContext && partialContext.readField || function () {\n        var options = normalizeReadFieldOptions(arguments, storeObject);\n        return policies.readField(options, {\n          store: policies.cache[\"data\"],\n          variables: options.variables\n        });\n      }\n    });\n    var id;\n    var policy = typename && this.getTypePolicy(typename);\n    var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n    while (keyFn) {\n      var specifierOrId = keyFn(__assign(__assign({}, object), storeObject), context);\n      if (isArray(specifierOrId)) {\n        keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n      } else {\n        id = specifierOrId;\n        break;\n      }\n    }\n    id = id ? String(id) : void 0;\n    return context.keyObject ? [id, context.keyObject] : [id];\n  };\n  Policies.prototype.addTypePolicies = function (typePolicies) {\n    var _this = this;\n    Object.keys(typePolicies).forEach(function (typename) {\n      var _a = typePolicies[typename],\n        queryType = _a.queryType,\n        mutationType = _a.mutationType,\n        subscriptionType = _a.subscriptionType,\n        incoming = __rest(_a, [\"queryType\", \"mutationType\", \"subscriptionType\"]);\n      if (queryType) _this.setRootTypename(\"Query\", typename);\n      if (mutationType) _this.setRootTypename(\"Mutation\", typename);\n      if (subscriptionType) _this.setRootTypename(\"Subscription\", typename);\n      if (hasOwn.call(_this.toBeAdded, typename)) {\n        _this.toBeAdded[typename].push(incoming);\n      } else {\n        _this.toBeAdded[typename] = [incoming];\n      }\n    });\n  };\n  Policies.prototype.updateTypePolicy = function (typename, incoming) {\n    var _this = this;\n    var existing = this.getTypePolicy(typename);\n    var keyFields = incoming.keyFields,\n      fields = incoming.fields;\n    function setMerge(existing, merge) {\n      existing.merge = typeof merge === \"function\" ? merge : merge === true ? mergeTrueFn : merge === false ? mergeFalseFn : existing.merge;\n    }\n    setMerge(existing, incoming.merge);\n    existing.keyFn = keyFields === false ? nullKeyFieldsFn : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === \"function\" ? keyFields : existing.keyFn;\n    if (fields) {\n      Object.keys(fields).forEach(function (fieldName) {\n        var existing = _this.getFieldPolicy(typename, fieldName, true);\n        var incoming = fields[fieldName];\n        if (typeof incoming === \"function\") {\n          existing.read = incoming;\n        } else {\n          var keyArgs = incoming.keyArgs,\n            read = incoming.read,\n            merge = incoming.merge;\n          existing.keyFn = keyArgs === false ? simpleKeyArgsFn : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === \"function\" ? keyArgs : existing.keyFn;\n          if (typeof read === \"function\") {\n            existing.read = read;\n          }\n          setMerge(existing, merge);\n        }\n        if (existing.read && existing.merge) {\n          existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n        }\n      });\n    }\n  };\n  Policies.prototype.setRootTypename = function (which, typename) {\n    if (typename === void 0) {\n      typename = which;\n    }\n    var rootId = \"ROOT_\" + which.toUpperCase();\n    var old = this.rootTypenamesById[rootId];\n    if (typename !== old) {\n      __DEV__ ? invariant(!old || old === which, \"Cannot change root \".concat(which, \" __typename more than once\")) : invariant(!old || old === which, 3);\n      if (old) delete this.rootIdsByTypename[old];\n      this.rootIdsByTypename[typename] = rootId;\n      this.rootTypenamesById[rootId] = typename;\n    }\n  };\n  Policies.prototype.addPossibleTypes = function (possibleTypes) {\n    var _this = this;\n    this.usingPossibleTypes = true;\n    Object.keys(possibleTypes).forEach(function (supertype) {\n      _this.getSupertypeSet(supertype, true);\n      possibleTypes[supertype].forEach(function (subtype) {\n        _this.getSupertypeSet(subtype, true).add(supertype);\n        var match = subtype.match(TypeOrFieldNameRegExp);\n        if (!match || match[0] !== subtype) {\n          _this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n        }\n      });\n    });\n  };\n  Policies.prototype.getTypePolicy = function (typename) {\n    var _this = this;\n    if (!hasOwn.call(this.typePolicies, typename)) {\n      var policy_1 = this.typePolicies[typename] = Object.create(null);\n      policy_1.fields = Object.create(null);\n      var supertypes = this.supertypeMap.get(typename);\n      if (supertypes && supertypes.size) {\n        supertypes.forEach(function (supertype) {\n          var _a = _this.getTypePolicy(supertype),\n            fields = _a.fields,\n            rest = __rest(_a, [\"fields\"]);\n          Object.assign(policy_1, rest);\n          Object.assign(policy_1.fields, fields);\n        });\n      }\n    }\n    var inbox = this.toBeAdded[typename];\n    if (inbox && inbox.length) {\n      inbox.splice(0).forEach(function (policy) {\n        _this.updateTypePolicy(typename, policy);\n      });\n    }\n    return this.typePolicies[typename];\n  };\n  Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\n    if (typename) {\n      var fieldPolicies = this.getTypePolicy(typename).fields;\n      return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = Object.create(null));\n    }\n  };\n  Policies.prototype.getSupertypeSet = function (subtype, createIfMissing) {\n    var supertypeSet = this.supertypeMap.get(subtype);\n    if (!supertypeSet && createIfMissing) {\n      this.supertypeMap.set(subtype, supertypeSet = new Set());\n    }\n    return supertypeSet;\n  };\n  Policies.prototype.fragmentMatches = function (fragment, typename, result, variables) {\n    var _this = this;\n    if (!fragment.typeCondition) return true;\n    if (!typename) return false;\n    var supertype = fragment.typeCondition.name.value;\n    if (typename === supertype) return true;\n    if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {\n      var typenameSupertypeSet = this.getSupertypeSet(typename, true);\n      var workQueue_1 = [typenameSupertypeSet];\n      var maybeEnqueue_1 = function maybeEnqueue_1(subtype) {\n        var supertypeSet = _this.getSupertypeSet(subtype, false);\n        if (supertypeSet && supertypeSet.size && workQueue_1.indexOf(supertypeSet) < 0) {\n          workQueue_1.push(supertypeSet);\n        }\n      };\n      var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n      var checkingFuzzySubtypes = false;\n      for (var i = 0; i < workQueue_1.length; ++i) {\n        var supertypeSet = workQueue_1[i];\n        if (supertypeSet.has(supertype)) {\n          if (!typenameSupertypeSet.has(supertype)) {\n            if (checkingFuzzySubtypes) {\n              __DEV__ && invariant.warn(\"Inferring subtype \".concat(typename, \" of supertype \").concat(supertype));\n            }\n            typenameSupertypeSet.add(supertype);\n          }\n          return true;\n        }\n        supertypeSet.forEach(maybeEnqueue_1);\n        if (needToCheckFuzzySubtypes && i === workQueue_1.length - 1 && selectionSetMatchesResult(fragment.selectionSet, result, variables)) {\n          needToCheckFuzzySubtypes = false;\n          checkingFuzzySubtypes = true;\n          this.fuzzySubtypes.forEach(function (regExp, fuzzyString) {\n            var match = typename.match(regExp);\n            if (match && match[0] === typename) {\n              maybeEnqueue_1(fuzzyString);\n            }\n          });\n        }\n      }\n    }\n    return false;\n  };\n  Policies.prototype.hasKeyArgs = function (typename, fieldName) {\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    return !!(policy && policy.keyFn);\n  };\n  Policies.prototype.getStoreFieldName = function (fieldSpec) {\n    var typename = fieldSpec.typename,\n      fieldName = fieldSpec.fieldName;\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    var storeFieldName;\n    var keyFn = policy && policy.keyFn;\n    if (keyFn && typename) {\n      var context = {\n        typename: typename,\n        fieldName: fieldName,\n        field: fieldSpec.field || null,\n        variables: fieldSpec.variables\n      };\n      var args = argsFromFieldSpecifier(fieldSpec);\n      while (keyFn) {\n        var specifierOrString = keyFn(args, context);\n        if (isArray(specifierOrString)) {\n          keyFn = keyArgsFnFromSpecifier(specifierOrString);\n        } else {\n          storeFieldName = specifierOrString || fieldName;\n          break;\n        }\n      }\n    }\n    if (storeFieldName === void 0) {\n      storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n    }\n    if (storeFieldName === false) {\n      return fieldName;\n    }\n    return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + \":\" + storeFieldName;\n  };\n  Policies.prototype.readField = function (options, context) {\n    var objectOrReference = options.from;\n    if (!objectOrReference) return;\n    var nameOrField = options.field || options.fieldName;\n    if (!nameOrField) return;\n    if (options.typename === void 0) {\n      var typename = context.store.getFieldValue(objectOrReference, \"__typename\");\n      if (typename) options.typename = typename;\n    }\n    var storeFieldName = this.getStoreFieldName(options);\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var existing = context.store.getFieldValue(objectOrReference, storeFieldName);\n    var policy = this.getFieldPolicy(options.typename, fieldName, false);\n    var read = policy && policy.read;\n    if (read) {\n      var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));\n      return cacheSlot.withValue(this.cache, read, [existing, readOptions]);\n    }\n    return existing;\n  };\n  Policies.prototype.getReadFunction = function (typename, fieldName) {\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    return policy && policy.read;\n  };\n  Policies.prototype.getMergeFunction = function (parentTypename, fieldName, childTypename) {\n    var policy = this.getFieldPolicy(parentTypename, fieldName, false);\n    var merge = policy && policy.merge;\n    if (!merge && childTypename) {\n      policy = this.getTypePolicy(childTypename);\n      merge = policy && policy.merge;\n    }\n    return merge;\n  };\n  Policies.prototype.runMergeFunction = function (existing, incoming, _a, context, storage) {\n    var field = _a.field,\n      typename = _a.typename,\n      merge = _a.merge;\n    if (merge === mergeTrueFn) {\n      return makeMergeObjectsFunction(context.store)(existing, incoming);\n    }\n    if (merge === mergeFalseFn) {\n      return incoming;\n    }\n    if (context.overwrite) {\n      existing = void 0;\n    }\n    return merge(existing, incoming, makeFieldFunctionOptions(this, void 0, {\n      typename: typename,\n      fieldName: field.name.value,\n      field: field,\n      variables: context.variables\n    }, context, storage || Object.create(null)));\n  };\n  return Policies;\n}();\nexport { Policies };\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {\n  var storeFieldName = policies.getStoreFieldName(fieldSpec);\n  var fieldName = fieldNameFromStoreName(storeFieldName);\n  var variables = fieldSpec.variables || context.variables;\n  var _a = context.store,\n    toReference = _a.toReference,\n    canRead = _a.canRead;\n  return {\n    args: argsFromFieldSpecifier(fieldSpec),\n    field: fieldSpec.field || null,\n    fieldName: fieldName,\n    storeFieldName: storeFieldName,\n    variables: variables,\n    isReference: isReference,\n    toReference: toReference,\n    storage: storage,\n    cache: policies.cache,\n    canRead: canRead,\n    readField: function readField() {\n      return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context);\n    },\n    mergeObjects: makeMergeObjectsFunction(context.store)\n  };\n}\nexport function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {\n  var fieldNameOrOptions = readFieldArgs[0],\n    from = readFieldArgs[1],\n    argc = readFieldArgs.length;\n  var options;\n  if (typeof fieldNameOrOptions === \"string\") {\n    options = {\n      fieldName: fieldNameOrOptions,\n      from: argc > 1 ? from : objectOrReference\n    };\n  } else {\n    options = __assign({}, fieldNameOrOptions);\n    if (!hasOwn.call(options, \"from\")) {\n      options.from = objectOrReference;\n    }\n  }\n  if (__DEV__ && options.from === void 0) {\n    __DEV__ && invariant.warn(\"Undefined 'from' passed to readField with arguments \".concat(stringifyForDisplay(Array.from(readFieldArgs))));\n  }\n  if (void 0 === options.variables) {\n    options.variables = variables;\n  }\n  return options;\n}\nfunction makeMergeObjectsFunction(store) {\n  return function mergeObjects(existing, incoming) {\n    if (isArray(existing) || isArray(incoming)) {\n      throw __DEV__ ? new InvariantError(\"Cannot automatically merge arrays\") : new InvariantError(4);\n    }\n    if (isNonNullObject(existing) && isNonNullObject(incoming)) {\n      var eType = store.getFieldValue(existing, \"__typename\");\n      var iType = store.getFieldValue(incoming, \"__typename\");\n      var typesDiffer = eType && iType && eType !== iType;\n      if (typesDiffer) {\n        return incoming;\n      }\n      if (isReference(existing) && storeValueIsStoreObject(incoming)) {\n        store.merge(existing.__ref, incoming);\n        return existing;\n      }\n      if (storeValueIsStoreObject(existing) && isReference(incoming)) {\n        store.merge(existing, incoming.__ref);\n        return incoming;\n      }\n      if (storeValueIsStoreObject(existing) && storeValueIsStoreObject(incoming)) {\n        return __assign(__assign({}, existing), incoming);\n      }\n    }\n    return incoming;\n  };\n}","map":{"version":3,"names":["invariant","InvariantError","storeKeyNameFromField","argumentsObjectFromField","isReference","getStoreKeyName","isNonNullObject","stringifyForDisplay","hasOwn","fieldNameFromStoreName","storeValueIsStoreObject","selectionSetMatchesResult","TypeOrFieldNameRegExp","defaultDataIdFromObject","isArray","cacheSlot","canonicalStringify","keyArgsFnFromSpecifier","keyFieldsFnFromSpecifier","setStringify","argsFromFieldSpecifier","spec","args","field","variables","nullKeyFieldsFn","simpleKeyArgsFn","_args","context","fieldName","mergeTrueFn","existing","incoming","_a","mergeObjects","mergeFalseFn","_","Policies","config","typePolicies","Object","create","toBeAdded","supertypeMap","Map","fuzzySubtypes","rootIdsByTypename","rootTypenamesById","usingPossibleTypes","__assign","dataIdFromObject","cache","setRootTypename","possibleTypes","addPossibleTypes","addTypePolicies","prototype","identify","object","partialContext","policies","typename","storeObject","__typename","ROOT_QUERY","readField","options","normalizeReadFieldOptions","arguments","store","id","policy","getTypePolicy","keyFn","specifierOrId","String","keyObject","_this","keys","forEach","queryType","mutationType","subscriptionType","__rest","call","push","updateTypePolicy","keyFields","fields","setMerge","merge","getFieldPolicy","read","keyArgs","which","rootId","toUpperCase","old","__DEV__","concat","supertype","getSupertypeSet","subtype","add","match","set","RegExp","policy_1","supertypes","get","size","rest","assign","inbox","length","splice","createIfMissing","fieldPolicies","supertypeSet","Set","fragmentMatches","fragment","result","typeCondition","name","value","has","typenameSupertypeSet","workQueue_1","maybeEnqueue_1","indexOf","needToCheckFuzzySubtypes","checkingFuzzySubtypes","i","warn","selectionSet","regExp","fuzzyString","hasKeyArgs","getStoreFieldName","fieldSpec","storeFieldName","specifierOrString","objectOrReference","from","nameOrField","getFieldValue","readOptions","makeFieldFunctionOptions","getStorage","__ref","withValue","getReadFunction","getMergeFunction","parentTypename","childTypename","runMergeFunction","storage","makeMergeObjectsFunction","overwrite","toReference","canRead","readFieldArgs","fieldNameOrOptions","argc","Array","eType","iType","typesDiffer"],"sources":["/data/stackhub-web/plugins/myapps/node_modules/@apollo/src/cache/inmemory/policies.ts"],"sourcesContent":["import { invariant, InvariantError } from '../../utilities/globals';\n\nimport {\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  SelectionSetNode,\n  FieldNode,\n} from 'graphql';\n\nimport {\n  FragmentMap,\n  storeKeyNameFromField,\n  StoreValue,\n  StoreObject,\n  argumentsObjectFromField,\n  Reference,\n  isReference,\n  getStoreKeyName,\n  isNonNullObject,\n  stringifyForDisplay,\n} from '../../utilities';\nimport {\n  IdGetter,\n  MergeInfo,\n  NormalizedCache,\n  ReadMergeModifyContext,\n} from \"./types\";\nimport {\n  hasOwn,\n  fieldNameFromStoreName,\n  storeValueIsStoreObject,\n  selectionSetMatchesResult,\n  TypeOrFieldNameRegExp,\n  defaultDataIdFromObject,\n  isArray,\n} from './helpers';\nimport { cacheSlot } from './reactiveVars';\nimport { InMemoryCache } from './inMemoryCache';\nimport {\n  SafeReadonly,\n  FieldSpecifier,\n  ToReferenceFunction,\n  ReadFieldFunction,\n  ReadFieldOptions,\n  CanReadFunction,\n} from '../core/types/common';\nimport { WriteContext } from './writeToStore';\n\n// Upgrade to a faster version of the default stable JSON.stringify function\n// used by getStoreKeyName. This function is used when computing storeFieldName\n// strings (when no keyArgs has been configured for a field).\nimport { canonicalStringify } from './object-canon';\nimport { keyArgsFnFromSpecifier, keyFieldsFnFromSpecifier } from './key-extractor';\n\ngetStoreKeyName.setStringify(canonicalStringify);\n\nexport type TypePolicies = {\n  [__typename: string]: TypePolicy;\n}\n\n// TypeScript 3.7 will allow recursive type aliases, so this should work:\n// type KeySpecifier = (string | KeySpecifier)[]\nexport type KeySpecifier = ReadonlyArray<string | KeySpecifier>;\n\nexport type KeyFieldsContext = {\n  // The __typename of the incoming object, even if the __typename field was\n  // aliased to another name in the raw result object. May be undefined when\n  // dataIdFromObject is called for objects without __typename fields.\n  typename: string | undefined;\n\n  // The object to be identified, after processing to remove aliases and\n  // normalize identifiable child objects with references.\n  storeObject: StoreObject;\n\n  // Handy tool for reading additional fields from context.storeObject, either\n  // readField(\"fieldName\") to read storeObject[fieldName], or readField(\"name\",\n  // objectOrReference) to read from another object or Reference. If you read a\n  // field with a read function, that function will be invoked.\n  readField: ReadFieldFunction;\n\n  // If you are writing a custom keyFields function, and you plan to use the raw\n  // result object passed as the first argument, you may also need access to the\n  // selection set and available fragments for this object, just in case any\n  // fields have aliases. Since this logic is tricky to get right, and these\n  // context properties are not even always provided (for example, they are\n  // omitted when calling cache.identify(object), where object is assumed to be\n  // a StoreObject), we recommend you use context.storeObject (which has already\n  // been de-aliased) and context.readField (which can read from references as\n  // well as objects) instead of the raw result object in your keyFields\n  // functions, or just rely on the internal implementation of keyFields:[...]\n  // syntax to get these details right for you.\n  selectionSet?: SelectionSetNode;\n  fragmentMap?: FragmentMap;\n\n  // Internal. May be set by the KeyFieldsFunction to report fields that were\n  // involved in computing the ID. Never passed in by the caller.\n  keyObject?: Record<string, any>;\n};\n\nexport type KeyFieldsFunction = (\n  object: Readonly<StoreObject>,\n  context: KeyFieldsContext,\n) => KeySpecifier | false | ReturnType<IdGetter>;\n\ntype KeyFieldsResult = Exclude<ReturnType<KeyFieldsFunction>, KeySpecifier>;\n\n// TODO Should TypePolicy be a generic type, with a TObject or TEntity\n// type parameter?\nexport type TypePolicy = {\n  // Allows defining the primary key fields for this type, either using an\n  // array of field names or a function that returns an arbitrary string.\n  keyFields?: KeySpecifier | KeyFieldsFunction | false;\n\n  // Allows defining a merge function (or merge:true/false shorthand) to\n  // be used for merging objects of this type wherever they appear, unless\n  // the parent field also defines a merge function/boolean (that is,\n  // parent field merge functions take precedence over type policy merge\n  // functions). In many cases, defining merge:true for a given type\n  // policy can save you from specifying merge:true for all the field\n  // policies where that type might be encountered.\n  merge?: FieldMergeFunction | boolean;\n\n  // In the rare event that your schema happens to use a different\n  // __typename for the root Query, Mutation, and/or Schema types, you can\n  // express your deviant preferences by enabling one of these options.\n  queryType?: true,\n  mutationType?: true,\n  subscriptionType?: true,\n\n  fields?: {\n    [fieldName: string]:\n      | FieldPolicy<any>\n      | FieldReadFunction<any>;\n  }\n};\n\nexport type KeyArgsFunction = (\n  args: Record<string, any> | null,\n  context: {\n    typename: string;\n    fieldName: string;\n    field: FieldNode | null;\n    variables?: Record<string, any>;\n  },\n) => KeySpecifier | false | ReturnType<IdGetter>;\n\nexport type FieldPolicy<\n  // The internal representation used to store the field's data in the\n  // cache. Must be JSON-serializable if you plan to serialize the result\n  // of cache.extract() using JSON.\n  TExisting = any,\n  // The type of the incoming parameter passed to the merge function,\n  // typically matching the GraphQL response format, but with Reference\n  // objects substituted for any identifiable child objects. Often the\n  // same as TExisting, but not necessarily.\n  TIncoming = TExisting,\n  // The type that the read function actually returns, using TExisting\n  // data and options.args as input. Usually the same as TIncoming.\n  TReadResult = TIncoming,\n  // Allows FieldFunctionOptions definition to be overwritten by the\n  // developer\n  TOptions extends FieldFunctionOptions = FieldFunctionOptions\n> = {\n  keyArgs?: KeySpecifier | KeyArgsFunction | false;\n  read?: FieldReadFunction<TExisting, TReadResult, TOptions>;\n  merge?: FieldMergeFunction<TExisting, TIncoming, TOptions> | boolean;\n};\n\nexport type StorageType = Record<string, any>;\n\nfunction argsFromFieldSpecifier(spec: FieldSpecifier) {\n  return spec.args !== void 0 ? spec.args :\n    spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;\n}\n\nexport interface FieldFunctionOptions<\n  TArgs = Record<string, any>,\n  TVars = Record<string, any>,\n> {\n  args: TArgs | null;\n\n  // The name of the field, equal to options.field.name.value when\n  // options.field is available. Useful if you reuse the same function for\n  // multiple fields, and you need to know which field you're currently\n  // processing. Always a string, even when options.field is null.\n  fieldName: string;\n\n  // The full field key used internally, including serialized key arguments.\n  storeFieldName: string;\n\n  // The FieldNode object used to read this field. Useful if you need to\n  // know about other attributes of the field, such as its directives. This\n  // option will be null when a string was passed to options.readField.\n  field: FieldNode | null;\n\n  variables?: TVars;\n\n  // Utilities for dealing with { __ref } objects.\n  isReference: typeof isReference;\n  toReference: ToReferenceFunction;\n\n  // A handy place to put field-specific data that you want to survive\n  // across multiple read function calls. Useful for field-level caching,\n  // if your read function does any expensive work.\n  storage: StorageType;\n\n  cache: InMemoryCache;\n\n  // Helper function for reading other fields within the current object.\n  // If a foreign object or reference is provided, the field will be read\n  // from that object instead of the current object, so this function can\n  // be used (together with isReference) to examine the cache outside the\n  // current object. If a FieldNode is passed instead of a string, and\n  // that FieldNode has arguments, the same options.variables will be used\n  // to compute the argument values. Note that this function will invoke\n  // custom read functions for other fields, if defined. Always returns\n  // immutable data (enforced with Object.freeze in development).\n  readField: ReadFieldFunction;\n\n  // Returns true for non-normalized StoreObjects and non-dangling\n  // References, indicating that readField(name, objOrRef) has a chance of\n  // working. Useful for filtering out dangling references from lists.\n  canRead: CanReadFunction;\n\n  // Instead of just merging objects with { ...existing, ...incoming }, this\n  // helper function can be used to merge objects in a way that respects any\n  // custom merge functions defined for their fields.\n  mergeObjects: MergeObjectsFunction;\n}\n\ntype MergeObjectsFunction = <T extends StoreObject | Reference>(\n  existing: T,\n  incoming: T,\n) => T;\n\nexport type FieldReadFunction<\n  TExisting = any,\n  TReadResult = TExisting,\n  TOptions extends FieldFunctionOptions = FieldFunctionOptions\n> = (\n  // When reading a field, one often needs to know about any existing\n  // value stored for that field. If the field is read before any value\n  // has been written to the cache, this existing parameter will be\n  // undefined, which makes it easy to use a default parameter expression\n  // to supply the initial value. This parameter is positional (rather\n  // than one of the named options) because that makes it possible for the\n  // developer to annotate it with a type, without also having to provide\n  // a whole new type for the options object.\n  existing: SafeReadonly<TExisting> | undefined,\n  options: TOptions,\n) => TReadResult | undefined;\n\nexport type FieldMergeFunction<\n  TExisting = any,\n  TIncoming = TExisting,\n  // Passing the whole FieldFunctionOptions makes the current definition\n  // independent from its implementation\n  TOptions extends FieldFunctionOptions = FieldFunctionOptions\n> = (\n  existing: SafeReadonly<TExisting> | undefined,\n  // The incoming parameter needs to be positional as well, for the same\n  // reasons discussed in FieldReadFunction above.\n  incoming: SafeReadonly<TIncoming>,\n  options: TOptions,\n) => SafeReadonly<TExisting>;\n\nconst nullKeyFieldsFn: KeyFieldsFunction = () => void 0;\nconst simpleKeyArgsFn: KeyArgsFunction = (_args, context) => context.fieldName;\n\n// These merge functions can be selected by specifying merge:true or\n// merge:false in a field policy.\nconst mergeTrueFn: FieldMergeFunction<any> =\n  (existing, incoming, { mergeObjects }) => mergeObjects(existing, incoming);\nconst mergeFalseFn: FieldMergeFunction<any> = (_, incoming) => incoming;\n\nexport type PossibleTypesMap = {\n  [supertype: string]: string[];\n};\n\nexport class Policies {\n  private typePolicies: {\n    [__typename: string]: {\n      keyFn?: KeyFieldsFunction;\n      merge?: FieldMergeFunction<any>;\n      fields: {\n        [fieldName: string]: {\n          keyFn?: KeyArgsFunction;\n          read?: FieldReadFunction<any>;\n          merge?: FieldMergeFunction<any>;\n        };\n      };\n    };\n  } = Object.create(null);\n\n  private toBeAdded: {\n    [__typename: string]: TypePolicy[];\n  } = Object.create(null);\n\n  // Map from subtype names to sets of supertype names. Note that this\n  // representation inverts the structure of possibleTypes (whose keys are\n  // supertypes and whose values are arrays of subtypes) because it tends\n  // to be much more efficient to search upwards than downwards.\n  private supertypeMap = new Map<string, Set<string>>();\n\n  // Any fuzzy subtypes specified by possibleTypes will be converted to\n  // RegExp objects and recorded here. Every key of this map can also be\n  // found in supertypeMap. In many cases this Map will be empty, which\n  // means no fuzzy subtype checking will happen in fragmentMatches.\n  private fuzzySubtypes = new Map<string, RegExp>();\n\n  public readonly cache: InMemoryCache;\n\n  public readonly rootIdsByTypename: Record<string, string> = Object.create(null);\n  public readonly rootTypenamesById: Record<string, string> = Object.create(null);\n\n  public readonly usingPossibleTypes = false;\n\n  constructor(private config: {\n    cache: InMemoryCache;\n    dataIdFromObject?: KeyFieldsFunction;\n    possibleTypes?: PossibleTypesMap;\n    typePolicies?: TypePolicies;\n  }) {\n    this.config = {\n      dataIdFromObject: defaultDataIdFromObject,\n      ...config,\n    };\n\n    this.cache = this.config.cache;\n\n    this.setRootTypename(\"Query\");\n    this.setRootTypename(\"Mutation\");\n    this.setRootTypename(\"Subscription\");\n\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n\n  public identify(\n    object: StoreObject,\n    partialContext?: Partial<KeyFieldsContext>,\n  ): [string?, StoreObject?] {\n    const policies = this;\n\n    const typename = partialContext && (\n      partialContext.typename ||\n      partialContext.storeObject?.__typename\n    ) || object.__typename;\n\n    // It should be possible to write root Query fields with writeFragment,\n    // using { __typename: \"Query\", ... } as the data, but it does not make\n    // sense to allow the same identification behavior for the Mutation and\n    // Subscription types, since application code should never be writing\n    // directly to (or reading directly from) those root objects.\n    if (typename === this.rootTypenamesById.ROOT_QUERY) {\n      return [\"ROOT_QUERY\"];\n    }\n\n    // Default context.storeObject to object if not otherwise provided.\n    const storeObject = partialContext && partialContext.storeObject || object;\n\n    const context: KeyFieldsContext = {\n      ...partialContext,\n      typename,\n      storeObject,\n      readField: partialContext && partialContext.readField || function () {\n        const options = normalizeReadFieldOptions(arguments, storeObject);\n        return policies.readField(options, {\n          store: policies.cache[\"data\"],\n          variables: options.variables,\n        });\n      },\n    };\n\n    let id: KeyFieldsResult;\n\n    const policy = typename && this.getTypePolicy(typename);\n    let keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n    while (keyFn) {\n      const specifierOrId = keyFn({...object, ...storeObject}, context);\n      if (isArray(specifierOrId)) {\n        keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n      } else {\n        id = specifierOrId;\n        break;\n      }\n    }\n\n    id = id ? String(id) : void 0;\n    return context.keyObject ? [id, context.keyObject] : [id];\n  }\n\n  public addTypePolicies(typePolicies: TypePolicies) {\n    Object.keys(typePolicies).forEach(typename => {\n      const {\n        queryType,\n        mutationType,\n        subscriptionType,\n        ...incoming\n      } = typePolicies[typename];\n\n      // Though {query,mutation,subscription}Type configurations are rare,\n      // it's important to call setRootTypename as early as possible,\n      // since these configurations should apply consistently for the\n      // entire lifetime of the cache. Also, since only one __typename can\n      // qualify as one of these root types, these three properties cannot\n      // be inherited, unlike the rest of the incoming properties. That\n      // restriction is convenient, because the purpose of this.toBeAdded\n      // is to delay the processing of type/field policies until the first\n      // time they're used, allowing policies to be added in any order as\n      // long as all relevant policies (including policies for supertypes)\n      // have been added by the time a given policy is used for the first\n      // time. In other words, since inheritance doesn't matter for these\n      // properties, there's also no need to delay their processing using\n      // the this.toBeAdded queue.\n      if (queryType) this.setRootTypename(\"Query\", typename);\n      if (mutationType) this.setRootTypename(\"Mutation\", typename);\n      if (subscriptionType) this.setRootTypename(\"Subscription\", typename);\n\n      if (hasOwn.call(this.toBeAdded, typename)) {\n        this.toBeAdded[typename].push(incoming);\n      } else {\n        this.toBeAdded[typename] = [incoming];\n      }\n    });\n  }\n\n  private updateTypePolicy(typename: string, incoming: TypePolicy) {\n    const existing = this.getTypePolicy(typename);\n    const { keyFields, fields } = incoming;\n\n    function setMerge(\n      existing: { merge?: FieldMergeFunction | boolean; },\n      merge?: FieldMergeFunction | boolean,\n    ) {\n      existing.merge =\n        typeof merge === \"function\" ? merge :\n        // Pass merge:true as a shorthand for a merge implementation\n        // that returns options.mergeObjects(existing, incoming).\n        merge === true ? mergeTrueFn :\n        // Pass merge:false to make incoming always replace existing\n        // without any warnings about data clobbering.\n        merge === false ? mergeFalseFn :\n        existing.merge;\n    }\n\n    // Type policies can define merge functions, as an alternative to\n    // using field policies to merge child objects.\n    setMerge(existing, incoming.merge);\n\n    existing.keyFn =\n      // Pass false to disable normalization for this typename.\n      keyFields === false ? nullKeyFieldsFn :\n      // Pass an array of strings to use those fields to compute a\n      // composite ID for objects of this typename.\n      isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) :\n      // Pass a function to take full control over identification.\n      typeof keyFields === \"function\" ? keyFields :\n      // Leave existing.keyFn unchanged if above cases fail.\n      existing.keyFn;\n\n    if (fields) {\n      Object.keys(fields).forEach(fieldName => {\n        const existing = this.getFieldPolicy(typename, fieldName, true)!;\n        const incoming = fields[fieldName];\n\n        if (typeof incoming === \"function\") {\n          existing.read = incoming;\n        } else {\n          const { keyArgs, read, merge } = incoming;\n\n          existing.keyFn =\n            // Pass false to disable argument-based differentiation of\n            // field identities.\n            keyArgs === false ? simpleKeyArgsFn :\n            // Pass an array of strings to use named arguments to\n            // compute a composite identity for the field.\n            isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) :\n            // Pass a function to take full control over field identity.\n            typeof keyArgs === \"function\" ? keyArgs :\n            // Leave existing.keyFn unchanged if above cases fail.\n            existing.keyFn;\n\n          if (typeof read === \"function\") {\n            existing.read = read;\n          }\n\n          setMerge(existing, merge);\n        }\n\n        if (existing.read && existing.merge) {\n          // If we have both a read and a merge function, assume\n          // keyArgs:false, because read and merge together can take\n          // responsibility for interpreting arguments in and out. This\n          // default assumption can always be overridden by specifying\n          // keyArgs explicitly in the FieldPolicy.\n          existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n        }\n      });\n    }\n  }\n\n  private setRootTypename(\n    which: \"Query\" | \"Mutation\" | \"Subscription\",\n    typename: string = which,\n  ) {\n    const rootId = \"ROOT_\" + which.toUpperCase();\n    const old = this.rootTypenamesById[rootId];\n    if (typename !== old) {\n      invariant(!old || old === which, `Cannot change root ${which} __typename more than once`);\n      // First, delete any old __typename associated with this rootId from\n      // rootIdsByTypename.\n      if (old) delete this.rootIdsByTypename[old];\n      // Now make this the only __typename that maps to this rootId.\n      this.rootIdsByTypename[typename] = rootId;\n      // Finally, update the __typename associated with this rootId.\n      this.rootTypenamesById[rootId] = typename;\n    }\n  }\n\n  public addPossibleTypes(possibleTypes: PossibleTypesMap) {\n    (this.usingPossibleTypes as boolean) = true;\n    Object.keys(possibleTypes).forEach(supertype => {\n      // Make sure all types have an entry in this.supertypeMap, even if\n      // their supertype set is empty, so we can return false immediately\n      // from policies.fragmentMatches for unknown supertypes.\n      this.getSupertypeSet(supertype, true);\n\n      possibleTypes[supertype].forEach(subtype => {\n        this.getSupertypeSet(subtype, true)!.add(supertype);\n        const match = subtype.match(TypeOrFieldNameRegExp);\n        if (!match || match[0] !== subtype) {\n          // TODO Don't interpret just any invalid typename as a RegExp.\n          this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n        }\n      });\n    });\n  }\n\n  private getTypePolicy(typename: string): Policies[\"typePolicies\"][string] {\n    if (!hasOwn.call(this.typePolicies, typename)) {\n      const policy: Policies[\"typePolicies\"][string] =\n        this.typePolicies[typename] = Object.create(null);\n      policy.fields = Object.create(null);\n\n      // When the TypePolicy for typename is first accessed, instead of\n      // starting with an empty policy object, inherit any properties or\n      // fields from the type policies of the supertypes of typename.\n      //\n      // Any properties or fields defined explicitly within the TypePolicy\n      // for typename will take precedence, and if there are multiple\n      // supertypes, the properties of policies whose types were added\n      // later via addPossibleTypes will take precedence over those of\n      // earlier supertypes. TODO Perhaps we should warn about these\n      // conflicts in development, and recommend defining the property\n      // explicitly in the subtype policy?\n      //\n      // Field policy inheritance is atomic/shallow: you can't inherit a\n      // field policy and then override just its read function, since read\n      // and merge functions often need to cooperate, so changing only one\n      // of them would be a recipe for inconsistency.\n      //\n      // Once the TypePolicy for typename has been accessed, its\n      // properties can still be updated directly using addTypePolicies,\n      // but future changes to supertype policies will not be reflected in\n      // this policy, because this code runs at most once per typename.\n      const supertypes = this.supertypeMap.get(typename);\n      if (supertypes && supertypes.size) {\n        supertypes.forEach(supertype => {\n          const { fields, ...rest } = this.getTypePolicy(supertype);\n          Object.assign(policy, rest);\n          Object.assign(policy.fields, fields);\n        });\n      }\n    }\n\n    const inbox = this.toBeAdded[typename];\n    if (inbox && inbox.length) {\n      // Merge the pending policies into this.typePolicies, in the order they\n      // were originally passed to addTypePolicy.\n      inbox.splice(0).forEach(policy => {\n        this.updateTypePolicy(typename, policy);\n      });\n    }\n\n    return this.typePolicies[typename];\n  }\n\n  private getFieldPolicy(\n    typename: string | undefined,\n    fieldName: string,\n    createIfMissing: boolean,\n  ): {\n    keyFn?: KeyArgsFunction;\n    read?: FieldReadFunction<any>;\n    merge?: FieldMergeFunction<any>;\n  } | undefined {\n    if (typename) {\n      const fieldPolicies = this.getTypePolicy(typename).fields;\n      return fieldPolicies[fieldName] || (\n        createIfMissing && (fieldPolicies[fieldName] = Object.create(null)));\n    }\n  }\n\n  private getSupertypeSet(\n    subtype: string,\n    createIfMissing: boolean,\n  ): Set<string> | undefined {\n    let supertypeSet = this.supertypeMap.get(subtype);\n    if (!supertypeSet && createIfMissing) {\n      this.supertypeMap.set(subtype, supertypeSet = new Set<string>());\n    }\n    return supertypeSet;\n  }\n\n  public fragmentMatches(\n    fragment: InlineFragmentNode | FragmentDefinitionNode,\n    typename: string | undefined,\n    result?: Record<string, any>,\n    variables?: Record<string, any>,\n  ): boolean {\n    if (!fragment.typeCondition) return true;\n\n    // If the fragment has a type condition but the object we're matching\n    // against does not have a __typename, the fragment cannot match.\n    if (!typename) return false;\n\n    const supertype = fragment.typeCondition.name.value;\n    // Common case: fragment type condition and __typename are the same.\n    if (typename === supertype) return true;\n\n    if (this.usingPossibleTypes &&\n        this.supertypeMap.has(supertype)) {\n      const typenameSupertypeSet = this.getSupertypeSet(typename, true)!;\n      const workQueue = [typenameSupertypeSet];\n      const maybeEnqueue = (subtype: string) => {\n        const supertypeSet = this.getSupertypeSet(subtype, false);\n        if (supertypeSet &&\n            supertypeSet.size &&\n            workQueue.indexOf(supertypeSet) < 0) {\n          workQueue.push(supertypeSet);\n        }\n      };\n\n      // We need to check fuzzy subtypes only if we encountered fuzzy\n      // subtype strings in addPossibleTypes, and only while writing to\n      // the cache, since that's when selectionSetMatchesResult gives a\n      // strong signal of fragment matching. The StoreReader class calls\n      // policies.fragmentMatches without passing a result object, so\n      // needToCheckFuzzySubtypes is always false while reading.\n      let needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n      let checkingFuzzySubtypes = false;\n\n      // It's important to keep evaluating workQueue.length each time through\n      // the loop, because the queue can grow while we're iterating over it.\n      for (let i = 0; i < workQueue.length; ++i) {\n        const supertypeSet = workQueue[i];\n\n        if (supertypeSet.has(supertype)) {\n          if (!typenameSupertypeSet.has(supertype)) {\n            if (checkingFuzzySubtypes) {\n              invariant.warn(`Inferring subtype ${typename} of supertype ${supertype}`);\n            }\n            // Record positive results for faster future lookup.\n            // Unfortunately, we cannot safely cache negative results,\n            // because new possibleTypes data could always be added to the\n            // Policies class.\n            typenameSupertypeSet.add(supertype);\n          }\n          return true;\n        }\n\n        supertypeSet.forEach(maybeEnqueue);\n\n        if (needToCheckFuzzySubtypes &&\n            // Start checking fuzzy subtypes only after exhausting all\n            // non-fuzzy subtypes (after the final iteration of the loop).\n            i === workQueue.length - 1 &&\n            // We could wait to compare fragment.selectionSet to result\n            // after we verify the supertype, but this check is often less\n            // expensive than that search, and we will have to do the\n            // comparison anyway whenever we find a potential match.\n            selectionSetMatchesResult(fragment.selectionSet, result!, variables)) {\n          // We don't always need to check fuzzy subtypes (if no result\n          // was provided, or !this.fuzzySubtypes.size), but, when we do,\n          // we only want to check them once.\n          needToCheckFuzzySubtypes = false;\n          checkingFuzzySubtypes = true;\n\n          // If we find any fuzzy subtypes that match typename, extend the\n          // workQueue to search through the supertypes of those fuzzy\n          // subtypes. Otherwise the for-loop will terminate and we'll\n          // return false below.\n          this.fuzzySubtypes.forEach((regExp, fuzzyString) => {\n            const match = typename.match(regExp);\n            if (match && match[0] === typename) {\n              maybeEnqueue(fuzzyString);\n            }\n          });\n        }\n      }\n    }\n\n    return false;\n  }\n\n  public hasKeyArgs(typename: string | undefined, fieldName: string) {\n    const policy = this.getFieldPolicy(typename, fieldName, false);\n    return !!(policy && policy.keyFn);\n  }\n\n  public getStoreFieldName(fieldSpec: FieldSpecifier): string {\n    const { typename, fieldName } = fieldSpec;\n    const policy = this.getFieldPolicy(typename, fieldName, false);\n    let storeFieldName: Exclude<ReturnType<KeyArgsFunction>, KeySpecifier>;\n\n    let keyFn = policy && policy.keyFn;\n    if (keyFn && typename) {\n      const context: Parameters<KeyArgsFunction>[1] = {\n        typename,\n        fieldName,\n        field: fieldSpec.field || null,\n        variables: fieldSpec.variables,\n      };\n      const args = argsFromFieldSpecifier(fieldSpec);\n      while (keyFn) {\n        const specifierOrString = keyFn(args, context);\n        if (isArray(specifierOrString)) {\n          keyFn = keyArgsFnFromSpecifier(specifierOrString);\n        } else {\n          // If the custom keyFn returns a falsy value, fall back to\n          // fieldName instead.\n          storeFieldName = specifierOrString || fieldName;\n          break;\n        }\n      }\n    }\n\n    if (storeFieldName === void 0) {\n      storeFieldName = fieldSpec.field\n        ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)\n        : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n    }\n\n    // Returning false from a keyArgs function is like configuring\n    // keyArgs: false, but more dynamic.\n    if (storeFieldName === false) {\n      return fieldName;\n    }\n\n    // Make sure custom field names start with the actual field.name.value\n    // of the field, so we can always figure out which properties of a\n    // StoreObject correspond to which original field names.\n    return fieldName === fieldNameFromStoreName(storeFieldName)\n      ? storeFieldName\n      : fieldName + \":\" + storeFieldName;\n  }\n\n  public readField<V = StoreValue>(\n    options: ReadFieldOptions,\n    context: ReadMergeModifyContext,\n  ): SafeReadonly<V> | undefined {\n    const objectOrReference = options.from;\n    if (!objectOrReference) return;\n\n    const nameOrField = options.field || options.fieldName;\n    if (!nameOrField) return;\n\n    if (options.typename === void 0) {\n      const typename = context.store.getFieldValue<string>(objectOrReference, \"__typename\");\n      if (typename) options.typename = typename;\n    }\n\n    const storeFieldName = this.getStoreFieldName(options);\n    const fieldName = fieldNameFromStoreName(storeFieldName);\n    const existing = context.store.getFieldValue<V>(objectOrReference, storeFieldName);\n    const policy = this.getFieldPolicy(options.typename, fieldName, false);\n    const read = policy && policy.read;\n\n    if (read) {\n      const readOptions = makeFieldFunctionOptions(\n        this,\n        objectOrReference,\n        options,\n        context,\n        context.store.getStorage(\n          isReference(objectOrReference)\n            ? objectOrReference.__ref\n            : objectOrReference,\n          storeFieldName,\n        ),\n      );\n\n      // Call read(existing, readOptions) with cacheSlot holding this.cache.\n      return cacheSlot.withValue(\n        this.cache,\n        read,\n        [existing, readOptions],\n      ) as SafeReadonly<V>;\n    }\n\n    return existing;\n  }\n\n  public getReadFunction(\n    typename: string | undefined,\n    fieldName: string,\n  ): FieldReadFunction | undefined {\n    const policy = this.getFieldPolicy(typename, fieldName, false);\n    return policy && policy.read;\n  }\n\n  public getMergeFunction(\n    parentTypename: string | undefined,\n    fieldName: string,\n    childTypename: string | undefined,\n  ): FieldMergeFunction | undefined {\n    let policy:\n      | Policies[\"typePolicies\"][string]\n      | Policies[\"typePolicies\"][string][\"fields\"][string]\n      | undefined =\n      this.getFieldPolicy(parentTypename, fieldName, false);\n    let merge = policy && policy.merge;\n    if (!merge && childTypename) {\n      policy = this.getTypePolicy(childTypename);\n      merge = policy && policy.merge;\n    }\n    return merge;\n  }\n\n  public runMergeFunction(\n    existing: StoreValue,\n    incoming: StoreValue,\n    { field, typename, merge }: MergeInfo,\n    context: WriteContext,\n    storage?: StorageType,\n  ) {\n    if (merge === mergeTrueFn) {\n      // Instead of going to the trouble of creating a full\n      // FieldFunctionOptions object and calling mergeTrueFn, we can\n      // simply call mergeObjects, as mergeTrueFn would.\n      return makeMergeObjectsFunction(\n        context.store,\n      )(existing as StoreObject,\n        incoming as StoreObject);\n    }\n\n    if (merge === mergeFalseFn) {\n      // Likewise for mergeFalseFn, whose implementation is even simpler.\n      return incoming;\n    }\n\n    // If cache.writeQuery or cache.writeFragment was called with\n    // options.overwrite set to true, we still call merge functions, but\n    // the existing data is always undefined, so the merge function will\n    // not attempt to combine the incoming data with the existing data.\n    if (context.overwrite) {\n      existing = void 0;\n    }\n\n    return merge(existing, incoming, makeFieldFunctionOptions(\n      this,\n      // Unlike options.readField for read functions, we do not fall\n      // back to the current object if no foreignObjOrRef is provided,\n      // because it's not clear what the current object should be for\n      // merge functions: the (possibly undefined) existing object, or\n      // the incoming object? If you think your merge function needs\n      // to read sibling fields in order to produce a new value for\n      // the current field, you might want to rethink your strategy,\n      // because that's a recipe for making merge behavior sensitive\n      // to the order in which fields are written into the cache.\n      // However, readField(name, ref) is useful for merge functions\n      // that need to deduplicate child objects and references.\n      void 0,\n      { typename,\n        fieldName: field.name.value,\n        field,\n        variables: context.variables },\n      context,\n      storage || Object.create(null),\n    ));\n  }\n}\n\nfunction makeFieldFunctionOptions(\n  policies: Policies,\n  objectOrReference: StoreObject | Reference | undefined,\n  fieldSpec: FieldSpecifier,\n  context: ReadMergeModifyContext,\n  storage: StorageType,\n): FieldFunctionOptions {\n  const storeFieldName = policies.getStoreFieldName(fieldSpec);\n  const fieldName = fieldNameFromStoreName(storeFieldName);\n  const variables = fieldSpec.variables || context.variables;\n  const { toReference, canRead } = context.store;\n\n  return {\n    args: argsFromFieldSpecifier(fieldSpec),\n    field: fieldSpec.field || null,\n    fieldName,\n    storeFieldName,\n    variables,\n    isReference,\n    toReference,\n    storage,\n    cache: policies.cache,\n    canRead,\n    readField<T>() {\n      return policies.readField<T>(\n        normalizeReadFieldOptions(arguments, objectOrReference, variables),\n        context,\n      );\n    },\n    mergeObjects: makeMergeObjectsFunction(context.store),\n  };\n}\n\nexport function normalizeReadFieldOptions(\n  readFieldArgs: IArguments,\n  objectOrReference: StoreObject | Reference | undefined,\n  variables?: ReadMergeModifyContext[\"variables\"],\n): ReadFieldOptions {\n  const {\n    0: fieldNameOrOptions,\n    1: from,\n    length: argc,\n  } = readFieldArgs;\n\n  let options: ReadFieldOptions;\n\n  if (typeof fieldNameOrOptions === \"string\") {\n    options = {\n      fieldName: fieldNameOrOptions,\n      // Default to objectOrReference only when no second argument was\n      // passed for the from parameter, not when undefined is explicitly\n      // passed as the second argument.\n      from: argc > 1 ? from : objectOrReference,\n    };\n  } else {\n    options = { ...fieldNameOrOptions };\n    // Default to objectOrReference only when fieldNameOrOptions.from is\n    // actually omitted, rather than just undefined.\n    if (!hasOwn.call(options, \"from\")) {\n      options.from = objectOrReference;\n    }\n  }\n\n  if (__DEV__ && options.from === void 0) {\n    invariant.warn(`Undefined 'from' passed to readField with arguments ${\n      stringifyForDisplay(Array.from(readFieldArgs))\n    }`);\n  }\n\n  if (void 0 === options.variables) {\n    options.variables = variables;\n  }\n\n  return options;\n}\n\nfunction makeMergeObjectsFunction(\n  store: NormalizedCache,\n): MergeObjectsFunction {\n  return function mergeObjects(existing, incoming) {\n    if (isArray(existing) || isArray(incoming)) {\n      throw new InvariantError(\"Cannot automatically merge arrays\");\n    }\n\n    // These dynamic checks are necessary because the parameters of a\n    // custom merge function can easily have the any type, so the type\n    // system cannot always enforce the StoreObject | Reference parameter\n    // types of options.mergeObjects.\n    if (isNonNullObject(existing) &&\n        isNonNullObject(incoming)) {\n      const eType = store.getFieldValue(existing, \"__typename\");\n      const iType = store.getFieldValue(incoming, \"__typename\");\n      const typesDiffer = eType && iType && eType !== iType;\n\n      if (typesDiffer) {\n        return incoming;\n      }\n\n      if (isReference(existing) &&\n          storeValueIsStoreObject(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // existing.__ref, preferring/overwriting any fields contributed by the\n        // newer incoming StoreObject.\n        store.merge(existing.__ref, incoming);\n        return existing;\n      }\n\n      if (storeValueIsStoreObject(existing) &&\n          isReference(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // incoming.__ref, taking fields from the older existing object only if\n        // those fields are not already present in the newer StoreObject\n        // identified by incoming.__ref.\n        store.merge(existing, incoming.__ref);\n        return incoming;\n      }\n\n      if (storeValueIsStoreObject(existing) &&\n          storeValueIsStoreObject(incoming)) {\n        return { ...existing, ...incoming };\n      }\n    }\n\n    return incoming;\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}