{"ast":null,"code":"// @ts-nocheck\nimport { top, left, right, bottom, start } from '../enums';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport getMainAxisFromPlacement from '../utils/getMainAxisFromPlacement';\nimport getAltAxis from '../utils/getAltAxis';\nimport within from '../utils/within';\nimport getLayoutRect from '../dom-utils/getLayoutRect';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport detectOverflow from '../utils/detectOverflow';\nimport getVariation from '../utils/getVariation';\nimport getFreshSideObject from '../utils/getFreshSideObject';\n/**\n *\n */\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n    options = _ref.options,\n    name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n    checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n    _options$altAxis = options.altAxis,\n    checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n    boundary = options.boundary,\n    rootBoundary = options.rootBoundary,\n    altBoundary = options.altBoundary,\n    padding = options.padding,\n    _options$tether = options.tether,\n    tether = _options$tether === void 0 ? true : _options$tether,\n    _options$tetherOffset = options.tetherOffset,\n    tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign(Object.assign({}, state.rects), {\n    placement: state.placement\n  })) : tetherOffset;\n  var data = {\n    x: 0,\n    y: 0\n  };\n  if (!popperOffsets) {\n    return;\n  }\n  if (checkMainAxis) {\n    var mainSide = mainAxis === 'y' ? top : left;\n    var altSide = mainAxis === 'y' ? bottom : right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min = popperOffsets[mainAxis] + overflow[mainSide];\n    var max = popperOffsets[mainAxis] - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];\n    // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide];\n    // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;\n    var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? Math.min(min, tetherMin) : min, offset, tether ? Math.max(max, tetherMax) : max);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n  if (checkAltAxis) {\n    var _mainSide = mainAxis === 'x' ? top : left;\n    var _altSide = mainAxis === 'x' ? bottom : right;\n    var _offset = popperOffsets[altAxis];\n    var _min = _offset + overflow[_mainSide];\n    var _max = _offset - overflow[_altSide];\n    var _preventedOffset = within(_min, _offset, _max);\n    popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n  state.modifiersData[name] = data;\n}\nexport default {\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n};","map":{"version":3,"names":["top","left","right","bottom","start","getBasePlacement","getMainAxisFromPlacement","getAltAxis","within","getLayoutRect","getOffsetParent","detectOverflow","getVariation","getFreshSideObject","preventOverflow","_ref","state","options","name","_options$mainAxis","mainAxis","checkMainAxis","_options$altAxis","altAxis","checkAltAxis","boundary","rootBoundary","altBoundary","padding","_options$tether","tether","_options$tetherOffset","tetherOffset","overflow","basePlacement","placement","variation","isBasePlacement","popperOffsets","modifiersData","referenceRect","rects","reference","popperRect","popper","tetherOffsetValue","Object","assign","data","x","y","mainSide","altSide","len","offset","min","max","additive","minLen","maxLen","arrowElement","elements","arrow","arrowRect","width","height","arrowPaddingObject","arrowPaddingMin","arrowPaddingMax","arrowLen","minOffset","maxOffset","arrowOffsetParent","clientOffset","clientTop","clientLeft","offsetModifierValue","tetherMin","tetherMax","preventedOffset","Math","enabled","phase","fn","requiresIfExists"],"sources":["/data/stackhub-web/plugins/myapps/node_modules/@patternfly/react-core/src/helpers/Popper/thirdparty/popper-core/modifiers/preventOverflow.ts"],"sourcesContent":["// @ts-nocheck\nimport { top, left, right, bottom, start } from '../enums';\nimport { Placement, Boundary, RootBoundary } from '../enums';\nimport { Rect, ModifierArguments, Modifier, Padding } from '../types';\nimport getBasePlacement from '../utils/getBasePlacement';\nimport getMainAxisFromPlacement from '../utils/getMainAxisFromPlacement';\nimport getAltAxis from '../utils/getAltAxis';\nimport within from '../utils/within';\nimport getLayoutRect from '../dom-utils/getLayoutRect';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport detectOverflow from '../utils/detectOverflow';\nimport getVariation from '../utils/getVariation';\nimport getFreshSideObject from '../utils/getFreshSideObject';\n\ntype TetherOffset = (arg0: { popper: Rect; reference: Rect; placement: Placement }) => number | number;\n\n// eslint-disable-next-line import/no-unused-modules\nexport interface Options {\n  /* Prevents boundaries overflow on the main axis */\n  mainAxis: boolean;\n\n  /* Prevents boundaries overflow on the alternate axis */\n  altAxis: boolean;\n\n  /* The area to check the popper is overflowing in */\n  boundary: Boundary;\n\n  /* If the popper is not overflowing the main area, fallback to this one */\n  rootBoundary: RootBoundary;\n\n  /* Use the reference's \"clippingParents\" boundary context */\n  altBoundary: boolean;\n\n  /**\n   * Allows the popper to overflow from its boundaries to keep it near its\n   * reference element\n   */\n  tether: boolean;\n\n  /* Offsets when the `tether` option should activate */\n  tetherOffset: TetherOffset;\n\n  /* Sets a padding to the provided boundary */\n  padding: Padding;\n}\n\n/**\n *\n */\nfunction preventOverflow({ state, options, name }: ModifierArguments<Options>) {\n  const {\n    mainAxis: checkMainAxis = true,\n    altAxis: checkAltAxis = false,\n    boundary,\n    rootBoundary,\n    altBoundary,\n    padding,\n    tether = true,\n    tetherOffset = 0\n  } = options;\n\n  const overflow = detectOverflow(state, {\n    boundary,\n    rootBoundary,\n    padding,\n    altBoundary\n  });\n  const basePlacement = getBasePlacement(state.placement);\n  const variation = getVariation(state.placement);\n  const isBasePlacement = !variation;\n  const mainAxis = getMainAxisFromPlacement(basePlacement);\n  const altAxis = getAltAxis(mainAxis);\n  const popperOffsets = state.modifiersData.popperOffsets;\n  const referenceRect = state.rects.reference;\n  const popperRect = state.rects.popper;\n  const tetherOffsetValue =\n    typeof tetherOffset === 'function'\n      ? tetherOffset({\n          ...state.rects,\n          placement: state.placement\n        })\n      : tetherOffset;\n\n  const data = { x: 0, y: 0 };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    const mainSide = mainAxis === 'y' ? top : left;\n    const altSide = mainAxis === 'y' ? bottom : right;\n    const len = mainAxis === 'y' ? 'height' : 'width';\n    const offset = popperOffsets[mainAxis];\n\n    const min = popperOffsets[mainAxis] + overflow[mainSide];\n    const max = popperOffsets[mainAxis] - overflow[altSide];\n\n    const additive = tether ? -popperRect[len] / 2 : 0;\n\n    const minLen = variation === start ? referenceRect[len] : popperRect[len];\n    const maxLen = variation === start ? -popperRect[len] : -referenceRect[len];\n\n    // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n    const arrowElement = state.elements.arrow;\n    const arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : { width: 0, height: 0 };\n    const arrowPaddingObject = state.modifiersData['arrow#persistent']\n      ? state.modifiersData['arrow#persistent'].padding\n      : getFreshSideObject();\n    const arrowPaddingMin = arrowPaddingObject[mainSide];\n    const arrowPaddingMax = arrowPaddingObject[altSide];\n\n    // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n    const arrowLen = within(0, referenceRect[len], arrowRect[len]);\n\n    const minOffset = isBasePlacement\n      ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue\n      : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\n    const maxOffset = isBasePlacement\n      ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue\n      : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\n\n    const arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    const clientOffset = arrowOffsetParent\n      ? mainAxis === 'y'\n        ? arrowOffsetParent.clientTop || 0\n        : arrowOffsetParent.clientLeft || 0\n      : 0;\n\n    const offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;\n\n    const tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;\n    const tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;\n\n    const preventedOffset = within(\n      tether ? Math.min(min, tetherMin) : min,\n      offset,\n      tether ? Math.max(max, tetherMax) : max\n    );\n\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    const mainSide = mainAxis === 'x' ? top : left;\n    const altSide = mainAxis === 'x' ? bottom : right;\n    const offset = popperOffsets[altAxis];\n\n    const min = offset + overflow[mainSide];\n    const max = offset - overflow[altSide];\n\n    const preventedOffset = within(min, offset, max);\n\n    popperOffsets[altAxis] = preventedOffset;\n    data[altAxis] = preventedOffset - offset;\n  }\n\n  state.modifiersData[name] = data;\n}\n\n// eslint-disable-next-line import/no-unused-modules\nexport type PreventOverflowModifier = Modifier<'preventOverflow', Options>;\nexport default {\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n} as PreventOverflowModifier;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}