{"ast":null,"code":"import inspect from \"../jsutils/inspect.mjs\";\nimport { isNode } from \"./ast.mjs\";\n/**\n * A visitor is provided to visit, it contains the collection of\n * relevant functions to be called during the visitor's traversal.\n */\n\nexport var QueryDocumentKeys = {\n  Name: [],\n  Document: ['definitions'],\n  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],\n  VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],\n  Variable: ['name'],\n  SelectionSet: ['selections'],\n  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],\n  Argument: ['name', 'value'],\n  FragmentSpread: ['name', 'directives'],\n  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],\n  FragmentDefinition: ['name',\n  // Note: fragment variable definitions are experimental and may be changed\n  // or removed in the future.\n  'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],\n  IntValue: [],\n  FloatValue: [],\n  StringValue: [],\n  BooleanValue: [],\n  NullValue: [],\n  EnumValue: [],\n  ListValue: ['values'],\n  ObjectValue: ['fields'],\n  ObjectField: ['name', 'value'],\n  Directive: ['name', 'arguments'],\n  NamedType: ['name'],\n  ListType: ['type'],\n  NonNullType: ['type'],\n  SchemaDefinition: ['description', 'directives', 'operationTypes'],\n  OperationTypeDefinition: ['type'],\n  ScalarTypeDefinition: ['description', 'name', 'directives'],\n  ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],\n  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],\n  InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],\n  InterfaceTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],\n  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],\n  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],\n  EnumValueDefinition: ['description', 'name', 'directives'],\n  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],\n  SchemaExtension: ['directives', 'operationTypes'],\n  ScalarTypeExtension: ['name', 'directives'],\n  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  InterfaceTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  UnionTypeExtension: ['name', 'directives', 'types'],\n  EnumTypeExtension: ['name', 'directives', 'values'],\n  InputObjectTypeExtension: ['name', 'directives', 'fields']\n};\nexport var BREAK = Object.freeze({});\n/**\n * visit() will walk through an AST using a depth-first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n *     const editedAST = visit(ast, {\n *       enter(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: skip visiting this node\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       },\n *       leave(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: no action\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       }\n *     });\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to four permutations of the\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node of a specific kind.\n *\n *     visit(ast, {\n *       Kind(node) {\n *         // enter the \"Kind\" node\n *       }\n *     })\n *\n * 2) Named visitors that trigger upon entering and leaving a node of\n *    a specific kind.\n *\n *     visit(ast, {\n *       Kind: {\n *         enter(node) {\n *           // enter the \"Kind\" node\n *         }\n *         leave(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n *     visit(ast, {\n *       enter(node) {\n *         // enter any node\n *       },\n *       leave(node) {\n *         // leave any node\n *       }\n *     })\n *\n * 4) Parallel visitors for entering and leaving nodes of a specific kind.\n *\n *     visit(ast, {\n *       enter: {\n *         Kind(node) {\n *           // enter the \"Kind\" node\n *         }\n *       },\n *       leave: {\n *         Kind(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n */\n\nexport function visit(root, visitor) {\n  var visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;\n\n  /* eslint-disable no-undef-init */\n  var stack = undefined;\n  var inArray = Array.isArray(root);\n  var keys = [root];\n  var index = -1;\n  var edits = [];\n  var node = undefined;\n  var key = undefined;\n  var parent = undefined;\n  var path = [];\n  var ancestors = [];\n  var newRoot = root;\n  /* eslint-enable no-undef-init */\n\n  do {\n    index++;\n    var isLeaving = index === keys.length;\n    var isEdited = isLeaving && edits.length !== 0;\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path[path.length - 1];\n      node = parent;\n      parent = ancestors.pop();\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n        } else {\n          var clone = {};\n          for (var _i2 = 0, _Object$keys2 = Object.keys(node); _i2 < _Object$keys2.length; _i2++) {\n            var k = _Object$keys2[_i2];\n            clone[k] = node[k];\n          }\n          node = clone;\n        }\n        var editOffset = 0;\n        for (var ii = 0; ii < edits.length; ii++) {\n          var editKey = edits[ii][0];\n          var editValue = edits[ii][1];\n          if (inArray) {\n            editKey -= editOffset;\n          }\n          if (inArray && editValue === null) {\n            node.splice(editKey, 1);\n            editOffset++;\n          } else {\n            node[editKey] = editValue;\n          }\n        }\n      }\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else {\n      key = parent ? inArray ? index : keys[index] : undefined;\n      node = parent ? parent[key] : newRoot;\n      if (node === null || node === undefined) {\n        continue;\n      }\n      if (parent) {\n        path.push(key);\n      }\n    }\n    var result = void 0;\n    if (!Array.isArray(node)) {\n      if (!isNode(node)) {\n        throw new Error(\"Invalid AST Node: \".concat(inspect(node), \".\"));\n      }\n      var visitFn = getVisitFn(visitor, node.kind, isLeaving);\n      if (visitFn) {\n        result = visitFn.call(visitor, node, key, parent, path, ancestors);\n        if (result === BREAK) {\n          break;\n        }\n        if (result === false) {\n          if (!isLeaving) {\n            path.pop();\n            continue;\n          }\n        } else if (result !== undefined) {\n          edits.push([key, result]);\n          if (!isLeaving) {\n            if (isNode(result)) {\n              node = result;\n            } else {\n              path.pop();\n              continue;\n            }\n          }\n        }\n      }\n    }\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n    if (isLeaving) {\n      path.pop();\n    } else {\n      var _visitorKeys$node$kin;\n      stack = {\n        inArray: inArray,\n        index: index,\n        keys: keys,\n        edits: edits,\n        prev: stack\n      };\n      inArray = Array.isArray(node);\n      keys = inArray ? node : (_visitorKeys$node$kin = visitorKeys[node.kind]) !== null && _visitorKeys$node$kin !== void 0 ? _visitorKeys$node$kin : [];\n      index = -1;\n      edits = [];\n      if (parent) {\n        ancestors.push(parent);\n      }\n      parent = node;\n    }\n  } while (stack !== undefined);\n  if (edits.length !== 0) {\n    newRoot = edits[edits.length - 1][1];\n  }\n  return newRoot;\n}\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n */\n\nexport function visitInParallel(visitors) {\n  var skipping = new Array(visitors.length);\n  return {\n    enter: function enter(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (skipping[i] == null) {\n          var fn = getVisitFn(visitors[i], node.kind, /* isLeaving */\n          false);\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n            if (result === false) {\n              skipping[i] = node;\n            } else if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined) {\n              return result;\n            }\n          }\n        }\n      }\n    },\n    leave: function leave(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (skipping[i] == null) {\n          var fn = getVisitFn(visitors[i], node.kind, /* isLeaving */\n          true);\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n            if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined && result !== false) {\n              return result;\n            }\n          }\n        } else if (skipping[i] === node) {\n          skipping[i] = null;\n        }\n      }\n    }\n  };\n}\n/**\n * Given a visitor instance, if it is leaving or not, and a node kind, return\n * the function the visitor runtime should call.\n */\n\nexport function getVisitFn(visitor, kind, isLeaving) {\n  var kindVisitor = visitor[kind];\n  if (kindVisitor) {\n    if (!isLeaving && typeof kindVisitor === 'function') {\n      // { Kind() {} }\n      return kindVisitor;\n    }\n    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;\n    if (typeof kindSpecificVisitor === 'function') {\n      // { Kind: { enter() {}, leave() {} } }\n      return kindSpecificVisitor;\n    }\n  } else {\n    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;\n    if (specificVisitor) {\n      if (typeof specificVisitor === 'function') {\n        // { enter() {}, leave() {} }\n        return specificVisitor;\n      }\n      var specificKindVisitor = specificVisitor[kind];\n      if (typeof specificKindVisitor === 'function') {\n        // { enter: { Kind() {} }, leave: { Kind() {} } }\n        return specificKindVisitor;\n      }\n    }\n  }\n}","map":{"version":3,"names":["inspect","isNode","QueryDocumentKeys","Name","Document","OperationDefinition","VariableDefinition","Variable","SelectionSet","Field","Argument","FragmentSpread","InlineFragment","FragmentDefinition","IntValue","FloatValue","StringValue","BooleanValue","NullValue","EnumValue","ListValue","ObjectValue","ObjectField","Directive","NamedType","ListType","NonNullType","SchemaDefinition","OperationTypeDefinition","ScalarTypeDefinition","ObjectTypeDefinition","FieldDefinition","InputValueDefinition","InterfaceTypeDefinition","UnionTypeDefinition","EnumTypeDefinition","EnumValueDefinition","InputObjectTypeDefinition","DirectiveDefinition","SchemaExtension","ScalarTypeExtension","ObjectTypeExtension","InterfaceTypeExtension","UnionTypeExtension","EnumTypeExtension","InputObjectTypeExtension","BREAK","Object","freeze","visit","root","visitor","visitorKeys","arguments","length","undefined","stack","inArray","Array","isArray","keys","index","edits","node","key","parent","path","ancestors","newRoot","isLeaving","isEdited","pop","slice","clone","_i2","_Object$keys2","k","editOffset","ii","editKey","editValue","splice","prev","push","result","Error","concat","visitFn","getVisitFn","kind","call","_visitorKeys$node$kin","visitInParallel","visitors","skipping","enter","i","fn","apply","leave","kindVisitor","kindSpecificVisitor","specificVisitor","specificKindVisitor"],"sources":["/data/stackhub-web/plugins/myapps/node_modules/graphql/language/visitor.mjs"],"sourcesContent":["import inspect from \"../jsutils/inspect.mjs\";\nimport { isNode } from \"./ast.mjs\";\n/**\n * A visitor is provided to visit, it contains the collection of\n * relevant functions to be called during the visitor's traversal.\n */\n\nexport var QueryDocumentKeys = {\n  Name: [],\n  Document: ['definitions'],\n  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],\n  VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],\n  Variable: ['name'],\n  SelectionSet: ['selections'],\n  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],\n  Argument: ['name', 'value'],\n  FragmentSpread: ['name', 'directives'],\n  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],\n  FragmentDefinition: ['name', // Note: fragment variable definitions are experimental and may be changed\n  // or removed in the future.\n  'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],\n  IntValue: [],\n  FloatValue: [],\n  StringValue: [],\n  BooleanValue: [],\n  NullValue: [],\n  EnumValue: [],\n  ListValue: ['values'],\n  ObjectValue: ['fields'],\n  ObjectField: ['name', 'value'],\n  Directive: ['name', 'arguments'],\n  NamedType: ['name'],\n  ListType: ['type'],\n  NonNullType: ['type'],\n  SchemaDefinition: ['description', 'directives', 'operationTypes'],\n  OperationTypeDefinition: ['type'],\n  ScalarTypeDefinition: ['description', 'name', 'directives'],\n  ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],\n  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],\n  InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],\n  InterfaceTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],\n  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],\n  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],\n  EnumValueDefinition: ['description', 'name', 'directives'],\n  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],\n  SchemaExtension: ['directives', 'operationTypes'],\n  ScalarTypeExtension: ['name', 'directives'],\n  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  InterfaceTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  UnionTypeExtension: ['name', 'directives', 'types'],\n  EnumTypeExtension: ['name', 'directives', 'values'],\n  InputObjectTypeExtension: ['name', 'directives', 'fields']\n};\nexport var BREAK = Object.freeze({});\n/**\n * visit() will walk through an AST using a depth-first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n *     const editedAST = visit(ast, {\n *       enter(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: skip visiting this node\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       },\n *       leave(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: no action\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       }\n *     });\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to four permutations of the\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node of a specific kind.\n *\n *     visit(ast, {\n *       Kind(node) {\n *         // enter the \"Kind\" node\n *       }\n *     })\n *\n * 2) Named visitors that trigger upon entering and leaving a node of\n *    a specific kind.\n *\n *     visit(ast, {\n *       Kind: {\n *         enter(node) {\n *           // enter the \"Kind\" node\n *         }\n *         leave(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n *     visit(ast, {\n *       enter(node) {\n *         // enter any node\n *       },\n *       leave(node) {\n *         // leave any node\n *       }\n *     })\n *\n * 4) Parallel visitors for entering and leaving nodes of a specific kind.\n *\n *     visit(ast, {\n *       enter: {\n *         Kind(node) {\n *           // enter the \"Kind\" node\n *         }\n *       },\n *       leave: {\n *         Kind(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n */\n\nexport function visit(root, visitor) {\n  var visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;\n\n  /* eslint-disable no-undef-init */\n  var stack = undefined;\n  var inArray = Array.isArray(root);\n  var keys = [root];\n  var index = -1;\n  var edits = [];\n  var node = undefined;\n  var key = undefined;\n  var parent = undefined;\n  var path = [];\n  var ancestors = [];\n  var newRoot = root;\n  /* eslint-enable no-undef-init */\n\n  do {\n    index++;\n    var isLeaving = index === keys.length;\n    var isEdited = isLeaving && edits.length !== 0;\n\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path[path.length - 1];\n      node = parent;\n      parent = ancestors.pop();\n\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n        } else {\n          var clone = {};\n\n          for (var _i2 = 0, _Object$keys2 = Object.keys(node); _i2 < _Object$keys2.length; _i2++) {\n            var k = _Object$keys2[_i2];\n            clone[k] = node[k];\n          }\n\n          node = clone;\n        }\n\n        var editOffset = 0;\n\n        for (var ii = 0; ii < edits.length; ii++) {\n          var editKey = edits[ii][0];\n          var editValue = edits[ii][1];\n\n          if (inArray) {\n            editKey -= editOffset;\n          }\n\n          if (inArray && editValue === null) {\n            node.splice(editKey, 1);\n            editOffset++;\n          } else {\n            node[editKey] = editValue;\n          }\n        }\n      }\n\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else {\n      key = parent ? inArray ? index : keys[index] : undefined;\n      node = parent ? parent[key] : newRoot;\n\n      if (node === null || node === undefined) {\n        continue;\n      }\n\n      if (parent) {\n        path.push(key);\n      }\n    }\n\n    var result = void 0;\n\n    if (!Array.isArray(node)) {\n      if (!isNode(node)) {\n        throw new Error(\"Invalid AST Node: \".concat(inspect(node), \".\"));\n      }\n\n      var visitFn = getVisitFn(visitor, node.kind, isLeaving);\n\n      if (visitFn) {\n        result = visitFn.call(visitor, node, key, parent, path, ancestors);\n\n        if (result === BREAK) {\n          break;\n        }\n\n        if (result === false) {\n          if (!isLeaving) {\n            path.pop();\n            continue;\n          }\n        } else if (result !== undefined) {\n          edits.push([key, result]);\n\n          if (!isLeaving) {\n            if (isNode(result)) {\n              node = result;\n            } else {\n              path.pop();\n              continue;\n            }\n          }\n        }\n      }\n    }\n\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n\n    if (isLeaving) {\n      path.pop();\n    } else {\n      var _visitorKeys$node$kin;\n\n      stack = {\n        inArray: inArray,\n        index: index,\n        keys: keys,\n        edits: edits,\n        prev: stack\n      };\n      inArray = Array.isArray(node);\n      keys = inArray ? node : (_visitorKeys$node$kin = visitorKeys[node.kind]) !== null && _visitorKeys$node$kin !== void 0 ? _visitorKeys$node$kin : [];\n      index = -1;\n      edits = [];\n\n      if (parent) {\n        ancestors.push(parent);\n      }\n\n      parent = node;\n    }\n  } while (stack !== undefined);\n\n  if (edits.length !== 0) {\n    newRoot = edits[edits.length - 1][1];\n  }\n\n  return newRoot;\n}\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n */\n\nexport function visitInParallel(visitors) {\n  var skipping = new Array(visitors.length);\n  return {\n    enter: function enter(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (skipping[i] == null) {\n          var fn = getVisitFn(visitors[i], node.kind,\n          /* isLeaving */\n          false);\n\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n\n            if (result === false) {\n              skipping[i] = node;\n            } else if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined) {\n              return result;\n            }\n          }\n        }\n      }\n    },\n    leave: function leave(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (skipping[i] == null) {\n          var fn = getVisitFn(visitors[i], node.kind,\n          /* isLeaving */\n          true);\n\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n\n            if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined && result !== false) {\n              return result;\n            }\n          }\n        } else if (skipping[i] === node) {\n          skipping[i] = null;\n        }\n      }\n    }\n  };\n}\n/**\n * Given a visitor instance, if it is leaving or not, and a node kind, return\n * the function the visitor runtime should call.\n */\n\nexport function getVisitFn(visitor, kind, isLeaving) {\n  var kindVisitor = visitor[kind];\n\n  if (kindVisitor) {\n    if (!isLeaving && typeof kindVisitor === 'function') {\n      // { Kind() {} }\n      return kindVisitor;\n    }\n\n    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;\n\n    if (typeof kindSpecificVisitor === 'function') {\n      // { Kind: { enter() {}, leave() {} } }\n      return kindSpecificVisitor;\n    }\n  } else {\n    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;\n\n    if (specificVisitor) {\n      if (typeof specificVisitor === 'function') {\n        // { enter() {}, leave() {} }\n        return specificVisitor;\n      }\n\n      var specificKindVisitor = specificVisitor[kind];\n\n      if (typeof specificKindVisitor === 'function') {\n        // { enter: { Kind() {} }, leave: { Kind() {} } }\n        return specificKindVisitor;\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}