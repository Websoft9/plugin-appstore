{"ast":null,"code":"import _toConsumableArray from \"/data/stackhub-web/plugins/myapps/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { viewport } from '../enums';\nimport getViewportRect from './getViewportRect';\nimport getDocumentRect from './getDocumentRect';\nimport listScrollParents from './listScrollParents';\nimport getOffsetParent from './getOffsetParent';\nimport getDocumentElement from './getDocumentElement';\nimport getComputedStyle from './getComputedStyle';\nimport { isElement, isHTMLElement } from './instanceOf';\nimport getBoundingClientRect from './getBoundingClientRect';\nimport getParentNode from './getParentNode';\nimport contains from './contains';\nimport getNodeName from './getNodeName';\nimport rectToClientRect from '../utils/rectToClientRect';\n/**\n * @param element\n */\nfunction getInnerBoundingClientRect(element) {\n  var rect = getBoundingClientRect(element);\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\n/**\n * @param element\n * @param clippingParent\n */\nfunction getClientRectFromMixedType(element, clippingParent) {\n  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n}\n// A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n/**\n * @param element\n */\nfunction getClippingParents(element) {\n  var clippingParents = listScrollParents(getParentNode(element));\n  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n  if (!isElement(clipperElement)) {\n    return [];\n  }\n  // $FlowFixMe: https://github.com/facebook/flow/issues/1414\n  return clippingParents.filter(function (clippingParent) {\n    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\n  });\n}\n// Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n/**\n * @param element\n * @param boundary\n * @param rootBoundary\n */\nexport default function getClippingRect(element, boundary, rootBoundary) {\n  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  var clippingParents = [].concat(_toConsumableArray(mainClippingParents), [rootBoundary]);\n  var firstClippingParent = clippingParents[0];\n  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent);\n    accRect.top = Math.max(rect.top, accRect.top);\n    accRect.right = Math.min(rect.right, accRect.right);\n    accRect.bottom = Math.min(rect.bottom, accRect.bottom);\n    accRect.left = Math.max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}","map":{"version":3,"names":["viewport","getViewportRect","getDocumentRect","listScrollParents","getOffsetParent","getDocumentElement","getComputedStyle","isElement","isHTMLElement","getBoundingClientRect","getParentNode","contains","getNodeName","rectToClientRect","getInnerBoundingClientRect","element","rect","top","clientTop","left","clientLeft","bottom","clientHeight","right","clientWidth","width","height","x","y","getClientRectFromMixedType","clippingParent","getClippingParents","clippingParents","canEscapeClipping","indexOf","position","clipperElement","filter","getClippingRect","boundary","rootBoundary","mainClippingParents","concat","_toConsumableArray","firstClippingParent","clippingRect","reduce","accRect","Math","max","min"],"sources":["/data/stackhub-web/plugins/myapps/node_modules/@patternfly/react-core/src/helpers/Popper/thirdparty/popper-core/dom-utils/getClippingRect.ts"],"sourcesContent":["// @ts-nocheck\nimport { ClientRectObject } from '../types';\nimport { Boundary, RootBoundary } from '../enums';\nimport { viewport } from '../enums';\nimport getViewportRect from './getViewportRect';\nimport getDocumentRect from './getDocumentRect';\nimport listScrollParents from './listScrollParents';\nimport getOffsetParent from './getOffsetParent';\nimport getDocumentElement from './getDocumentElement';\nimport getComputedStyle from './getComputedStyle';\nimport { isElement, isHTMLElement } from './instanceOf';\nimport getBoundingClientRect from './getBoundingClientRect';\nimport getParentNode from './getParentNode';\nimport contains from './contains';\nimport getNodeName from './getNodeName';\nimport rectToClientRect from '../utils/rectToClientRect';\n\n/**\n * @param element\n */\nfunction getInnerBoundingClientRect(element: Element) {\n  const rect = getBoundingClientRect(element);\n\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n\n  return rect;\n}\n\n/**\n * @param element\n * @param clippingParent\n */\nfunction getClientRectFromMixedType(element: Element, clippingParent: Element | RootBoundary): ClientRectObject {\n  return clippingParent === viewport\n    ? rectToClientRect(getViewportRect(element))\n    : isHTMLElement(clippingParent)\n    ? getInnerBoundingClientRect(clippingParent)\n    : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n}\n\n// A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n/**\n * @param element\n */\nfunction getClippingParents(element: Element): Element[] {\n  const clippingParents = listScrollParents(getParentNode(element));\n  const canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  }\n\n  // $FlowFixMe: https://github.com/facebook/flow/issues/1414\n  return clippingParents.filter(\n    clippingParent =>\n      isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body'\n  );\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n/**\n * @param element\n * @param boundary\n * @param rootBoundary\n */\nexport default function getClippingRect(\n  element: Element,\n  boundary: Boundary,\n  rootBoundary: RootBoundary\n): ClientRectObject {\n  const mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  const clippingParents = [...mainClippingParents, rootBoundary];\n  const firstClippingParent = clippingParents[0];\n\n  const clippingRect = clippingParents.reduce((accRect, clippingParent) => {\n    const rect = getClientRectFromMixedType(element, clippingParent);\n\n    accRect.top = Math.max(rect.top, accRect.top);\n    accRect.right = Math.min(rect.right, accRect.right);\n    accRect.bottom = Math.min(rect.bottom, accRect.bottom);\n    accRect.left = Math.max(rect.left, accRect.left);\n\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent));\n\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n\n  return clippingRect;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}