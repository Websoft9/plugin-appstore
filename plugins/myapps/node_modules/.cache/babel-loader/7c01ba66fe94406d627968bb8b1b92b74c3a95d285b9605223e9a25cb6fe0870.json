{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport { visit, BREAK, isSelectionNode } from 'graphql';\nimport { argumentsObjectFromField, buildQueryFromSelectionSet, createFragmentMap, getFragmentDefinitions, getMainDefinition, hasDirectives, isField, isInlineFragment, mergeDeep, mergeDeepArray, removeClientSetsFromDocument, resultKeyNameFromField, shouldInclude } from \"../utilities/index.js\";\nimport { cacheSlot } from \"../cache/index.js\";\nvar LocalState = function () {\n  function LocalState(_a) {\n    var cache = _a.cache,\n      client = _a.client,\n      resolvers = _a.resolvers,\n      fragmentMatcher = _a.fragmentMatcher;\n    this.selectionsToResolveCache = new WeakMap();\n    this.cache = cache;\n    if (client) {\n      this.client = client;\n    }\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n  LocalState.prototype.addResolvers = function (resolvers) {\n    var _this = this;\n    this.resolvers = this.resolvers || {};\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach(function (resolverGroup) {\n        _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = mergeDeep(this.resolvers, resolvers);\n    }\n  };\n  LocalState.prototype.setResolvers = function (resolvers) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  };\n  LocalState.prototype.getResolvers = function () {\n    return this.resolvers || {};\n  };\n  LocalState.prototype.runResolvers = function (_a) {\n    var document = _a.document,\n      remoteResult = _a.remoteResult,\n      context = _a.context,\n      variables = _a.variables,\n      _b = _a.onlyRunForcedResolvers,\n      onlyRunForcedResolvers = _b === void 0 ? false : _b;\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_c) {\n        if (document) {\n          return [2, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function (localResult) {\n            return __assign(__assign({}, remoteResult), {\n              data: localResult.result\n            });\n          })];\n        }\n        return [2, remoteResult];\n      });\n    });\n  };\n  LocalState.prototype.setFragmentMatcher = function (fragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  };\n  LocalState.prototype.getFragmentMatcher = function () {\n    return this.fragmentMatcher;\n  };\n  LocalState.prototype.clientQuery = function (document) {\n    if (hasDirectives(['client'], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n    }\n    return null;\n  };\n  LocalState.prototype.serverQuery = function (document) {\n    return removeClientSetsFromDocument(document);\n  };\n  LocalState.prototype.prepareContext = function (context) {\n    var cache = this.cache;\n    return __assign(__assign({}, context), {\n      cache: cache,\n      getCacheKey: function getCacheKey(obj) {\n        return cache.identify(obj);\n      }\n    });\n  };\n  LocalState.prototype.addExportedVariables = function (document, variables, context) {\n    if (variables === void 0) {\n      variables = {};\n    }\n    if (context === void 0) {\n      context = {};\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        if (document) {\n          return [2, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function (data) {\n            return __assign(__assign({}, variables), data.exportedVariables);\n          })];\n        }\n        return [2, __assign({}, variables)];\n      });\n    });\n  };\n  LocalState.prototype.shouldForceResolvers = function (document) {\n    var forceResolvers = false;\n    visit(document, {\n      Directive: {\n        enter: function enter(node) {\n          if (node.name.value === 'client' && node.arguments) {\n            forceResolvers = node.arguments.some(function (arg) {\n              return arg.name.value === 'always' && arg.value.kind === 'BooleanValue' && arg.value.value === true;\n            });\n            if (forceResolvers) {\n              return BREAK;\n            }\n          }\n        }\n      }\n    });\n    return forceResolvers;\n  };\n  LocalState.prototype.buildRootValueFromCache = function (document, variables) {\n    return this.cache.diff({\n      query: buildQueryFromSelectionSet(document),\n      variables: variables,\n      returnPartialData: true,\n      optimistic: false\n    }).result;\n  };\n  LocalState.prototype.resolveDocument = function (document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {\n    if (context === void 0) {\n      context = {};\n    }\n    if (variables === void 0) {\n      variables = {};\n    }\n    if (fragmentMatcher === void 0) {\n      fragmentMatcher = function fragmentMatcher() {\n        return true;\n      };\n    }\n    if (onlyRunForcedResolvers === void 0) {\n      onlyRunForcedResolvers = false;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var mainDefinition, fragments, fragmentMap, selectionsToResolve, definitionOperation, defaultOperationType, _a, cache, client, execContext, isClientFieldDescendant;\n      return __generator(this, function (_b) {\n        mainDefinition = getMainDefinition(document);\n        fragments = getFragmentDefinitions(document);\n        fragmentMap = createFragmentMap(fragments);\n        selectionsToResolve = this.collectSelectionsToResolve(mainDefinition, fragmentMap);\n        definitionOperation = mainDefinition.operation;\n        defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : 'Query';\n        _a = this, cache = _a.cache, client = _a.client;\n        execContext = {\n          fragmentMap: fragmentMap,\n          context: __assign(__assign({}, context), {\n            cache: cache,\n            client: client\n          }),\n          variables: variables,\n          fragmentMatcher: fragmentMatcher,\n          defaultOperationType: defaultOperationType,\n          exportedVariables: {},\n          selectionsToResolve: selectionsToResolve,\n          onlyRunForcedResolvers: onlyRunForcedResolvers\n        };\n        isClientFieldDescendant = false;\n        return [2, this.resolveSelectionSet(mainDefinition.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function (result) {\n          return {\n            result: result,\n            exportedVariables: execContext.exportedVariables\n          };\n        })];\n      });\n    });\n  };\n  LocalState.prototype.resolveSelectionSet = function (selectionSet, isClientFieldDescendant, rootValue, execContext) {\n    return __awaiter(this, void 0, void 0, function () {\n      var fragmentMap, context, variables, resultsToMerge, execute;\n      var _this = this;\n      return __generator(this, function (_a) {\n        fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;\n        resultsToMerge = [rootValue];\n        execute = function execute(selection) {\n          return __awaiter(_this, void 0, void 0, function () {\n            var fragment, typeCondition;\n            return __generator(this, function (_a) {\n              if (!isClientFieldDescendant && !execContext.selectionsToResolve.has(selection)) {\n                return [2];\n              }\n              if (!shouldInclude(selection, variables)) {\n                return [2];\n              }\n              if (isField(selection)) {\n                return [2, this.resolveField(selection, isClientFieldDescendant, rootValue, execContext).then(function (fieldResult) {\n                  var _a;\n                  if (typeof fieldResult !== 'undefined') {\n                    resultsToMerge.push((_a = {}, _a[resultKeyNameFromField(selection)] = fieldResult, _a));\n                  }\n                })];\n              }\n              if (isInlineFragment(selection)) {\n                fragment = selection;\n              } else {\n                fragment = fragmentMap[selection.name.value];\n                __DEV__ ? invariant(fragment, \"No fragment named \".concat(selection.name.value)) : invariant(fragment, 11);\n              }\n              if (fragment && fragment.typeCondition) {\n                typeCondition = fragment.typeCondition.name.value;\n                if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n                  return [2, this.resolveSelectionSet(fragment.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function (fragmentResult) {\n                    resultsToMerge.push(fragmentResult);\n                  })];\n                }\n              }\n              return [2];\n            });\n          });\n        };\n        return [2, Promise.all(selectionSet.selections.map(execute)).then(function () {\n          return mergeDeepArray(resultsToMerge);\n        })];\n      });\n    });\n  };\n  LocalState.prototype.resolveField = function (field, isClientFieldDescendant, rootValue, execContext) {\n    return __awaiter(this, void 0, void 0, function () {\n      var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;\n      var _this = this;\n      return __generator(this, function (_a) {\n        if (!rootValue) {\n          return [2, null];\n        }\n        variables = execContext.variables;\n        fieldName = field.name.value;\n        aliasedFieldName = resultKeyNameFromField(field);\n        aliasUsed = fieldName !== aliasedFieldName;\n        defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n        resultPromise = Promise.resolve(defaultResult);\n        if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {\n          resolverType = rootValue.__typename || execContext.defaultOperationType;\n          resolverMap = this.resolvers && this.resolvers[resolverType];\n          if (resolverMap) {\n            resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n            if (resolve) {\n              resultPromise = Promise.resolve(cacheSlot.withValue(this.cache, resolve, [rootValue, argumentsObjectFromField(field, variables), execContext.context, {\n                field: field,\n                fragmentMap: execContext.fragmentMap\n              }]));\n            }\n          }\n        }\n        return [2, resultPromise.then(function (result) {\n          var _a, _b;\n          if (result === void 0) {\n            result = defaultResult;\n          }\n          if (field.directives) {\n            field.directives.forEach(function (directive) {\n              if (directive.name.value === 'export' && directive.arguments) {\n                directive.arguments.forEach(function (arg) {\n                  if (arg.name.value === 'as' && arg.value.kind === 'StringValue') {\n                    execContext.exportedVariables[arg.value.value] = result;\n                  }\n                });\n              }\n            });\n          }\n          if (!field.selectionSet) {\n            return result;\n          }\n          if (result == null) {\n            return result;\n          }\n          var isClientField = (_b = (_a = field.directives) === null || _a === void 0 ? void 0 : _a.some(function (d) {\n            return d.name.value === 'client';\n          })) !== null && _b !== void 0 ? _b : false;\n          if (Array.isArray(result)) {\n            return _this.resolveSubSelectedArray(field, isClientFieldDescendant || isClientField, result, execContext);\n          }\n          if (field.selectionSet) {\n            return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant || isClientField, result, execContext);\n          }\n        })];\n      });\n    });\n  };\n  LocalState.prototype.resolveSubSelectedArray = function (field, isClientFieldDescendant, result, execContext) {\n    var _this = this;\n    return Promise.all(result.map(function (item) {\n      if (item === null) {\n        return null;\n      }\n      if (Array.isArray(item)) {\n        return _this.resolveSubSelectedArray(field, isClientFieldDescendant, item, execContext);\n      }\n      if (field.selectionSet) {\n        return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant, item, execContext);\n      }\n    }));\n  };\n  LocalState.prototype.collectSelectionsToResolve = function (mainDefinition, fragmentMap) {\n    var isSingleASTNode = function isSingleASTNode(node) {\n      return !Array.isArray(node);\n    };\n    var selectionsToResolveCache = this.selectionsToResolveCache;\n    function collectByDefinition(definitionNode) {\n      if (!selectionsToResolveCache.has(definitionNode)) {\n        var matches_1 = new Set();\n        selectionsToResolveCache.set(definitionNode, matches_1);\n        visit(definitionNode, {\n          Directive: function Directive(node, _, __, ___, ancestors) {\n            if (node.name.value === 'client') {\n              ancestors.forEach(function (node) {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches_1.add(node);\n                }\n              });\n            }\n          },\n          FragmentSpread: function FragmentSpread(spread, _, __, ___, ancestors) {\n            var fragment = fragmentMap[spread.name.value];\n            __DEV__ ? invariant(fragment, \"No fragment named \".concat(spread.name.value)) : invariant(fragment, 12);\n            var fragmentSelections = collectByDefinition(fragment);\n            if (fragmentSelections.size > 0) {\n              ancestors.forEach(function (node) {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches_1.add(node);\n                }\n              });\n              matches_1.add(spread);\n              fragmentSelections.forEach(function (selection) {\n                matches_1.add(selection);\n              });\n            }\n          }\n        });\n      }\n      return selectionsToResolveCache.get(definitionNode);\n    }\n    return collectByDefinition(mainDefinition);\n  };\n  return LocalState;\n}();\nexport { LocalState };","map":{"version":3,"names":["invariant","visit","BREAK","isSelectionNode","argumentsObjectFromField","buildQueryFromSelectionSet","createFragmentMap","getFragmentDefinitions","getMainDefinition","hasDirectives","isField","isInlineFragment","mergeDeep","mergeDeepArray","removeClientSetsFromDocument","resultKeyNameFromField","shouldInclude","cacheSlot","LocalState","_a","cache","client","resolvers","fragmentMatcher","selectionsToResolveCache","WeakMap","addResolvers","setFragmentMatcher","prototype","_this","Array","isArray","forEach","resolverGroup","setResolvers","getResolvers","runResolvers","document","remoteResult","context","variables","_b","onlyRunForcedResolvers","resolveDocument","data","then","localResult","__assign","result","getFragmentMatcher","clientQuery","serverQuery","prepareContext","getCacheKey","obj","identify","addExportedVariables","buildRootValueFromCache","exportedVariables","shouldForceResolvers","forceResolvers","Directive","enter","node","name","value","arguments","some","arg","kind","diff","query","returnPartialData","optimistic","rootValue","mainDefinition","fragments","fragmentMap","selectionsToResolve","collectSelectionsToResolve","definitionOperation","operation","defaultOperationType","charAt","toUpperCase","slice","execContext","isClientFieldDescendant","resolveSelectionSet","selectionSet","resultsToMerge","execute","selection","__awaiter","has","resolveField","fieldResult","push","fragment","__DEV__","concat","typeCondition","fragmentResult","Promise","all","selections","map","field","fieldName","aliasedFieldName","aliasUsed","defaultResult","resultPromise","resolve","resolverType","__typename","resolverMap","withValue","directives","directive","isClientField","d","resolveSubSelectedArray","item","isSingleASTNode","collectByDefinition","definitionNode","matches_1","Set","set","_","__","___","ancestors","add","FragmentSpread","spread","fragmentSelections","size","get"],"sources":["/data/stackhub-web/plugins/myapps/node_modules/@apollo/src/core/LocalState.ts"],"sourcesContent":["import { invariant } from '../utilities/globals';\n\nimport {\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  SelectionNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  FieldNode,\n  ASTNode,\n  visit,\n  BREAK,\n  isSelectionNode,\n  DirectiveNode,\n  FragmentSpreadNode,\n  ExecutableDefinitionNode,\n} from 'graphql';\n\nimport { ApolloCache } from '../cache';\nimport {\n  FragmentMap,\n  StoreObject,\n  argumentsObjectFromField,\n  buildQueryFromSelectionSet,\n  createFragmentMap,\n  getFragmentDefinitions,\n  getMainDefinition,\n  hasDirectives,\n  isField,\n  isInlineFragment,\n  mergeDeep,\n  mergeDeepArray,\n  removeClientSetsFromDocument,\n  resultKeyNameFromField,\n  shouldInclude,\n} from '../utilities';\nimport { ApolloClient } from './ApolloClient';\nimport { Resolvers, OperationVariables } from './types';\nimport { FetchResult } from '../link/core';\nimport { cacheSlot } from '../cache';\n\nexport type Resolver = (\n  rootValue?: any,\n  args?: any,\n  context?: any,\n  info?: {\n    field: FieldNode;\n    fragmentMap: FragmentMap;\n  },\n) => any;\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: any,\n) => boolean;\n\nexport type ExecContext = {\n  fragmentMap: FragmentMap;\n  context: any;\n  variables: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n  defaultOperationType: string;\n  exportedVariables: Record<string, any>;\n  onlyRunForcedResolvers: boolean;\n  selectionsToResolve: Set<SelectionNode>;\n};\n\nexport type LocalStateOptions<TCacheShape> = {\n  cache: ApolloCache<TCacheShape>;\n  client?: ApolloClient<TCacheShape>;\n  resolvers?: Resolvers | Resolvers[];\n  fragmentMatcher?: FragmentMatcher;\n};\n\nexport class LocalState<TCacheShape> {\n  private cache: ApolloCache<TCacheShape>;\n  private client: ApolloClient<TCacheShape>;\n  private resolvers?: Resolvers;\n  private fragmentMatcher: FragmentMatcher;\n  private selectionsToResolveCache = new WeakMap<ExecutableDefinitionNode, Set<SelectionNode>>()\n\n  constructor({\n    cache,\n    client,\n    resolvers,\n    fragmentMatcher,\n  }: LocalStateOptions<TCacheShape>) {\n    this.cache = cache;\n\n    if (client) {\n      this.client = client;\n    }\n\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = this.resolvers || {};\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach(resolverGroup => {\n        this.resolvers = mergeDeep(this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = mergeDeep(this.resolvers, resolvers);\n    }\n  }\n\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  }\n\n  public getResolvers() {\n    return this.resolvers || {};\n  }\n\n  // Run local client resolvers against the incoming query and remote data.\n  // Locally resolved field values are merged with the incoming remote data,\n  // and returned. Note that locally resolved fields will overwrite\n  // remote data using the same field name.\n  public async runResolvers<TData>({\n    document,\n    remoteResult,\n    context,\n    variables,\n    onlyRunForcedResolvers = false,\n  }: {\n    document: DocumentNode | null;\n    remoteResult: FetchResult<TData>;\n    context?: Record<string, any>;\n    variables?: Record<string, any>;\n    onlyRunForcedResolvers?: boolean;\n  }): Promise<FetchResult<TData>> {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        remoteResult.data,\n        context,\n        variables,\n        this.fragmentMatcher,\n        onlyRunForcedResolvers,\n      ).then(localResult => ({\n        ...remoteResult,\n        data: localResult.result,\n      }));\n    }\n\n    return remoteResult;\n  }\n\n  public setFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  }\n\n  public getFragmentMatcher(): FragmentMatcher {\n    return this.fragmentMatcher;\n  }\n\n  // Client queries contain everything in the incoming document (if a @client\n  // directive is found).\n  public clientQuery(document: DocumentNode) {\n    if (hasDirectives(['client'], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n    }\n    return null;\n  }\n\n  // Server queries are stripped of all @client based selection sets.\n  public serverQuery(document: DocumentNode) {\n    return removeClientSetsFromDocument(document);\n  }\n\n  public prepareContext(context?: Record<string, any>) {\n    const { cache } = this;\n    return {\n      ...context,\n      cache,\n      // Getting an entry's cache key is useful for local state resolvers.\n      getCacheKey(obj: StoreObject) {\n        return cache.identify(obj);\n      },\n    };\n  }\n\n  // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n  // @client @export fields locally, then pass the resolved values back to be\n  // used alongside the original operation variables.\n  public async addExportedVariables(\n    document: DocumentNode,\n    variables: OperationVariables = {},\n    context = {},\n  ) {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        this.buildRootValueFromCache(document, variables) || {},\n        this.prepareContext(context),\n        variables,\n      ).then(data => ({\n        ...variables,\n        ...data.exportedVariables,\n      }));\n    }\n\n    return {\n      ...variables,\n    };\n  }\n\n  public shouldForceResolvers(document: ASTNode) {\n    let forceResolvers = false;\n    visit(document, {\n      Directive: {\n        enter(node) {\n          if (node.name.value === 'client' && node.arguments) {\n            forceResolvers = node.arguments.some(\n              arg =>\n                arg.name.value === 'always' &&\n                arg.value.kind === 'BooleanValue' &&\n                arg.value.value === true,\n            );\n            if (forceResolvers) {\n              return BREAK;\n            }\n          }\n        },\n      },\n    });\n    return forceResolvers;\n  }\n\n  // Query the cache and return matching data.\n  private buildRootValueFromCache(\n    document: DocumentNode,\n    variables?: Record<string, any>,\n  ) {\n    return this.cache.diff({\n      query: buildQueryFromSelectionSet(document),\n      variables,\n      returnPartialData: true,\n      optimistic: false,\n    }).result;\n  }\n\n  private async resolveDocument<TData>(\n    document: DocumentNode,\n    rootValue: TData,\n    context: any = {},\n    variables: VariableMap = {},\n    fragmentMatcher: FragmentMatcher = () => true,\n    onlyRunForcedResolvers: boolean = false,\n  ) {\n    const mainDefinition = getMainDefinition(document) as OperationDefinitionNode;\n    const fragments = getFragmentDefinitions(document);\n    const fragmentMap = createFragmentMap(fragments);\n    const selectionsToResolve = this.collectSelectionsToResolve(mainDefinition, fragmentMap);\n\n    const definitionOperation = mainDefinition.operation;\n\n    const defaultOperationType = definitionOperation\n      ? definitionOperation.charAt(0).toUpperCase() +\n        definitionOperation.slice(1)\n      : 'Query';\n\n    const { cache, client } = this;\n    const execContext: ExecContext = {\n      fragmentMap,\n      context: {\n        ...context,\n        cache,\n        client,\n      },\n      variables,\n      fragmentMatcher,\n      defaultOperationType,\n      exportedVariables: {},\n      selectionsToResolve,\n      onlyRunForcedResolvers,\n    };\n    const isClientFieldDescendant = false;\n\n    return this.resolveSelectionSet(\n      mainDefinition.selectionSet,\n      isClientFieldDescendant,\n      rootValue,\n      execContext,\n    ).then(result => ({\n      result,\n      exportedVariables: execContext.exportedVariables,\n    }));\n  }\n\n  private async resolveSelectionSet<TData>(\n    selectionSet: SelectionSetNode,\n    isClientFieldDescendant: boolean,\n    rootValue: TData,\n    execContext: ExecContext,\n  ) {\n    const { fragmentMap, context, variables } = execContext;\n    const resultsToMerge: TData[] = [rootValue];\n\n    const execute = async (selection: SelectionNode): Promise<void> => {\n      if (!isClientFieldDescendant && !execContext.selectionsToResolve.has(selection)) {\n        // Skip selections without @client directives\n        // (still processing if one of the ancestors or one of the child fields has @client directive)\n        return ;\n      }\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely.\n        return;\n      }\n\n      if (isField(selection)) {\n        return this.resolveField(selection, isClientFieldDescendant, rootValue, execContext).then(\n          fieldResult => {\n            if (typeof fieldResult !== 'undefined') {\n              resultsToMerge.push({\n                [resultKeyNameFromField(selection)]: fieldResult,\n              } as TData);\n            }\n          },\n        );\n      }\n\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // This is a named fragment.\n        fragment = fragmentMap[selection.name.value];\n        invariant(fragment, `No fragment named ${selection.name.value}`);\n      }\n\n      if (fragment && fragment.typeCondition) {\n        const typeCondition = fragment.typeCondition.name.value;\n        if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n          return this.resolveSelectionSet(\n            fragment.selectionSet,\n            isClientFieldDescendant,\n            rootValue,\n            execContext,\n          ).then(fragmentResult => {\n            resultsToMerge.push(fragmentResult);\n          });\n        }\n      }\n    };\n\n    return Promise.all(selectionSet.selections.map(execute)).then(function() {\n      return mergeDeepArray(resultsToMerge);\n    });\n  }\n\n  private async resolveField(\n    field: FieldNode,\n    isClientFieldDescendant: boolean,\n    rootValue: any,\n    execContext: ExecContext,\n  ): Promise<any> {\n    if (!rootValue) {\n      return null;\n    }\n\n    const { variables } = execContext;\n    const fieldName = field.name.value;\n    const aliasedFieldName = resultKeyNameFromField(field);\n    const aliasUsed = fieldName !== aliasedFieldName;\n    const defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n    let resultPromise = Promise.resolve(defaultResult);\n\n    // Usually all local resolvers are run when passing through here, but\n    // if we've specifically identified that we only want to run forced\n    // resolvers (that is, resolvers for fields marked with\n    // `@client(always: true)`), then we'll skip running non-forced resolvers.\n    if (\n      !execContext.onlyRunForcedResolvers ||\n      this.shouldForceResolvers(field)\n    ) {\n      const resolverType =\n        rootValue.__typename || execContext.defaultOperationType;\n      const resolverMap = this.resolvers && this.resolvers[resolverType];\n      if (resolverMap) {\n        const resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n        if (resolve) {\n          resultPromise = Promise.resolve(\n            // In case the resolve function accesses reactive variables,\n            // set cacheSlot to the current cache instance.\n            cacheSlot.withValue(this.cache, resolve, [\n              rootValue,\n              argumentsObjectFromField(field, variables),\n              execContext.context,\n              { field, fragmentMap: execContext.fragmentMap },\n            ])\n          );\n        }\n      }\n    }\n\n    return resultPromise.then((result = defaultResult) => {\n      // If an @export directive is associated with the current field, store\n      // the `as` export variable name and current result for later use.\n      if (field.directives) {\n        field.directives.forEach(directive => {\n          if (directive.name.value === 'export' && directive.arguments) {\n            directive.arguments.forEach(arg => {\n              if (arg.name.value === 'as' && arg.value.kind === 'StringValue') {\n                execContext.exportedVariables[arg.value.value] = result;\n              }\n            });\n          }\n        });\n      }\n\n      // Handle all scalar types here.\n      if (!field.selectionSet) {\n        return result;\n      }\n\n      // From here down, the field has a selection set, which means it's trying\n      // to query a GraphQLObjectType.\n      if (result == null) {\n        // Basically any field in a GraphQL response can be null, or missing\n        return result;\n      }\n\n      const isClientField = field.directives?.some(d => d.name.value === 'client') ?? false\n\n      if (Array.isArray(result)) {\n        return this.resolveSubSelectedArray(field, isClientFieldDescendant || isClientField, result, execContext);\n      }\n\n      // Returned value is an object, and the query has a sub-selection. Recurse.\n      if (field.selectionSet) {\n        return this.resolveSelectionSet(\n          field.selectionSet,\n          isClientFieldDescendant || isClientField,\n          result,\n          execContext,\n        );\n      }\n    });\n  }\n\n  private resolveSubSelectedArray(\n    field: FieldNode,\n    isClientFieldDescendant: boolean,\n    result: any[],\n    execContext: ExecContext,\n  ): any {\n    return Promise.all(\n      result.map(item => {\n        if (item === null) {\n          return null;\n        }\n\n        // This is a nested array, recurse.\n        if (Array.isArray(item)) {\n          return this.resolveSubSelectedArray(field, isClientFieldDescendant, item, execContext);\n        }\n\n        // This is an object, run the selection set on it.\n        if (field.selectionSet) {\n          return this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant, item, execContext);\n        }\n      }),\n    );\n  }\n\n  // Collect selection nodes on paths from document root down to all @client directives.\n  // This function takes into account transitive fragment spreads.\n  // Complexity equals to a single `visit` over the full document.\n  private collectSelectionsToResolve(\n    mainDefinition: OperationDefinitionNode,\n    fragmentMap: FragmentMap\n  ): Set<SelectionNode> {\n    const isSingleASTNode = (node: ASTNode | readonly ASTNode[]): node is ASTNode => !Array.isArray(node);\n    const selectionsToResolveCache = this.selectionsToResolveCache;\n\n    function collectByDefinition(definitionNode: ExecutableDefinitionNode): Set<SelectionNode> {\n      if (!selectionsToResolveCache.has(definitionNode)) {\n        const matches = new Set<SelectionNode>();\n        selectionsToResolveCache.set(definitionNode, matches);\n\n        visit(definitionNode, {\n          Directive(node: DirectiveNode, _, __, ___, ancestors) {\n            if (node.name.value === 'client') {\n              ancestors.forEach(node => {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches.add(node);\n                }\n              })\n            }\n          },\n          FragmentSpread(spread: FragmentSpreadNode, _, __, ___, ancestors) {\n            const fragment = fragmentMap[spread.name.value];\n            invariant(fragment, `No fragment named ${spread.name.value}`);\n\n            const fragmentSelections = collectByDefinition(fragment);\n            if (fragmentSelections.size > 0) {\n              // Fragment for this spread contains @client directive (either directly or transitively)\n              // Collect selection nodes on paths from the root down to fields with the @client directive\n              ancestors.forEach(node => {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches.add(node);\n                }\n              })\n              matches.add(spread);\n              fragmentSelections.forEach(selection => {\n                matches.add(selection);\n              })\n            }\n          }\n        })\n      }\n      return selectionsToResolveCache.get(definitionNode)!;\n    }\n    return collectByDefinition(mainDefinition);\n  }\n}\n"],"mappings":";AAAA,SAASA,SAAS,QAAQ,+BAAuB;AAEjD,SASEC,KAAK,EACLC,KAAK,EACLC,eAAe,QAIV,SAAS;AAGhB,SAGEC,wBAAwB,EACxBC,0BAA0B,EAC1BC,iBAAiB,EACjBC,sBAAsB,EACtBC,iBAAiB,EACjBC,aAAa,EACbC,OAAO,EACPC,gBAAgB,EAChBC,SAAS,EACTC,cAAc,EACdC,4BAA4B,EAC5BC,sBAAsB,EACtBC,aAAa,QACR,uBAAe;AAItB,SAASC,SAAS,QAAQ,mBAAW;AAsCrC,IAAAC,UAAA;EAOE,SAAAA,WAAYC,EAKqB;QAJ/BC,KAAK,GAAAD,EAAA,CAAAC,KAAA;MACLC,MAAM,GAAAF,EAAA,CAAAE,MAAA;MACNC,SAAS,GAAAH,EAAA,CAAAG,SAAA;MACTC,eAAe,GAAAJ,EAAA,CAAAI,eAAA;IANT,KAAAC,wBAAwB,GAAG,IAAIC,OAAO,EAAgD;IAQ5F,IAAI,CAACL,KAAK,GAAGA,KAAK;IAElB,IAAIC,MAAM,EAAE;MACV,IAAI,CAACA,MAAM,GAAGA,MAAM;;IAGtB,IAAIC,SAAS,EAAE;MACb,IAAI,CAACI,YAAY,CAACJ,SAAS,CAAC;;IAG9B,IAAIC,eAAe,EAAE;MACnB,IAAI,CAACI,kBAAkB,CAACJ,eAAe,CAAC;;EAE5C;EAEOL,UAAA,CAAAU,SAAA,CAAAF,YAAY,GAAnB,UAAoBJ,SAAkC;IAAtD,IAAAO,KAAA;IACE,IAAI,CAACP,SAAS,GAAG,IAAI,CAACA,SAAS,IAAI,EAAE;IACrC,IAAIQ,KAAK,CAACC,OAAO,CAACT,SAAS,CAAC,EAAE;MAC5BA,SAAS,CAACU,OAAO,CAAC,UAAAC,aAAa;QAC7BJ,KAAI,CAACP,SAAS,GAAGV,SAAS,CAACiB,KAAI,CAACP,SAAS,EAAEW,aAAa,CAAC;MAC3D,CAAC,CAAC;KACH,MAAM;MACL,IAAI,CAACX,SAAS,GAAGV,SAAS,CAAC,IAAI,CAACU,SAAS,EAAEA,SAAS,CAAC;;EAEzD,CAAC;EAEMJ,UAAA,CAAAU,SAAA,CAAAM,YAAY,GAAnB,UAAoBZ,SAAkC;IACpD,IAAI,CAACA,SAAS,GAAG,EAAE;IACnB,IAAI,CAACI,YAAY,CAACJ,SAAS,CAAC;EAC9B,CAAC;EAEMJ,UAAA,CAAAU,SAAA,CAAAO,YAAY,GAAnB;IACE,OAAO,IAAI,CAACb,SAAS,IAAI,EAAE;EAC7B,CAAC;EAMYJ,UAAA,CAAAU,SAAA,CAAAQ,YAAY,GAAzB,UAAiCjB,EAYhC;QAXCkB,QAAQ,GAAAlB,EAAA,CAAAkB,QAAA;MACRC,YAAY,GAAAnB,EAAA,CAAAmB,YAAA;MACZC,OAAO,GAAApB,EAAA,CAAAoB,OAAA;MACPC,SAAS,GAAArB,EAAA,CAAAqB,SAAA;MACTC,EAAA,GAAAtB,EAAA,CAAAuB,sBAA8B;MAA9BA,sBAAsB,GAAAD,EAAA,cAAG,KAAK,GAAAA,EAAA;;;QAQ9B,IAAIJ,QAAQ,EAAE;UACZ,WAAO,IAAI,CAACM,eAAe,CACzBN,QAAQ,EACRC,YAAY,CAACM,IAAI,EACjBL,OAAO,EACPC,SAAS,EACT,IAAI,CAACjB,eAAe,EACpBmB,sBAAsB,CACvB,CAACG,IAAI,CAAC,UAAAC,WAAW;YAAI,OAAAC,QAAA,CAAAA,QAAA,KACjBT,YAAY;cACfM,IAAI,EAAEE,WAAW,CAACE;YAAM;UAFJ,CAGpB,CAAC;;QAGL,WAAOV,YAAY;;;GACpB;EAEMpB,UAAA,CAAAU,SAAA,CAAAD,kBAAkB,GAAzB,UAA0BJ,eAAgC;IACxD,IAAI,CAACA,eAAe,GAAGA,eAAe;EACxC,CAAC;EAEML,UAAA,CAAAU,SAAA,CAAAqB,kBAAkB,GAAzB;IACE,OAAO,IAAI,CAAC1B,eAAe;EAC7B,CAAC;EAIML,UAAA,CAAAU,SAAA,CAAAsB,WAAW,GAAlB,UAAmBb,QAAsB;IACvC,IAAI5B,aAAa,CAAC,CAAC,QAAQ,CAAC,EAAE4B,QAAQ,CAAC,EAAE;MACvC,IAAI,IAAI,CAACf,SAAS,EAAE;QAClB,OAAOe,QAAQ;;;IAGnB,OAAO,IAAI;EACb,CAAC;EAGMnB,UAAA,CAAAU,SAAA,CAAAuB,WAAW,GAAlB,UAAmBd,QAAsB;IACvC,OAAOvB,4BAA4B,CAACuB,QAAQ,CAAC;EAC/C,CAAC;EAEMnB,UAAA,CAAAU,SAAA,CAAAwB,cAAc,GAArB,UAAsBb,OAA6B;IACzC,IAAAnB,KAAK,GAAK,IAAI,CAAAA,KAAT;IACb,OAAA2B,QAAA,CAAAA,QAAA,KACKR,OAAO;MACVnB,KAAK,EAAAA,KAAA;MAELiC,WAAW,WAAAA,YAACC,GAAgB;QAC1B,OAAOlC,KAAK,CAACmC,QAAQ,CAACD,GAAG,CAAC;MAC5B;IAAC;EAEL,CAAC;EAKYpC,UAAA,CAAAU,SAAA,CAAA4B,oBAAoB,GAAjC,UACEnB,QAAsB,EACtBG,SAAkC,EAClCD,OAAY;IADZ,IAAAC,SAAA;MAAAA,SAAA,KAAkC;IAAA;IAClC,IAAAD,OAAA;MAAAA,OAAA,KAAY;IAAA;;;QAEZ,IAAIF,QAAQ,EAAE;UACZ,WAAO,IAAI,CAACM,eAAe,CACzBN,QAAQ,EACR,IAAI,CAACoB,uBAAuB,CAACpB,QAAQ,EAAEG,SAAS,CAAC,IAAI,EAAE,EACvD,IAAI,CAACY,cAAc,CAACb,OAAO,CAAC,EAC5BC,SAAS,CACV,CAACK,IAAI,CAAC,UAAAD,IAAI;YAAI,OAAAG,QAAA,CAAAA,QAAA,KACVP,SAAS,GACTI,IAAI,CAACc,iBAAiB;UAFZ,CAGb,CAAC;;QAGL,WAAAX,QAAA,KACKP,SAAS;;;GAEf;EAEMtB,UAAA,CAAAU,SAAA,CAAA+B,oBAAoB,GAA3B,UAA4BtB,QAAiB;IAC3C,IAAIuB,cAAc,GAAG,KAAK;IAC1B3D,KAAK,CAACoC,QAAQ,EAAE;MACdwB,SAAS,EAAE;QACTC,KAAK,WAAAA,MAACC,IAAI;UACR,IAAIA,IAAI,CAACC,IAAI,CAACC,KAAK,KAAK,QAAQ,IAAIF,IAAI,CAACG,SAAS,EAAE;YAClDN,cAAc,GAAGG,IAAI,CAACG,SAAS,CAACC,IAAI,CAClC,UAAAC,GAAG;cACD,OAAAA,GAAG,CAACJ,IAAI,CAACC,KAAK,KAAK,QAAQ,IAC3BG,GAAG,CAACH,KAAK,CAACI,IAAI,KAAK,cAAc,IACjCD,GAAG,CAACH,KAAK,CAACA,KAAK,KAAK,IAAI;YAFxB,CAEwB,CAC3B;YACD,IAAIL,cAAc,EAAE;cAClB,OAAO1D,KAAK;;;QAGlB;;KAEH,CAAC;IACF,OAAO0D,cAAc;EACvB,CAAC;EAGO1C,UAAA,CAAAU,SAAA,CAAA6B,uBAAuB,GAA/B,UACEpB,QAAsB,EACtBG,SAA+B;IAE/B,OAAO,IAAI,CAACpB,KAAK,CAACkD,IAAI,CAAC;MACrBC,KAAK,EAAElE,0BAA0B,CAACgC,QAAQ,CAAC;MAC3CG,SAAS,EAAAA,SAAA;MACTgC,iBAAiB,EAAE,IAAI;MACvBC,UAAU,EAAE;KACb,CAAC,CAACzB,MAAM;EACX,CAAC;EAEa9B,UAAA,CAAAU,SAAA,CAAAe,eAAe,GAA7B,UACEN,QAAsB,EACtBqC,SAAgB,EAChBnC,OAAiB,EACjBC,SAA2B,EAC3BjB,eAA6C,EAC7CmB,sBAAuC;IAHvC,IAAAH,OAAA;MAAAA,OAAA,KAAiB;IAAA;IACjB,IAAAC,SAAA;MAAAA,SAAA,KAA2B;IAAA;IAC3B,IAAAjB,eAAA;MAAAA,eAAA,YAAAA,gBAAA;QAAyC,WAAI;MAAJ,CAAI;IAAA;IAC7C,IAAAmB,sBAAA;MAAAA,sBAAA,QAAuC;IAAA;;;;QAEjCiC,cAAc,GAAGnE,iBAAiB,CAAC6B,QAAQ,CAA4B;QACvEuC,SAAS,GAAGrE,sBAAsB,CAAC8B,QAAQ,CAAC;QAC5CwC,WAAW,GAAGvE,iBAAiB,CAACsE,SAAS,CAAC;QAC1CE,mBAAmB,GAAG,IAAI,CAACC,0BAA0B,CAACJ,cAAc,EAAEE,WAAW,CAAC;QAElFG,mBAAmB,GAAGL,cAAc,CAACM,SAAS;QAE9CC,oBAAoB,GAAGF,mBAAmB,GAC5CA,mBAAmB,CAACG,MAAM,CAAC,CAAC,CAAC,CAACC,WAAW,EAAE,GAC3CJ,mBAAmB,CAACK,KAAK,CAAC,CAAC,CAAC,GAC5B,OAAO;QAELlE,EAAA,GAAoB,IAAI,EAAtBC,KAAK,GAAAD,EAAA,CAAAC,KAAA,EAAEC,MAAM,GAAAF,EAAA,CAAAE,MAAA;QACfiE,WAAW,GAAgB;UAC/BT,WAAW,EAAAA,WAAA;UACXtC,OAAO,EAAAQ,QAAA,CAAAA,QAAA,KACFR,OAAO;YACVnB,KAAK,EAAAA,KAAA;YACLC,MAAM,EAAAA;UAAA,EACP;UACDmB,SAAS,EAAAA,SAAA;UACTjB,eAAe,EAAAA,eAAA;UACf2D,oBAAoB,EAAAA,oBAAA;UACpBxB,iBAAiB,EAAE,EAAE;UACrBoB,mBAAmB,EAAAA,mBAAA;UACnBpC,sBAAsB,EAAAA;SACvB;QACK6C,uBAAuB,GAAG,KAAK;QAErC,WAAO,IAAI,CAACC,mBAAmB,CAC7Bb,cAAc,CAACc,YAAY,EAC3BF,uBAAuB,EACvBb,SAAS,EACTY,WAAW,CACZ,CAACzC,IAAI,CAAC,UAAAG,MAAM;UAAI,OAAC;YAChBA,MAAM,EAAAA,MAAA;YACNU,iBAAiB,EAAE4B,WAAW,CAAC5B;WAChC;QAHgB,CAGf,CAAC;;;GACJ;EAEaxC,UAAA,CAAAU,SAAA,CAAA4D,mBAAmB,GAAjC,UACEC,YAA8B,EAC9BF,uBAAgC,EAChCb,SAAgB,EAChBY,WAAwB;;;;;QAEhBT,WAAW,GAAyBS,WAAW,CAAAT,WAApC,EAAEtC,OAAO,GAAgB+C,WAAW,CAAA/C,OAA3B,EAAEC,SAAS,GAAK8C,WAAW,CAAA9C,SAAhB;QACjCkD,cAAc,GAAY,CAAChB,SAAS,CAAC;QAErCiB,OAAO,GAAG,SAAAA,QAAOC,SAAwB;UAAA,OAAAC,SAAA,CAAAhE,KAAA;;;cAC7C,IAAI,CAAC0D,uBAAuB,IAAI,CAACD,WAAW,CAACR,mBAAmB,CAACgB,GAAG,CAACF,SAAS,CAAC,EAAE;gBAG/E;;cAEF,IAAI,CAAC5E,aAAa,CAAC4E,SAAS,EAAEpD,SAAS,CAAC,EAAE;gBAExC;;cAGF,IAAI9B,OAAO,CAACkF,SAAS,CAAC,EAAE;gBACtB,WAAO,IAAI,CAACG,YAAY,CAACH,SAAS,EAAEL,uBAAuB,EAAEb,SAAS,EAAEY,WAAW,CAAC,CAACzC,IAAI,CACvF,UAAAmD,WAAW;;kBACT,IAAI,OAAOA,WAAW,KAAK,WAAW,EAAE;oBACtCN,cAAc,CAACO,IAAI,EAAC9E,EAAA,OAClBA,EAAA,CAACJ,sBAAsB,CAAC6E,SAAS,CAAC,IAAGI,WAAW,E,EACxC,EAAC;;gBAEf,CAAC,CACF;;cAKH,IAAIrF,gBAAgB,CAACiF,SAAS,CAAC,EAAE;gBAC/BM,QAAQ,GAAGN,SAAS;eACrB,MAAM;gBAELM,QAAQ,GAAGrB,WAAW,CAACe,SAAS,CAAC5B,IAAI,CAACC,KAAK,CAAC;gBAC5CkC,OAAA,GAAUnG,SAAQ,CAAEkG,QAAA,sBAAqB,CAAAE,MAAS,CAACR,SAAK,CAAK5B,IAAI,CAAAC,KAAA,KAAAjE,SAAA,CAAAkG,QAAA;;cAGnE,IAAIA,QAAQ,IAAIA,QAAQ,CAACG,aAAa,EAAE;gBAChCA,aAAa,GAAGH,QAAQ,CAACG,aAAa,CAACrC,IAAI,CAACC,KAAK;gBACvD,IAAIqB,WAAW,CAAC/D,eAAe,CAACmD,SAAS,EAAE2B,aAAa,EAAE9D,OAAO,CAAC,EAAE;kBAClE,WAAO,IAAI,CAACiD,mBAAmB,CAC7BU,QAAQ,CAACT,YAAY,EACrBF,uBAAuB,EACvBb,SAAS,EACTY,WAAW,CACZ,CAACzC,IAAI,CAAC,UAAAyD,cAAc;oBACnBZ,cAAc,CAACO,IAAI,CAACK,cAAc,CAAC;kBACrC,CAAC,CAAC;;;;;;SAGP;QAED,WAAOC,OAAO,CAACC,GAAG,CAACf,YAAY,CAACgB,UAAU,CAACC,GAAG,CAACf,OAAO,CAAC,CAAC,CAAC9C,IAAI,CAAC;UAC5D,OAAOhC,cAAc,CAAC6E,cAAc,CAAC;QACvC,CAAC,CAAC;;;GACH;EAEaxE,UAAA,CAAAU,SAAA,CAAAmE,YAAY,GAA1B,UACEY,KAAgB,EAChBpB,uBAAgC,EAChCb,SAAc,EACdY,WAAwB;;;;;QAExB,IAAI,CAACZ,SAAS,EAAE;UACd,WAAO,IAAI;;QAGLlC,SAAS,GAAK8C,WAAW,CAAA9C,SAAhB;QACXoE,SAAS,GAAGD,KAAK,CAAC3C,IAAI,CAACC,KAAK;QAC5B4C,gBAAgB,GAAG9F,sBAAsB,CAAC4F,KAAK,CAAC;QAChDG,SAAS,GAAGF,SAAS,KAAKC,gBAAgB;QAC1CE,aAAa,GAAGrC,SAAS,CAACmC,gBAAgB,CAAC,IAAInC,SAAS,CAACkC,SAAS,CAAC;QACrEI,aAAa,GAAGT,OAAO,CAACU,OAAO,CAACF,aAAa,CAAC;QAMlD,IACE,CAACzB,WAAW,CAAC5C,sBAAsB,IACnC,IAAI,CAACiB,oBAAoB,CAACgD,KAAK,CAAC,EAChC;UACMO,YAAY,GAChBxC,SAAS,CAACyC,UAAU,IAAI7B,WAAW,CAACJ,oBAAoB;UACpDkC,WAAW,GAAG,IAAI,CAAC9F,SAAS,IAAI,IAAI,CAACA,SAAS,CAAC4F,YAAY,CAAC;UAClE,IAAIE,WAAW,EAAE;YACTH,OAAO,GAAGG,WAAW,CAACN,SAAS,GAAGF,SAAS,GAAGC,gBAAgB,CAAC;YACrE,IAAII,OAAO,EAAE;cACXD,aAAa,GAAGT,OAAO,CAACU,OAAO,CAG7BhG,SAAS,CAACoG,SAAS,CAAC,IAAI,CAACjG,KAAK,EAAE6F,OAAO,EAAE,CACvCvC,SAAS,EACTtE,wBAAwB,CAACuG,KAAK,EAAEnE,SAAS,CAAC,EAC1C8C,WAAW,CAAC/C,OAAO,EACnB;gBAAEoE,KAAK,EAAAA,KAAA;gBAAE9B,WAAW,EAAES,WAAW,CAACT;cAAW,CAAE,CAChD,CAAC,CACH;;;;QAKP,WAAOmC,aAAa,CAACnE,IAAI,CAAC,UAACG,MAAsB;;UAAtB,IAAAA,MAAA;YAAAA,MAAA,GAAA+D,aAAsB;UAAA;UAG/C,IAAIJ,KAAK,CAACW,UAAU,EAAE;YACpBX,KAAK,CAACW,UAAU,CAACtF,OAAO,CAAC,UAAAuF,SAAS;cAChC,IAAIA,SAAS,CAACvD,IAAI,CAACC,KAAK,KAAK,QAAQ,IAAIsD,SAAS,CAACrD,SAAS,EAAE;gBAC5DqD,SAAS,CAACrD,SAAS,CAAClC,OAAO,CAAC,UAAAoC,GAAG;kBAC7B,IAAIA,GAAG,CAACJ,IAAI,CAACC,KAAK,KAAK,IAAI,IAAIG,GAAG,CAACH,KAAK,CAACI,IAAI,KAAK,aAAa,EAAE;oBAC/DiB,WAAW,CAAC5B,iBAAiB,CAACU,GAAG,CAACH,KAAK,CAACA,KAAK,CAAC,GAAGjB,MAAM;;gBAE3D,CAAC,CAAC;;YAEN,CAAC,CAAC;;UAIJ,IAAI,CAAC2D,KAAK,CAAClB,YAAY,EAAE;YACvB,OAAOzC,MAAM;;UAKf,IAAIA,MAAM,IAAI,IAAI,EAAE;YAElB,OAAOA,MAAM;;UAGf,IAAMwE,aAAa,GAAG,CAAA/E,EAAA,IAAAtB,EAAA,GAAAwF,KAAK,CAACW,UAAU,cAAAnG,EAAA,uBAAAA,EAAA,CAAEgD,IAAI,CAAC,UAAAsD,CAAC;YAAI,OAAAA,CAAC,CAACzD,IAAI,CAACC,KAAK,KAAK,QAAQ;UAAzB,CAAyB,CAAC,cAAAxB,EAAA,cAAAA,EAAA,GAAI,KAAK;UAErF,IAAIX,KAAK,CAACC,OAAO,CAACiB,MAAM,CAAC,EAAE;YACzB,OAAOnB,KAAI,CAAC6F,uBAAuB,CAACf,KAAK,EAAEpB,uBAAuB,IAAIiC,aAAa,EAAExE,MAAM,EAAEsC,WAAW,CAAC;;UAI3G,IAAIqB,KAAK,CAAClB,YAAY,EAAE;YACtB,OAAO5D,KAAI,CAAC2D,mBAAmB,CAC7BmB,KAAK,CAAClB,YAAY,EAClBF,uBAAuB,IAAIiC,aAAa,EACxCxE,MAAM,EACNsC,WAAW,CACZ;;QAEL,CAAC,CAAC;;;GACH;EAEOpE,UAAA,CAAAU,SAAA,CAAA8F,uBAAuB,GAA/B,UACEf,KAAgB,EAChBpB,uBAAgC,EAChCvC,MAAa,EACbsC,WAAwB;IAJ1B,IAAAzD,KAAA;IAME,OAAO0E,OAAO,CAACC,GAAG,CAChBxD,MAAM,CAAC0D,GAAG,CAAC,UAAAiB,IAAI;MACb,IAAIA,IAAI,KAAK,IAAI,EAAE;QACjB,OAAO,IAAI;;MAIb,IAAI7F,KAAK,CAACC,OAAO,CAAC4F,IAAI,CAAC,EAAE;QACvB,OAAO9F,KAAI,CAAC6F,uBAAuB,CAACf,KAAK,EAAEpB,uBAAuB,EAAEoC,IAAI,EAAErC,WAAW,CAAC;;MAIxF,IAAIqB,KAAK,CAAClB,YAAY,EAAE;QACtB,OAAO5D,KAAI,CAAC2D,mBAAmB,CAACmB,KAAK,CAAClB,YAAY,EAAEF,uBAAuB,EAAEoC,IAAI,EAAErC,WAAW,CAAC;;IAEnG,CAAC,CAAC,CACH;EACH,CAAC;EAKOpE,UAAA,CAAAU,SAAA,CAAAmD,0BAA0B,GAAlC,UACEJ,cAAuC,EACvCE,WAAwB;IAExB,IAAM+C,eAAe,GAAG,SAAlBA,eAAeA,CAAI7D,IAAkC;MAAsB,QAACjC,KAAK,CAACC,OAAO,CAACgC,IAAI,CAAC;IAApB,CAAoB;IACrG,IAAMvC,wBAAwB,GAAG,IAAI,CAACA,wBAAwB;IAE9D,SAASqG,mBAAmBA,CAACC,cAAwC;MACnE,IAAI,CAACtG,wBAAwB,CAACsE,GAAG,CAACgC,cAAc,CAAC,EAAE;QACjD,IAAMC,SAAO,GAAG,IAAIC,GAAG,EAAiB;QACxCxG,wBAAwB,CAACyG,GAAG,CAACH,cAAc,EAAEC,SAAO,CAAC;QAErD9H,KAAK,CAAC6H,cAAc,EAAE;UACpBjE,SAAS,WAAAA,UAACE,IAAmB,EAAEmE,CAAC,EAAEC,EAAE,EAAEC,GAAG,EAAEC,SAAS;YAClD,IAAItE,IAAI,CAACC,IAAI,CAACC,KAAK,KAAK,QAAQ,EAAE;cAChCoE,SAAS,CAACrG,OAAO,CAAC,UAAA+B,IAAI;gBACpB,IAAI6D,eAAe,CAAC7D,IAAI,CAAC,IAAI5D,eAAe,CAAC4D,IAAI,CAAC,EAAE;kBAClDgE,SAAO,CAACO,GAAG,CAACvE,IAAI,CAAC;;cAErB,CAAC,CAAC;;UAEN,CAAC;UACDwE,cAAc,WAAAA,eAACC,MAA0B,EAAEN,CAAC,EAAEC,EAAE,EAAEC,GAAG,EAAEC,SAAS;YAC9D,IAAMnC,QAAQ,GAAGrB,WAAW,CAAC2D,MAAM,CAACxE,IAAI,CAACC,KAAK,CAAC;YAC/CkC,OAAA,GAAUnG,SAAQ,CAAEkG,QAAA,sBAAqB,CAAAE,MAAO,CAAAoC,MAAK,CAAKxE,IAAI,CAAAC,KAAA,KAAAjE,SAAA,CAAAkG,QAAA;YAE9D,IAAMuC,kBAAkB,GAAGZ,mBAAmB,CAAC3B,QAAQ,CAAC;YACxD,IAAIuC,kBAAkB,CAACC,IAAI,GAAG,CAAC,EAAE;cAG/BL,SAAS,CAACrG,OAAO,CAAC,UAAA+B,IAAI;gBACpB,IAAI6D,eAAe,CAAC7D,IAAI,CAAC,IAAI5D,eAAe,CAAC4D,IAAI,CAAC,EAAE;kBAClDgE,SAAO,CAACO,GAAG,CAACvE,IAAI,CAAC;;cAErB,CAAC,CAAC;cACFgE,SAAO,CAACO,GAAG,CAACE,MAAM,CAAC;cACnBC,kBAAkB,CAACzG,OAAO,CAAC,UAAA4D,SAAS;gBAClCmC,SAAO,CAACO,GAAG,CAAC1C,SAAS,CAAC;cACxB,CAAC,CAAC;;UAEN;SACD,CAAC;;MAEJ,OAAOpE,wBAAwB,CAACmH,GAAG,CAACb,cAAc,CAAE;IACtD;IACA,OAAOD,mBAAmB,CAAClD,cAAc,CAAC;EAC5C,CAAC;EACH,OAAAzD,UAAC;AAAD,CAAC,CArcD"},"metadata":{},"sourceType":"module","externalDependencies":[]}