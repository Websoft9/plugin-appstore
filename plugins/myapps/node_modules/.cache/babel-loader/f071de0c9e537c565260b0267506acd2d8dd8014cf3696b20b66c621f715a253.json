{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant, InvariantError } from \"../utilities/globals/index.js\";\nimport { equal } from '@wry/equality';\nimport { execute } from \"../link/core/index.js\";\nimport { isExecutionPatchIncrementalResult, isExecutionPatchResult } from \"../utilities/common/incrementalResult.js\";\nimport { canonicalStringify } from \"../cache/index.js\";\nimport { getDefaultValues, getOperationDefinition, getOperationName, hasClientExports, graphQLResultHasError, getGraphQLErrorsFromResult, removeConnectionDirectiveFromDocument, canUseWeakMap, Observable, asyncMap, isNonEmptyArray, Concast, makeUniqueId, isDocumentNode, isNonNullObject } from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/common/incrementalResult.js\";\nimport { ApolloError, isApolloError, graphQLResultHasProtocolErrors } from \"../errors/index.js\";\nimport { ObservableQuery, logMissingFieldErrors } from \"./ObservableQuery.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport { LocalState } from \"./LocalState.js\";\nimport { QueryInfo, shouldWriteResult } from \"./QueryInfo.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../errors/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar QueryManager = function () {\n  function QueryManager(_a) {\n    var cache = _a.cache,\n      link = _a.link,\n      defaultOptions = _a.defaultOptions,\n      _b = _a.queryDeduplication,\n      queryDeduplication = _b === void 0 ? false : _b,\n      onBroadcast = _a.onBroadcast,\n      _c = _a.ssrMode,\n      ssrMode = _c === void 0 ? false : _c,\n      _d = _a.clientAwareness,\n      clientAwareness = _d === void 0 ? {} : _d,\n      localState = _a.localState,\n      assumeImmutableResults = _a.assumeImmutableResults;\n    this.clientAwareness = {};\n    this.queries = new Map();\n    this.fetchCancelFns = new Map();\n    this.transformCache = new (canUseWeakMap ? WeakMap : Map)();\n    this.queryIdCounter = 1;\n    this.requestIdCounter = 1;\n    this.mutationIdCounter = 1;\n    this.inFlightLinkObservables = new Map();\n    this.cache = cache;\n    this.link = link;\n    this.defaultOptions = defaultOptions || Object.create(null);\n    this.queryDeduplication = queryDeduplication;\n    this.clientAwareness = clientAwareness;\n    this.localState = localState || new LocalState({\n      cache: cache\n    });\n    this.ssrMode = ssrMode;\n    this.assumeImmutableResults = !!assumeImmutableResults;\n    if (this.onBroadcast = onBroadcast) {\n      this.mutationStore = Object.create(null);\n    }\n  }\n  QueryManager.prototype.stop = function () {\n    var _this = this;\n    this.queries.forEach(function (_info, queryId) {\n      _this.stopQueryNoBroadcast(queryId);\n    });\n    this.cancelPendingFetches(__DEV__ ? new InvariantError('QueryManager stopped while query was in flight') : new InvariantError(14));\n  };\n  QueryManager.prototype.cancelPendingFetches = function (error) {\n    this.fetchCancelFns.forEach(function (cancel) {\n      return cancel(error);\n    });\n    this.fetchCancelFns.clear();\n  };\n  QueryManager.prototype.mutate = function (_a) {\n    var _b, _c;\n    var mutation = _a.mutation,\n      variables = _a.variables,\n      optimisticResponse = _a.optimisticResponse,\n      updateQueries = _a.updateQueries,\n      _d = _a.refetchQueries,\n      refetchQueries = _d === void 0 ? [] : _d,\n      _e = _a.awaitRefetchQueries,\n      awaitRefetchQueries = _e === void 0 ? false : _e,\n      updateWithProxyFn = _a.update,\n      onQueryUpdated = _a.onQueryUpdated,\n      _f = _a.fetchPolicy,\n      fetchPolicy = _f === void 0 ? ((_b = this.defaultOptions.mutate) === null || _b === void 0 ? void 0 : _b.fetchPolicy) || \"network-only\" : _f,\n      _g = _a.errorPolicy,\n      errorPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.errorPolicy) || \"none\" : _g,\n      keepRootFields = _a.keepRootFields,\n      context = _a.context;\n    return __awaiter(this, void 0, void 0, function () {\n      var mutationId, _h, document, hasClientExports, mutationStoreValue, self;\n      return __generator(this, function (_j) {\n        switch (_j.label) {\n          case 0:\n            __DEV__ ? invariant(mutation, 'mutation option is required. You must specify your GraphQL document in the mutation option.') : invariant(mutation, 15);\n            __DEV__ ? invariant(fetchPolicy === 'network-only' || fetchPolicy === 'no-cache', \"Mutations support only 'network-only' or 'no-cache' fetchPolicy strings. The default `network-only` behavior automatically writes mutation results to the cache. Passing `no-cache` skips the cache write.\") : invariant(fetchPolicy === 'network-only' || fetchPolicy === 'no-cache', 16);\n            mutationId = this.generateMutationId();\n            _h = this.transform(mutation), document = _h.document, hasClientExports = _h.hasClientExports;\n            mutation = this.cache.transformForLink(document);\n            variables = this.getVariables(mutation, variables);\n            if (!hasClientExports) return [3, 2];\n            return [4, this.localState.addExportedVariables(mutation, variables, context)];\n          case 1:\n            variables = _j.sent();\n            _j.label = 2;\n          case 2:\n            mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {\n              mutation: mutation,\n              variables: variables,\n              loading: true,\n              error: null\n            });\n            if (optimisticResponse) {\n              this.markMutationOptimistic(optimisticResponse, {\n                mutationId: mutationId,\n                document: mutation,\n                variables: variables,\n                fetchPolicy: fetchPolicy,\n                errorPolicy: errorPolicy,\n                context: context,\n                updateQueries: updateQueries,\n                update: updateWithProxyFn,\n                keepRootFields: keepRootFields\n              });\n            }\n            this.broadcastQueries();\n            self = this;\n            return [2, new Promise(function (resolve, reject) {\n              return asyncMap(self.getObservableFromLink(mutation, __assign(__assign({}, context), {\n                optimisticResponse: optimisticResponse\n              }), variables, false), function (result) {\n                if (graphQLResultHasError(result) && errorPolicy === 'none') {\n                  throw new ApolloError({\n                    graphQLErrors: getGraphQLErrorsFromResult(result)\n                  });\n                }\n                if (mutationStoreValue) {\n                  mutationStoreValue.loading = false;\n                  mutationStoreValue.error = null;\n                }\n                var storeResult = __assign({}, result);\n                if (typeof refetchQueries === \"function\") {\n                  refetchQueries = refetchQueries(storeResult);\n                }\n                if (errorPolicy === 'ignore' && graphQLResultHasError(storeResult)) {\n                  delete storeResult.errors;\n                }\n                return self.markMutationResult({\n                  mutationId: mutationId,\n                  result: storeResult,\n                  document: mutation,\n                  variables: variables,\n                  fetchPolicy: fetchPolicy,\n                  errorPolicy: errorPolicy,\n                  context: context,\n                  update: updateWithProxyFn,\n                  updateQueries: updateQueries,\n                  awaitRefetchQueries: awaitRefetchQueries,\n                  refetchQueries: refetchQueries,\n                  removeOptimistic: optimisticResponse ? mutationId : void 0,\n                  onQueryUpdated: onQueryUpdated,\n                  keepRootFields: keepRootFields\n                });\n              }).subscribe({\n                next: function next(storeResult) {\n                  self.broadcastQueries();\n                  if (!('hasNext' in storeResult) || storeResult.hasNext === false) {\n                    resolve(storeResult);\n                  }\n                },\n                error: function error(err) {\n                  if (mutationStoreValue) {\n                    mutationStoreValue.loading = false;\n                    mutationStoreValue.error = err;\n                  }\n                  if (optimisticResponse) {\n                    self.cache.removeOptimistic(mutationId);\n                  }\n                  self.broadcastQueries();\n                  reject(err instanceof ApolloError ? err : new ApolloError({\n                    networkError: err\n                  }));\n                }\n              });\n            })];\n        }\n      });\n    });\n  };\n  QueryManager.prototype.markMutationResult = function (mutation, cache) {\n    var _this = this;\n    if (cache === void 0) {\n      cache = this.cache;\n    }\n    var result = mutation.result;\n    var cacheWrites = [];\n    var skipCache = mutation.fetchPolicy === \"no-cache\";\n    if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n      if (!isExecutionPatchIncrementalResult(result)) {\n        cacheWrites.push({\n          result: result.data,\n          dataId: 'ROOT_MUTATION',\n          query: mutation.document,\n          variables: mutation.variables\n        });\n      }\n      if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {\n        var diff = cache.diff({\n          id: \"ROOT_MUTATION\",\n          query: this.transform(mutation.document).asQuery,\n          variables: mutation.variables,\n          optimistic: false,\n          returnPartialData: true\n        });\n        var mergedData = void 0;\n        if (diff.result) {\n          mergedData = mergeIncrementalData(diff.result, result);\n        }\n        if (typeof mergedData !== 'undefined') {\n          result.data = mergedData;\n          cacheWrites.push({\n            result: mergedData,\n            dataId: 'ROOT_MUTATION',\n            query: mutation.document,\n            variables: mutation.variables\n          });\n        }\n      }\n      var updateQueries_1 = mutation.updateQueries;\n      if (updateQueries_1) {\n        this.queries.forEach(function (_a, queryId) {\n          var observableQuery = _a.observableQuery;\n          var queryName = observableQuery && observableQuery.queryName;\n          if (!queryName || !hasOwnProperty.call(updateQueries_1, queryName)) {\n            return;\n          }\n          var updater = updateQueries_1[queryName];\n          var _b = _this.queries.get(queryId),\n            document = _b.document,\n            variables = _b.variables;\n          var _c = cache.diff({\n              query: document,\n              variables: variables,\n              returnPartialData: true,\n              optimistic: false\n            }),\n            currentQueryResult = _c.result,\n            complete = _c.complete;\n          if (complete && currentQueryResult) {\n            var nextQueryResult = updater(currentQueryResult, {\n              mutationResult: result,\n              queryName: document && getOperationName(document) || void 0,\n              queryVariables: variables\n            });\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: 'ROOT_QUERY',\n                query: document,\n                variables: variables\n              });\n            }\n          }\n        });\n      }\n    }\n    if (cacheWrites.length > 0 || mutation.refetchQueries || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {\n      var results_1 = [];\n      this.refetchQueries({\n        updateCache: function updateCache(cache) {\n          if (!skipCache) {\n            cacheWrites.forEach(function (write) {\n              return cache.write(write);\n            });\n          }\n          var update = mutation.update;\n          var isFinalResult = !isExecutionPatchResult(result) || isExecutionPatchIncrementalResult(result) && !result.hasNext;\n          if (update) {\n            if (!skipCache) {\n              var diff = cache.diff({\n                id: \"ROOT_MUTATION\",\n                query: _this.transform(mutation.document).asQuery,\n                variables: mutation.variables,\n                optimistic: false,\n                returnPartialData: true\n              });\n              if (diff.complete) {\n                result = __assign(__assign({}, result), {\n                  data: diff.result\n                });\n                if ('incremental' in result) {\n                  delete result.incremental;\n                }\n                if ('hasNext' in result) {\n                  delete result.hasNext;\n                }\n              }\n            }\n            if (isFinalResult) {\n              update(cache, result, {\n                context: mutation.context,\n                variables: mutation.variables\n              });\n            }\n          }\n          if (!skipCache && !mutation.keepRootFields && isFinalResult) {\n            cache.modify({\n              id: 'ROOT_MUTATION',\n              fields: function fields(value, _a) {\n                var fieldName = _a.fieldName,\n                  DELETE = _a.DELETE;\n                return fieldName === \"__typename\" ? value : DELETE;\n              }\n            });\n          }\n        },\n        include: mutation.refetchQueries,\n        optimistic: false,\n        removeOptimistic: mutation.removeOptimistic,\n        onQueryUpdated: mutation.onQueryUpdated || null\n      }).forEach(function (result) {\n        return results_1.push(result);\n      });\n      if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n        return Promise.all(results_1).then(function () {\n          return result;\n        });\n      }\n    }\n    return Promise.resolve(result);\n  };\n  QueryManager.prototype.markMutationOptimistic = function (optimisticResponse, mutation) {\n    var _this = this;\n    var data = typeof optimisticResponse === \"function\" ? optimisticResponse(mutation.variables) : optimisticResponse;\n    return this.cache.recordOptimisticTransaction(function (cache) {\n      try {\n        _this.markMutationResult(__assign(__assign({}, mutation), {\n          result: {\n            data: data\n          }\n        }), cache);\n      } catch (error) {\n        __DEV__ && invariant.error(error);\n      }\n    }, mutation.mutationId);\n  };\n  QueryManager.prototype.fetchQuery = function (queryId, options, networkStatus) {\n    return this.fetchQueryObservable(queryId, options, networkStatus).promise;\n  };\n  QueryManager.prototype.getQueryStore = function () {\n    var store = Object.create(null);\n    this.queries.forEach(function (info, queryId) {\n      store[queryId] = {\n        variables: info.variables,\n        networkStatus: info.networkStatus,\n        networkError: info.networkError,\n        graphQLErrors: info.graphQLErrors\n      };\n    });\n    return store;\n  };\n  QueryManager.prototype.resetErrors = function (queryId) {\n    var queryInfo = this.queries.get(queryId);\n    if (queryInfo) {\n      queryInfo.networkError = undefined;\n      queryInfo.graphQLErrors = [];\n    }\n  };\n  QueryManager.prototype.transform = function (document) {\n    var transformCache = this.transformCache;\n    if (!transformCache.has(document)) {\n      var transformed = this.cache.transformDocument(document);\n      var noConnection = removeConnectionDirectiveFromDocument(transformed);\n      var clientQuery = this.localState.clientQuery(transformed);\n      var serverQuery = noConnection && this.localState.serverQuery(noConnection);\n      var cacheEntry_1 = {\n        document: transformed,\n        hasClientExports: hasClientExports(transformed),\n        hasForcedResolvers: this.localState.shouldForceResolvers(transformed),\n        clientQuery: clientQuery,\n        serverQuery: serverQuery,\n        defaultVars: getDefaultValues(getOperationDefinition(transformed)),\n        asQuery: __assign(__assign({}, transformed), {\n          definitions: transformed.definitions.map(function (def) {\n            if (def.kind === \"OperationDefinition\" && def.operation !== \"query\") {\n              return __assign(__assign({}, def), {\n                operation: \"query\"\n              });\n            }\n            return def;\n          })\n        })\n      };\n      var add = function add(doc) {\n        if (doc && !transformCache.has(doc)) {\n          transformCache.set(doc, cacheEntry_1);\n        }\n      };\n      add(document);\n      add(transformed);\n      add(clientQuery);\n      add(serverQuery);\n    }\n    return transformCache.get(document);\n  };\n  QueryManager.prototype.getVariables = function (document, variables) {\n    return __assign(__assign({}, this.transform(document).defaultVars), variables);\n  };\n  QueryManager.prototype.watchQuery = function (options) {\n    options = __assign(__assign({}, options), {\n      variables: this.getVariables(options.query, options.variables)\n    });\n    if (typeof options.notifyOnNetworkStatusChange === 'undefined') {\n      options.notifyOnNetworkStatusChange = false;\n    }\n    var queryInfo = new QueryInfo(this);\n    var observable = new ObservableQuery({\n      queryManager: this,\n      queryInfo: queryInfo,\n      options: options\n    });\n    this.queries.set(observable.queryId, queryInfo);\n    queryInfo.init({\n      document: observable.query,\n      observableQuery: observable,\n      variables: observable.variables\n    });\n    return observable;\n  };\n  QueryManager.prototype.query = function (options, queryId) {\n    var _this = this;\n    if (queryId === void 0) {\n      queryId = this.generateQueryId();\n    }\n    __DEV__ ? invariant(options.query, 'query option is required. You must specify your GraphQL document ' + 'in the query option.') : invariant(options.query, 17);\n    __DEV__ ? invariant(options.query.kind === 'Document', 'You must wrap the query string in a \"gql\" tag.') : invariant(options.query.kind === 'Document', 18);\n    __DEV__ ? invariant(!options.returnPartialData, 'returnPartialData option only supported on watchQuery.') : invariant(!options.returnPartialData, 19);\n    __DEV__ ? invariant(!options.pollInterval, 'pollInterval option only supported on watchQuery.') : invariant(!options.pollInterval, 20);\n    return this.fetchQuery(queryId, options).finally(function () {\n      return _this.stopQuery(queryId);\n    });\n  };\n  QueryManager.prototype.generateQueryId = function () {\n    return String(this.queryIdCounter++);\n  };\n  QueryManager.prototype.generateRequestId = function () {\n    return this.requestIdCounter++;\n  };\n  QueryManager.prototype.generateMutationId = function () {\n    return String(this.mutationIdCounter++);\n  };\n  QueryManager.prototype.stopQueryInStore = function (queryId) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  };\n  QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {\n    var queryInfo = this.queries.get(queryId);\n    if (queryInfo) queryInfo.stop();\n  };\n  QueryManager.prototype.clearStore = function (options) {\n    if (options === void 0) {\n      options = {\n        discardWatches: true\n      };\n    }\n    this.cancelPendingFetches(__DEV__ ? new InvariantError('Store reset while query was in flight (not completed in link chain)') : new InvariantError(21));\n    this.queries.forEach(function (queryInfo) {\n      if (queryInfo.observableQuery) {\n        queryInfo.networkStatus = NetworkStatus.loading;\n      } else {\n        queryInfo.stop();\n      }\n    });\n    if (this.mutationStore) {\n      this.mutationStore = Object.create(null);\n    }\n    return this.cache.reset(options);\n  };\n  QueryManager.prototype.getObservableQueries = function (include) {\n    var _this = this;\n    if (include === void 0) {\n      include = \"active\";\n    }\n    var queries = new Map();\n    var queryNamesAndDocs = new Map();\n    var legacyQueryOptions = new Set();\n    if (Array.isArray(include)) {\n      include.forEach(function (desc) {\n        if (typeof desc === \"string\") {\n          queryNamesAndDocs.set(desc, false);\n        } else if (isDocumentNode(desc)) {\n          queryNamesAndDocs.set(_this.transform(desc).document, false);\n        } else if (isNonNullObject(desc) && desc.query) {\n          legacyQueryOptions.add(desc);\n        }\n      });\n    }\n    this.queries.forEach(function (_a, queryId) {\n      var oq = _a.observableQuery,\n        document = _a.document;\n      if (oq) {\n        if (include === \"all\") {\n          queries.set(queryId, oq);\n          return;\n        }\n        var queryName = oq.queryName,\n          fetchPolicy = oq.options.fetchPolicy;\n        if (fetchPolicy === \"standby\" || include === \"active\" && !oq.hasObservers()) {\n          return;\n        }\n        if (include === \"active\" || queryName && queryNamesAndDocs.has(queryName) || document && queryNamesAndDocs.has(document)) {\n          queries.set(queryId, oq);\n          if (queryName) queryNamesAndDocs.set(queryName, true);\n          if (document) queryNamesAndDocs.set(document, true);\n        }\n      }\n    });\n    if (legacyQueryOptions.size) {\n      legacyQueryOptions.forEach(function (options) {\n        var queryId = makeUniqueId(\"legacyOneTimeQuery\");\n        var queryInfo = _this.getQuery(queryId).init({\n          document: options.query,\n          variables: options.variables\n        });\n        var oq = new ObservableQuery({\n          queryManager: _this,\n          queryInfo: queryInfo,\n          options: __assign(__assign({}, options), {\n            fetchPolicy: \"network-only\"\n          })\n        });\n        invariant(oq.queryId === queryId);\n        queryInfo.setObservableQuery(oq);\n        queries.set(queryId, oq);\n      });\n    }\n    if (__DEV__ && queryNamesAndDocs.size) {\n      queryNamesAndDocs.forEach(function (included, nameOrDoc) {\n        if (!included) {\n          __DEV__ && invariant.warn(\"Unknown query \".concat(typeof nameOrDoc === \"string\" ? \"named \" : \"\").concat(JSON.stringify(nameOrDoc, null, 2), \" requested in refetchQueries options.include array\"));\n        }\n      });\n    }\n    return queries;\n  };\n  QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {\n    var _this = this;\n    if (includeStandby === void 0) {\n      includeStandby = false;\n    }\n    var observableQueryPromises = [];\n    this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(function (observableQuery, queryId) {\n      var fetchPolicy = observableQuery.options.fetchPolicy;\n      observableQuery.resetLastResults();\n      if (includeStandby || fetchPolicy !== \"standby\" && fetchPolicy !== \"cache-only\") {\n        observableQueryPromises.push(observableQuery.refetch());\n      }\n      _this.getQuery(queryId).setDiff(null);\n    });\n    this.broadcastQueries();\n    return Promise.all(observableQueryPromises);\n  };\n  QueryManager.prototype.setObservableQuery = function (observableQuery) {\n    this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\n  };\n  QueryManager.prototype.startGraphQLSubscription = function (_a) {\n    var _this = this;\n    var query = _a.query,\n      fetchPolicy = _a.fetchPolicy,\n      errorPolicy = _a.errorPolicy,\n      variables = _a.variables,\n      _b = _a.context,\n      context = _b === void 0 ? {} : _b;\n    query = this.transform(query).document;\n    variables = this.getVariables(query, variables);\n    var makeObservable = function makeObservable(variables) {\n      return _this.getObservableFromLink(query, context, variables).map(function (result) {\n        if (fetchPolicy !== 'no-cache') {\n          if (shouldWriteResult(result, errorPolicy)) {\n            _this.cache.write({\n              query: query,\n              result: result.data,\n              dataId: 'ROOT_SUBSCRIPTION',\n              variables: variables\n            });\n          }\n          _this.broadcastQueries();\n        }\n        var hasErrors = graphQLResultHasError(result);\n        var hasProtocolErrors = graphQLResultHasProtocolErrors(result);\n        if (hasErrors || hasProtocolErrors) {\n          var errors = {};\n          if (hasErrors) {\n            errors.graphQLErrors = result.errors;\n          }\n          if (hasProtocolErrors) {\n            errors.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];\n          }\n          throw new ApolloError(errors);\n        }\n        return result;\n      });\n    };\n    if (this.transform(query).hasClientExports) {\n      var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);\n      return new Observable(function (observer) {\n        var sub = null;\n        observablePromise_1.then(function (observable) {\n          return sub = observable.subscribe(observer);\n        }, observer.error);\n        return function () {\n          return sub && sub.unsubscribe();\n        };\n      });\n    }\n    return makeObservable(variables);\n  };\n  QueryManager.prototype.stopQuery = function (queryId) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  };\n  QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  };\n  QueryManager.prototype.removeQuery = function (queryId) {\n    this.fetchCancelFns.delete(queryId);\n    if (this.queries.has(queryId)) {\n      this.getQuery(queryId).stop();\n      this.queries.delete(queryId);\n    }\n  };\n  QueryManager.prototype.broadcastQueries = function () {\n    if (this.onBroadcast) this.onBroadcast();\n    this.queries.forEach(function (info) {\n      return info.notify();\n    });\n  };\n  QueryManager.prototype.getLocalState = function () {\n    return this.localState;\n  };\n  QueryManager.prototype.getObservableFromLink = function (query, context, variables, deduplication) {\n    var _this = this;\n    var _a;\n    if (deduplication === void 0) {\n      deduplication = (_a = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication;\n    }\n    var observable;\n    var serverQuery = this.transform(query).serverQuery;\n    if (serverQuery) {\n      var _b = this,\n        inFlightLinkObservables_1 = _b.inFlightLinkObservables,\n        link = _b.link;\n      var operation = {\n        query: serverQuery,\n        variables: variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext(__assign(__assign({}, context), {\n          forceFetch: !deduplication\n        }))\n      };\n      context = operation.context;\n      if (deduplication) {\n        var byVariables_1 = inFlightLinkObservables_1.get(serverQuery) || new Map();\n        inFlightLinkObservables_1.set(serverQuery, byVariables_1);\n        var varJson_1 = canonicalStringify(variables);\n        observable = byVariables_1.get(varJson_1);\n        if (!observable) {\n          var concast = new Concast([execute(link, operation)]);\n          byVariables_1.set(varJson_1, observable = concast);\n          concast.beforeNext(function () {\n            if (byVariables_1.delete(varJson_1) && byVariables_1.size < 1) {\n              inFlightLinkObservables_1.delete(serverQuery);\n            }\n          });\n        }\n      } else {\n        observable = new Concast([execute(link, operation)]);\n      }\n    } else {\n      observable = new Concast([Observable.of({\n        data: {}\n      })]);\n      context = this.prepareContext(context);\n    }\n    var clientQuery = this.transform(query).clientQuery;\n    if (clientQuery) {\n      observable = asyncMap(observable, function (result) {\n        return _this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context: context,\n          variables: variables\n        });\n      });\n    }\n    return observable;\n  };\n  QueryManager.prototype.getResultsFromLink = function (queryInfo, cacheWriteBehavior, options) {\n    var requestId = queryInfo.lastRequestId = this.generateRequestId();\n    var linkDocument = this.cache.transformForLink(this.transform(queryInfo.document).document);\n    return asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function (result) {\n      var graphQLErrors = getGraphQLErrorsFromResult(result);\n      var hasErrors = graphQLErrors.length > 0;\n      if (requestId >= queryInfo.lastRequestId) {\n        if (hasErrors && options.errorPolicy === \"none\") {\n          throw queryInfo.markError(new ApolloError({\n            graphQLErrors: graphQLErrors\n          }));\n        }\n        queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);\n        queryInfo.markReady();\n      }\n      var aqr = {\n        data: result.data,\n        loading: false,\n        networkStatus: NetworkStatus.ready\n      };\n      if (hasErrors && options.errorPolicy !== \"ignore\") {\n        aqr.errors = graphQLErrors;\n        aqr.networkStatus = NetworkStatus.error;\n      }\n      return aqr;\n    }, function (networkError) {\n      var error = isApolloError(networkError) ? networkError : new ApolloError({\n        networkError: networkError\n      });\n      if (requestId >= queryInfo.lastRequestId) {\n        queryInfo.markError(error);\n      }\n      throw error;\n    });\n  };\n  QueryManager.prototype.fetchQueryObservable = function (queryId, options, networkStatus) {\n    return this.fetchConcastWithInfo(queryId, options, networkStatus).concast;\n  };\n  QueryManager.prototype.fetchConcastWithInfo = function (queryId, options, networkStatus) {\n    var _this = this;\n    if (networkStatus === void 0) {\n      networkStatus = NetworkStatus.loading;\n    }\n    var query = this.transform(options.query).document;\n    var variables = this.getVariables(query, options.variables);\n    var queryInfo = this.getQuery(queryId);\n    var defaults = this.defaultOptions.watchQuery;\n    var _a = options.fetchPolicy,\n      fetchPolicy = _a === void 0 ? defaults && defaults.fetchPolicy || \"cache-first\" : _a,\n      _b = options.errorPolicy,\n      errorPolicy = _b === void 0 ? defaults && defaults.errorPolicy || \"none\" : _b,\n      _c = options.returnPartialData,\n      returnPartialData = _c === void 0 ? false : _c,\n      _d = options.notifyOnNetworkStatusChange,\n      notifyOnNetworkStatusChange = _d === void 0 ? false : _d,\n      _e = options.context,\n      context = _e === void 0 ? {} : _e;\n    var normalized = Object.assign({}, options, {\n      query: query,\n      variables: variables,\n      fetchPolicy: fetchPolicy,\n      errorPolicy: errorPolicy,\n      returnPartialData: returnPartialData,\n      notifyOnNetworkStatusChange: notifyOnNetworkStatusChange,\n      context: context\n    });\n    var fromVariables = function fromVariables(variables) {\n      normalized.variables = variables;\n      var sourcesWithInfo = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);\n      if (normalized.fetchPolicy !== \"standby\" && sourcesWithInfo.sources.length > 0 && queryInfo.observableQuery) {\n        queryInfo.observableQuery[\"applyNextFetchPolicy\"](\"after-fetch\", options);\n      }\n      return sourcesWithInfo;\n    };\n    var cleanupCancelFn = function cleanupCancelFn() {\n      return _this.fetchCancelFns.delete(queryId);\n    };\n    this.fetchCancelFns.set(queryId, function (reason) {\n      cleanupCancelFn();\n      setTimeout(function () {\n        return concast.cancel(reason);\n      });\n    });\n    var concast, containsDataFromLink;\n    if (this.transform(normalized.query).hasClientExports) {\n      concast = new Concast(this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables).then(function (sourcesWithInfo) {\n        return sourcesWithInfo.sources;\n      }));\n      containsDataFromLink = true;\n    } else {\n      var sourcesWithInfo = fromVariables(normalized.variables);\n      containsDataFromLink = sourcesWithInfo.fromLink;\n      concast = new Concast(sourcesWithInfo.sources);\n    }\n    concast.promise.then(cleanupCancelFn, cleanupCancelFn);\n    return {\n      concast: concast,\n      fromLink: containsDataFromLink\n    };\n  };\n  QueryManager.prototype.refetchQueries = function (_a) {\n    var _this = this;\n    var updateCache = _a.updateCache,\n      include = _a.include,\n      _b = _a.optimistic,\n      optimistic = _b === void 0 ? false : _b,\n      _c = _a.removeOptimistic,\n      removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId(\"refetchQueries\") : void 0 : _c,\n      onQueryUpdated = _a.onQueryUpdated;\n    var includedQueriesById = new Map();\n    if (include) {\n      this.getObservableQueries(include).forEach(function (oq, queryId) {\n        includedQueriesById.set(queryId, {\n          oq: oq,\n          lastDiff: _this.getQuery(queryId).getDiff()\n        });\n      });\n    }\n    var results = new Map();\n    if (updateCache) {\n      this.cache.batch({\n        update: updateCache,\n        optimistic: optimistic && removeOptimistic || false,\n        removeOptimistic: removeOptimistic,\n        onWatchUpdated: function onWatchUpdated(watch, diff, lastDiff) {\n          var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;\n          if (oq) {\n            if (onQueryUpdated) {\n              includedQueriesById.delete(oq.queryId);\n              var result = onQueryUpdated(oq, diff, lastDiff);\n              if (result === true) {\n                result = oq.refetch();\n              }\n              if (result !== false) {\n                results.set(oq, result);\n              }\n              return result;\n            }\n            if (onQueryUpdated !== null) {\n              includedQueriesById.set(oq.queryId, {\n                oq: oq,\n                lastDiff: lastDiff,\n                diff: diff\n              });\n            }\n          }\n        }\n      });\n    }\n    if (includedQueriesById.size) {\n      includedQueriesById.forEach(function (_a, queryId) {\n        var oq = _a.oq,\n          lastDiff = _a.lastDiff,\n          diff = _a.diff;\n        var result;\n        if (onQueryUpdated) {\n          if (!diff) {\n            var info = oq[\"queryInfo\"];\n            info.reset();\n            diff = info.getDiff();\n          }\n          result = onQueryUpdated(oq, diff, lastDiff);\n        }\n        if (!onQueryUpdated || result === true) {\n          result = oq.refetch();\n        }\n        if (result !== false) {\n          results.set(oq, result);\n        }\n        if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n          _this.stopQueryNoBroadcast(queryId);\n        }\n      });\n    }\n    if (removeOptimistic) {\n      this.cache.removeOptimistic(removeOptimistic);\n    }\n    return results;\n  };\n  QueryManager.prototype.fetchQueryByPolicy = function (queryInfo, _a, networkStatus) {\n    var _this = this;\n    var query = _a.query,\n      variables = _a.variables,\n      fetchPolicy = _a.fetchPolicy,\n      refetchWritePolicy = _a.refetchWritePolicy,\n      errorPolicy = _a.errorPolicy,\n      returnPartialData = _a.returnPartialData,\n      context = _a.context,\n      notifyOnNetworkStatusChange = _a.notifyOnNetworkStatusChange;\n    var oldNetworkStatus = queryInfo.networkStatus;\n    queryInfo.init({\n      document: this.transform(query).document,\n      variables: variables,\n      networkStatus: networkStatus\n    });\n    var readCache = function readCache() {\n      return queryInfo.getDiff(variables);\n    };\n    var resultsFromCache = function resultsFromCache(diff, networkStatus) {\n      if (networkStatus === void 0) {\n        networkStatus = queryInfo.networkStatus || NetworkStatus.loading;\n      }\n      var data = diff.result;\n      if (__DEV__ && !returnPartialData && !equal(data, {})) {\n        logMissingFieldErrors(diff.missing);\n      }\n      var fromData = function fromData(data) {\n        return Observable.of(__assign({\n          data: data,\n          loading: isNetworkRequestInFlight(networkStatus),\n          networkStatus: networkStatus\n        }, diff.complete ? null : {\n          partial: true\n        }));\n      };\n      if (data && _this.transform(query).hasForcedResolvers) {\n        return _this.localState.runResolvers({\n          document: query,\n          remoteResult: {\n            data: data\n          },\n          context: context,\n          variables: variables,\n          onlyRunForcedResolvers: true\n        }).then(function (resolved) {\n          return fromData(resolved.data || void 0);\n        });\n      }\n      if (errorPolicy === 'none' && networkStatus === NetworkStatus.refetch && Array.isArray(diff.missing)) {\n        return fromData(void 0);\n      }\n      return fromData(data);\n    };\n    var cacheWriteBehavior = fetchPolicy === \"no-cache\" ? 0 : networkStatus === NetworkStatus.refetch && refetchWritePolicy !== \"merge\" ? 1 : 2;\n    var resultsFromLink = function resultsFromLink() {\n      return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {\n        variables: variables,\n        context: context,\n        fetchPolicy: fetchPolicy,\n        errorPolicy: errorPolicy\n      });\n    };\n    var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === \"number\" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus);\n    switch (fetchPolicy) {\n      default:\n      case \"cache-first\":\n        {\n          var diff = readCache();\n          if (diff.complete) {\n            return {\n              fromLink: false,\n              sources: [resultsFromCache(diff, queryInfo.markReady())]\n            };\n          }\n          if (returnPartialData || shouldNotify) {\n            return {\n              fromLink: true,\n              sources: [resultsFromCache(diff), resultsFromLink()]\n            };\n          }\n          return {\n            fromLink: true,\n            sources: [resultsFromLink()]\n          };\n        }\n      case \"cache-and-network\":\n        {\n          var diff = readCache();\n          if (diff.complete || returnPartialData || shouldNotify) {\n            return {\n              fromLink: true,\n              sources: [resultsFromCache(diff), resultsFromLink()]\n            };\n          }\n          return {\n            fromLink: true,\n            sources: [resultsFromLink()]\n          };\n        }\n      case \"cache-only\":\n        return {\n          fromLink: false,\n          sources: [resultsFromCache(readCache(), queryInfo.markReady())]\n        };\n      case \"network-only\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(readCache()), resultsFromLink()]\n          };\n        }\n        return {\n          fromLink: true,\n          sources: [resultsFromLink()]\n        };\n      case \"no-cache\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()]\n          };\n        }\n        return {\n          fromLink: true,\n          sources: [resultsFromLink()]\n        };\n      case \"standby\":\n        return {\n          fromLink: false,\n          sources: []\n        };\n    }\n  };\n  QueryManager.prototype.getQuery = function (queryId) {\n    if (queryId && !this.queries.has(queryId)) {\n      this.queries.set(queryId, new QueryInfo(this, queryId));\n    }\n    return this.queries.get(queryId);\n  };\n  QueryManager.prototype.prepareContext = function (context) {\n    if (context === void 0) {\n      context = {};\n    }\n    var newContext = this.localState.prepareContext(context);\n    return __assign(__assign({}, newContext), {\n      clientAwareness: this.clientAwareness\n    });\n  };\n  return QueryManager;\n}();\nexport { QueryManager };","map":{"version":3,"names":["invariant","InvariantError","equal","execute","isExecutionPatchIncrementalResult","isExecutionPatchResult","canonicalStringify","getDefaultValues","getOperationDefinition","getOperationName","hasClientExports","graphQLResultHasError","getGraphQLErrorsFromResult","removeConnectionDirectiveFromDocument","canUseWeakMap","Observable","asyncMap","isNonEmptyArray","Concast","makeUniqueId","isDocumentNode","isNonNullObject","mergeIncrementalData","ApolloError","isApolloError","graphQLResultHasProtocolErrors","ObservableQuery","logMissingFieldErrors","NetworkStatus","isNetworkRequestInFlight","LocalState","QueryInfo","shouldWriteResult","PROTOCOL_ERRORS_SYMBOL","hasOwnProperty","Object","prototype","QueryManager","_a","cache","link","defaultOptions","_b","queryDeduplication","onBroadcast","_c","ssrMode","_d","clientAwareness","localState","assumeImmutableResults","queries","Map","fetchCancelFns","transformCache","WeakMap","queryIdCounter","requestIdCounter","mutationIdCounter","inFlightLinkObservables","create","mutationStore","stop","_this","forEach","_info","queryId","stopQueryNoBroadcast","cancelPendingFetches","__DEV__","error","cancel","clear","mutate","mutation","variables","optimisticResponse","updateQueries","refetchQueries","_e","awaitRefetchQueries","updateWithProxyFn","update","onQueryUpdated","_f","fetchPolicy","_g","errorPolicy","keepRootFields","context","mutationId","generateMutationId","_h","transform","document","transformForLink","getVariables","loading","markMutationOptimistic","broadcastQueries","self","Promise","resolve","reject","getObservableFromLink","__assign","result","graphQLErrors","mutationStoreValue","storeResult","errors","markMutationResult","removeOptimistic","next","hasNext","err","networkError","cacheWrites","skipCache","push","data","dataId","query","incremental","diff","id","asQuery","optimistic","returnPartialData","mergedData","updateQueries_1","observableQuery","queryName","call","updater","get","currentQueryResult","complete","nextQueryResult","mutationResult","queryVariables","length","results_1","updateCache","write","isFinalResult","modify","fields","value","fieldName","DELETE","include","all","then","recordOptimisticTransaction","fetchQuery","options","networkStatus","fetchQueryObservable","promise","getQueryStore","store","info","resetErrors","queryInfo","undefined","has","transformed","transformDocument","noConnection","clientQuery","serverQuery","cacheEntry_1","hasForcedResolvers","shouldForceResolvers","defaultVars","definitions","map","def","kind","operation","add","doc","set","watchQuery","notifyOnNetworkStatusChange","observable","queryManager","init","generateQueryId","pollInterval","finally","stopQuery","String","generateRequestId","stopQueryInStore","stopQueryInStoreNoBroadcast","clearStore","discardWatches","reset","getObservableQueries","queryNamesAndDocs","legacyQueryOptions","Set","Array","isArray","desc","oq","hasObservers","size","getQuery","setObservableQuery","included","nameOrDoc","warn","concat","JSON","stringify","reFetchObservableQueries","includeStandby","observableQueryPromises","resetLastResults","refetch","setDiff","startGraphQLSubscription","makeObservable","hasErrors","hasProtocolErrors","protocolErrors","extensions","observablePromise_1","addExportedVariables","observer","sub","subscribe","unsubscribe","removeQuery","delete","notify","getLocalState","deduplication","inFlightLinkObservables_1","operationName","prepareContext","forceFetch","byVariables_1","varJson_1","concast","beforeNext","of","runResolvers","remoteResult","getResultsFromLink","cacheWriteBehavior","requestId","lastRequestId","linkDocument","markError","markResult","markReady","aqr","ready","fetchConcastWithInfo","defaults","normalized","assign","fromVariables","sourcesWithInfo","fetchQueryByPolicy","sources","cleanupCancelFn","reason","setTimeout","containsDataFromLink","fromLink","includedQueriesById","lastDiff","getDiff","results","batch","onWatchUpdated","watch","watcher","indexOf","refetchWritePolicy","oldNetworkStatus","readCache","resultsFromCache","missing","fromData","partial","onlyRunForcedResolvers","resolved","resultsFromLink","shouldNotify","newContext"],"sources":["/data/stackhub-web/plugins/myapps/node_modules/@apollo/src/core/QueryManager.ts"],"sourcesContent":["import { invariant, InvariantError } from '../utilities/globals';\n\nimport { DocumentNode } from 'graphql';\n// TODO(brian): A hack until this issue is resolved (https://github.com/graphql/graphql-js/issues/3356)\ntype OperationTypeNode = any;\nimport { equal } from '@wry/equality';\n\nimport { ApolloLink, execute, FetchResult } from '../link/core';\nimport {\n  isExecutionPatchIncrementalResult,\n  isExecutionPatchResult,\n} from '../utilities/common/incrementalResult';\nimport { Cache, ApolloCache, canonicalStringify } from '../cache';\n\nimport {\n  getDefaultValues,\n  getOperationDefinition,\n  getOperationName,\n  hasClientExports,\n  graphQLResultHasError,\n  getGraphQLErrorsFromResult,\n  removeConnectionDirectiveFromDocument,\n  canUseWeakMap,\n  ObservableSubscription,\n  Observable,\n  asyncMap,\n  isNonEmptyArray,\n  Concast,\n  ConcastSourcesArray,\n  makeUniqueId,\n  isDocumentNode,\n  isNonNullObject,\n} from '../utilities';\nimport { mergeIncrementalData } from '../utilities/common/incrementalResult';\nimport { ApolloError, isApolloError, graphQLResultHasProtocolErrors } from '../errors';\nimport {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  ErrorPolicy,\n  MutationFetchPolicy,\n} from './watchQueryOptions';\nimport { ObservableQuery, logMissingFieldErrors } from './ObservableQuery';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport {\n  ApolloQueryResult,\n  OperationVariables,\n  MutationUpdaterFunction,\n  OnQueryUpdated,\n  InternalRefetchQueriesInclude,\n  InternalRefetchQueriesOptions,\n  InternalRefetchQueriesResult,\n  InternalRefetchQueriesMap,\n} from './types';\nimport { LocalState } from './LocalState';\n\nimport {\n  QueryInfo,\n  QueryStoreValue,\n  shouldWriteResult,\n  CacheWriteBehavior,\n} from './QueryInfo';\nimport { PROTOCOL_ERRORS_SYMBOL, ApolloErrorOptions } from '../errors';\n\nconst { hasOwnProperty } = Object.prototype;\n\ninterface MutationStoreValue {\n  mutation: DocumentNode;\n  variables: Record<string, any>;\n  loading: boolean;\n  error: Error | null;\n}\n\ntype UpdateQueries<TData> = MutationOptions<TData, any, any>[\"updateQueries\"];\n\ninterface TransformCacheEntry {\n  document: DocumentNode;\n  hasClientExports: boolean;\n  hasForcedResolvers: boolean;\n  clientQuery: DocumentNode | null;\n  serverQuery: DocumentNode | null;\n  defaultVars: OperationVariables;\n  asQuery: DocumentNode;\n}\n\ntype DefaultOptions = import(\"./ApolloClient\").DefaultOptions;\n\nexport class QueryManager<TStore> {\n  public cache: ApolloCache<TStore>;\n  public link: ApolloLink;\n  public defaultOptions: DefaultOptions;\n\n  public readonly assumeImmutableResults: boolean;\n  public readonly ssrMode: boolean;\n\n  private queryDeduplication: boolean;\n  private clientAwareness: Record<string, string> = {};\n  private localState: LocalState<TStore>;\n\n  private onBroadcast?: () => void;\n  public mutationStore?: {\n    [mutationId: string]: MutationStoreValue;\n  };\n\n  // All the queries that the QueryManager is currently managing (not\n  // including mutations and subscriptions).\n  private queries = new Map<string, QueryInfo>();\n\n  // Maps from queryId strings to Promise rejection functions for\n  // currently active queries and fetches.\n  private fetchCancelFns = new Map<string, (error: any) => any>();\n\n  constructor({\n    cache,\n    link,\n    defaultOptions,\n    queryDeduplication = false,\n    onBroadcast,\n    ssrMode = false,\n    clientAwareness = {},\n    localState,\n    assumeImmutableResults,\n  }: {\n    cache: ApolloCache<TStore>;\n    link: ApolloLink;\n    defaultOptions?: DefaultOptions;\n    queryDeduplication?: boolean;\n    onBroadcast?: () => void;\n    ssrMode?: boolean;\n    clientAwareness?: Record<string, string>;\n    localState?: LocalState<TStore>;\n    assumeImmutableResults?: boolean;\n  }) {\n    this.cache = cache;\n    this.link = link;\n    this.defaultOptions = defaultOptions || Object.create(null);\n    this.queryDeduplication = queryDeduplication;\n    this.clientAwareness = clientAwareness;\n    this.localState = localState || new LocalState({ cache });\n    this.ssrMode = ssrMode;\n    this.assumeImmutableResults = !!assumeImmutableResults;\n    if ((this.onBroadcast = onBroadcast)) {\n      this.mutationStore = Object.create(null);\n    }\n  }\n\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  public stop() {\n    this.queries.forEach((_info, queryId) => {\n      this.stopQueryNoBroadcast(queryId);\n    });\n\n    this.cancelPendingFetches(\n      new InvariantError('QueryManager stopped while query was in flight'),\n    );\n  }\n\n  private cancelPendingFetches(error: Error) {\n    this.fetchCancelFns.forEach(cancel => cancel(error));\n    this.fetchCancelFns.clear();\n  }\n\n  public async mutate<\n    TData,\n    TVariables extends OperationVariables,\n    TContext extends Record<string, any>,\n    TCache extends ApolloCache<any>\n  >({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    onQueryUpdated,\n    fetchPolicy = this.defaultOptions.mutate?.fetchPolicy || \"network-only\",\n    errorPolicy = this.defaultOptions.mutate?.errorPolicy || \"none\",\n    keepRootFields,\n    context,\n  }: MutationOptions<TData, TVariables, TContext>): Promise<FetchResult<TData>> {\n    invariant(\n      mutation,\n      'mutation option is required. You must specify your GraphQL document in the mutation option.',\n    );\n\n    invariant(\n      fetchPolicy === 'network-only' ||\n      fetchPolicy === 'no-cache',\n      \"Mutations support only 'network-only' or 'no-cache' fetchPolicy strings. The default `network-only` behavior automatically writes mutation results to the cache. Passing `no-cache` skips the cache write.\"\n    );\n\n    const mutationId = this.generateMutationId();\n\n    const {\n      document,\n      hasClientExports,\n    } = this.transform(mutation);\n    mutation = this.cache.transformForLink(document);\n\n    variables = this.getVariables(mutation, variables) as TVariables;\n    if (hasClientExports) {\n      variables = await this.localState.addExportedVariables(mutation, variables, context) as TVariables;\n    }\n\n    const mutationStoreValue =\n      this.mutationStore &&\n      (this.mutationStore[mutationId] = {\n        mutation,\n        variables,\n        loading: true,\n        error: null,\n      } as MutationStoreValue);\n\n    if (optimisticResponse) {\n      this.markMutationOptimistic<\n        TData,\n        TVariables,\n        TContext,\n        TCache\n      >(optimisticResponse, {\n        mutationId,\n        document: mutation,\n        variables,\n        fetchPolicy,\n        errorPolicy,\n        context,\n        updateQueries,\n        update: updateWithProxyFn,\n        keepRootFields,\n      });\n    }\n\n    this.broadcastQueries();\n\n    const self = this;\n\n    return new Promise((resolve, reject) => {\n      return asyncMap(\n        self.getObservableFromLink(\n          mutation,\n          {\n            ...context,\n            optimisticResponse,\n          },\n          variables,\n          false,\n        ),\n\n        (result: FetchResult<TData>) => {\n          if (graphQLResultHasError(result) && errorPolicy === 'none') {\n            throw new ApolloError({\n              graphQLErrors: getGraphQLErrorsFromResult(result),\n            });\n          }\n\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = null;\n          }\n\n          const storeResult: typeof result = { ...result };\n\n          if (typeof refetchQueries === \"function\") {\n            refetchQueries = refetchQueries(storeResult);\n          }\n\n          if (errorPolicy === 'ignore' &&\n              graphQLResultHasError(storeResult)) {\n            delete storeResult.errors;\n          }\n\n          return self.markMutationResult<\n            TData,\n            TVariables,\n            TContext,\n            TCache\n          >({\n            mutationId,\n            result: storeResult,\n            document: mutation,\n            variables,\n            fetchPolicy,\n            errorPolicy,\n            context,\n            update: updateWithProxyFn,\n            updateQueries,\n            awaitRefetchQueries,\n            refetchQueries,\n            removeOptimistic: optimisticResponse ? mutationId : void 0,\n            onQueryUpdated,\n            keepRootFields,\n          });\n        },\n\n      ).subscribe({\n        next(storeResult) {\n          self.broadcastQueries();\n\n          // Since mutations might receive multiple payloads from the\n          // ApolloLink chain (e.g. when used with @defer),\n          // we resolve with a SingleExecutionResult or after the final\n          // ExecutionPatchResult has arrived and we have assembled the\n          // multipart response into a single result.\n          if (!('hasNext' in storeResult) || storeResult.hasNext === false) {\n            resolve(storeResult);\n          }\n        },\n\n        error(err: Error) {\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = err;\n          }\n\n          if (optimisticResponse) {\n            self.cache.removeOptimistic(mutationId);\n          }\n\n          self.broadcastQueries();\n\n          reject(\n            err instanceof ApolloError ? err : new ApolloError({\n              networkError: err,\n            }),\n          );\n        },\n      });\n    });\n  }\n\n  public markMutationResult<\n    TData,\n    TVariables,\n    TContext,\n    TCache extends ApolloCache<any>\n  >(\n    mutation: {\n      mutationId: string;\n      result: FetchResult<TData>;\n      document: DocumentNode;\n      variables?: TVariables;\n      fetchPolicy?: MutationFetchPolicy;\n      errorPolicy: ErrorPolicy;\n      context?: TContext;\n      updateQueries: UpdateQueries<TData>;\n      update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;\n      awaitRefetchQueries?: boolean;\n      refetchQueries?: InternalRefetchQueriesInclude;\n      removeOptimistic?: string;\n      onQueryUpdated?: OnQueryUpdated<any>;\n      keepRootFields?: boolean;\n    },\n    cache = this.cache,\n  ): Promise<FetchResult<TData>> {\n    let { result } = mutation;\n    const cacheWrites: Cache.WriteOptions[] = [];\n    const skipCache = mutation.fetchPolicy === \"no-cache\";\n\n    if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n      if (!isExecutionPatchIncrementalResult(result)) {\n        cacheWrites.push({\n          result: result.data,\n          dataId: 'ROOT_MUTATION',\n          query: mutation.document,\n          variables: mutation.variables,\n        });\n      }\n      if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {\n        const diff = cache.diff<TData>({\n          id: \"ROOT_MUTATION\",\n          // The cache complains if passed a mutation where it expects a\n          // query, so we transform mutations and subscriptions to queries\n          // (only once, thanks to this.transformCache).\n          query: this.transform(mutation.document).asQuery,\n          variables: mutation.variables,\n          optimistic: false,\n          returnPartialData: true,\n        });\n        let mergedData;\n        if (diff.result) {\n          mergedData = mergeIncrementalData(diff.result, result);\n        }\n        if (typeof mergedData !== 'undefined') {\n          // cast the ExecutionPatchResult to FetchResult here since\n          // ExecutionPatchResult never has `data` when returned from the server\n          (result as FetchResult).data = mergedData;\n          cacheWrites.push({\n            result: mergedData,\n            dataId: 'ROOT_MUTATION',\n            query: mutation.document,\n            variables: mutation.variables,\n          })\n        }\n      }\n\n      const { updateQueries } = mutation;\n      if (updateQueries) {\n        this.queries.forEach(({ observableQuery }, queryId) => {\n          const queryName = observableQuery && observableQuery.queryName;\n          if (!queryName || !hasOwnProperty.call(updateQueries, queryName)) {\n            return;\n          }\n          const updater = updateQueries[queryName];\n          const { document, variables } = this.queries.get(queryId)!;\n\n          // Read the current query result from the store.\n          const { result: currentQueryResult, complete } = cache.diff<TData>({\n            query: document!,\n            variables,\n            returnPartialData: true,\n            optimistic: false,\n          });\n\n          if (complete && currentQueryResult) {\n            // Run our reducer using the current query result and the mutation result.\n            const nextQueryResult = updater(currentQueryResult, {\n              mutationResult: result,\n              queryName: document && getOperationName(document) || void 0,\n              queryVariables: variables!,\n            });\n\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: 'ROOT_QUERY',\n                query: document!,\n                variables,\n              });\n            }\n          }\n        });\n      }\n    }\n\n    if (\n      cacheWrites.length > 0 ||\n      mutation.refetchQueries ||\n      mutation.update ||\n      mutation.onQueryUpdated ||\n      mutation.removeOptimistic\n    ) {\n      const results: any[] = [];\n\n      this.refetchQueries({\n        updateCache: (cache: TCache) => {\n          if (!skipCache) {\n            cacheWrites.forEach(write => cache.write(write));\n          }\n\n          // If the mutation has some writes associated with it then we need to\n          // apply those writes to the store by running this reducer again with\n          // a write action.\n          const { update } = mutation;\n          // Determine whether result is a SingleExecutionResult,\n          // or the final ExecutionPatchResult.\n          const isFinalResult =\n            !isExecutionPatchResult(result) ||\n            (isExecutionPatchIncrementalResult(result) && !result.hasNext);\n\n          if (update) {\n            if (!skipCache) {\n              // Re-read the ROOT_MUTATION data we just wrote into the cache\n              // (the first cache.write call in the cacheWrites.forEach loop\n              // above), so field read functions have a chance to run for\n              // fields within mutation result objects.\n              const diff = cache.diff<TData>({\n                id: \"ROOT_MUTATION\",\n                // The cache complains if passed a mutation where it expects a\n                // query, so we transform mutations and subscriptions to queries\n                // (only once, thanks to this.transformCache).\n                query: this.transform(mutation.document).asQuery,\n                variables: mutation.variables,\n                optimistic: false,\n                returnPartialData: true,\n              });\n\n              if (diff.complete) {\n                result = { ...result as FetchResult, data: diff.result };\n                if ('incremental' in result) {\n                  delete result.incremental;\n                }\n                if ('hasNext' in result) {\n                  delete result.hasNext;\n                }\n              }\n            }\n\n            // If we've received the whole response,\n            // either a SingleExecutionResult or the final ExecutionPatchResult,\n            // call the update function.\n            if (isFinalResult) {\n              update(cache, result, {\n                context: mutation.context,\n                variables: mutation.variables,\n              });\n            }\n          }\n\n          // TODO Do this with cache.evict({ id: 'ROOT_MUTATION' }) but make it\n          // shallow to allow rolling back optimistic evictions.\n          if (!skipCache && !mutation.keepRootFields && isFinalResult) {\n            cache.modify({\n              id: 'ROOT_MUTATION',\n              fields(value, { fieldName, DELETE }) {\n                return fieldName === \"__typename\" ? value : DELETE;\n              },\n            });\n          }\n        },\n\n        include: mutation.refetchQueries,\n\n        // Write the final mutation.result to the root layer of the cache.\n        optimistic: false,\n\n        // Remove the corresponding optimistic layer at the same time as we\n        // write the final non-optimistic result.\n        removeOptimistic: mutation.removeOptimistic,\n\n        // Let the caller of client.mutate optionally determine the refetching\n        // behavior for watched queries after the mutation.update function runs.\n        // If no onQueryUpdated function was provided for this mutation, pass\n        // null instead of undefined to disable the default refetching behavior.\n        onQueryUpdated: mutation.onQueryUpdated || null,\n\n      }).forEach(result => results.push(result));\n\n      if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n        // Returning a promise here makes the mutation await that promise, so we\n        // include results in that promise's work if awaitRefetchQueries or an\n        // onQueryUpdated function was specified.\n        return Promise.all(results).then(() => result);\n      }\n    }\n\n    return Promise.resolve(result);\n  }\n\n  public markMutationOptimistic<TData, TVariables, TContext, TCache extends ApolloCache<any>>(\n    optimisticResponse: any,\n    mutation: {\n      mutationId: string;\n      document: DocumentNode;\n      variables?: TVariables;\n      fetchPolicy?: MutationFetchPolicy;\n      errorPolicy: ErrorPolicy;\n      context?: TContext;\n      updateQueries: UpdateQueries<TData>,\n      update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;\n      keepRootFields?: boolean,\n    },\n  ) {\n    const data = typeof optimisticResponse === \"function\"\n      ? optimisticResponse(mutation.variables)\n      : optimisticResponse;\n\n    return this.cache.recordOptimisticTransaction(cache => {\n      try {\n        this.markMutationResult<TData, TVariables, TContext, TCache>({\n          ...mutation,\n          result: { data },\n        }, cache);\n      } catch (error) {\n        invariant.error(error);\n      }\n    }, mutation.mutationId);\n  }\n\n  public fetchQuery<TData, TVars extends OperationVariables>(\n    queryId: string,\n    options: WatchQueryOptions<TVars, TData>,\n    networkStatus?: NetworkStatus,\n  ): Promise<ApolloQueryResult<TData>> {\n    return this.fetchQueryObservable<TData, TVars>(\n      queryId,\n      options,\n      networkStatus,\n    ).promise;\n  }\n\n  public getQueryStore() {\n    const store: Record<string, QueryStoreValue> = Object.create(null);\n    this.queries.forEach((info, queryId) => {\n      store[queryId] = {\n        variables: info.variables,\n        networkStatus: info.networkStatus,\n        networkError: info.networkError,\n        graphQLErrors: info.graphQLErrors,\n      };\n    });\n    return store;\n  }\n\n  public resetErrors(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) {\n      queryInfo.networkError = undefined;\n      queryInfo.graphQLErrors = [];\n    }\n  }\n\n  private transformCache = new (\n    canUseWeakMap ? WeakMap : Map\n  )<DocumentNode, TransformCacheEntry>();\n\n  public transform(document: DocumentNode) {\n    const { transformCache } = this;\n\n    if (!transformCache.has(document)) {\n      const transformed = this.cache.transformDocument(document);\n      const noConnection = removeConnectionDirectiveFromDocument(transformed);\n      const clientQuery = this.localState.clientQuery(transformed);\n      const serverQuery = noConnection && this.localState.serverQuery(noConnection);\n\n      const cacheEntry: TransformCacheEntry = {\n        document: transformed,\n        // TODO These two calls (hasClientExports and shouldForceResolvers)\n        // could probably be merged into a single traversal.\n        hasClientExports: hasClientExports(transformed),\n        hasForcedResolvers: this.localState.shouldForceResolvers(transformed),\n        clientQuery,\n        serverQuery,\n        defaultVars: getDefaultValues(\n          getOperationDefinition(transformed)\n        ) as OperationVariables,\n        // Transform any mutation or subscription operations to query operations\n        // so we can read/write them from/to the cache.\n        asQuery: {\n          ...transformed,\n          definitions: transformed.definitions.map(def => {\n            if (def.kind === \"OperationDefinition\" &&\n                def.operation !== \"query\") {\n              return { ...def, operation: \"query\" as OperationTypeNode };\n            }\n            return def;\n          }),\n        }\n      };\n\n      const add = (doc: DocumentNode | null) => {\n        if (doc && !transformCache.has(doc)) {\n          transformCache.set(doc, cacheEntry);\n        }\n      }\n      // Add cacheEntry to the transformCache using several different keys,\n      // since any one of these documents could end up getting passed to the\n      // transform method again in the future.\n      add(document);\n      add(transformed);\n      add(clientQuery);\n      add(serverQuery);\n    }\n\n    return transformCache.get(document)!;\n  }\n\n  private getVariables<TVariables>(\n    document: DocumentNode,\n    variables?: TVariables,\n  ): OperationVariables {\n    return {\n      ...this.transform(document).defaultVars,\n      ...variables,\n    };\n  }\n\n  public watchQuery<T, TVariables extends OperationVariables = OperationVariables>(\n    options: WatchQueryOptions<TVariables, T>,\n  ): ObservableQuery<T, TVariables> {\n    // assign variable default values if supplied\n    options = {\n      ...options,\n      variables: this.getVariables(\n        options.query,\n        options.variables,\n      ) as TVariables,\n    };\n\n    if (typeof options.notifyOnNetworkStatusChange === 'undefined') {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    const queryInfo = new QueryInfo(this);\n    const observable = new ObservableQuery<T, TVariables>({\n      queryManager: this,\n      queryInfo,\n      options,\n    });\n\n    this.queries.set(observable.queryId, queryInfo);\n\n    queryInfo.init({\n      document: observable.query,\n      observableQuery: observable,\n      variables: observable.variables,\n    });\n\n    return observable;\n  }\n\n  public query<TData, TVars extends OperationVariables = OperationVariables>(\n    options: QueryOptions<TVars, TData>,\n    queryId = this.generateQueryId(),\n  ): Promise<ApolloQueryResult<TData>> {\n    invariant(\n      options.query,\n      'query option is required. You must specify your GraphQL document ' +\n        'in the query option.',\n    );\n\n    invariant(\n      options.query.kind === 'Document',\n      'You must wrap the query string in a \"gql\" tag.',\n    );\n\n    invariant(\n      !(options as any).returnPartialData,\n      'returnPartialData option only supported on watchQuery.',\n    );\n\n    invariant(\n      !(options as any).pollInterval,\n      'pollInterval option only supported on watchQuery.',\n    );\n\n    return this.fetchQuery<TData, TVars>(\n      queryId,\n      options,\n    ).finally(() => this.stopQuery(queryId));\n  }\n\n  private queryIdCounter = 1;\n  public generateQueryId() {\n    return String(this.queryIdCounter++);\n  }\n\n  private requestIdCounter = 1;\n  public generateRequestId() {\n    return this.requestIdCounter++;\n  }\n\n  private mutationIdCounter = 1;\n  public generateMutationId() {\n    return String(this.mutationIdCounter++);\n  }\n\n  public stopQueryInStore(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryInStoreNoBroadcast(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) queryInfo.stop();\n  }\n\n  public clearStore(options: Cache.ResetOptions = {\n    discardWatches: true,\n  }): Promise<void> {\n    // Before we have sent the reset action to the store, we can no longer\n    // rely on the results returned by in-flight requests since these may\n    // depend on values that previously existed in the data portion of the\n    // store. So, we cancel the promises and observers that we have issued\n    // so far and not yet resolved (in the case of queries).\n    this.cancelPendingFetches(new InvariantError(\n      'Store reset while query was in flight (not completed in link chain)',\n    ));\n\n    this.queries.forEach(queryInfo => {\n      if (queryInfo.observableQuery) {\n        // Set loading to true so listeners don't trigger unless they want\n        // results with partial data.\n        queryInfo.networkStatus = NetworkStatus.loading;\n      } else {\n        queryInfo.stop();\n      }\n    });\n\n    if (this.mutationStore) {\n      this.mutationStore = Object.create(null);\n    }\n\n    // begin removing data from the store\n    return this.cache.reset(options);\n  }\n\n  public getObservableQueries(\n    include: InternalRefetchQueriesInclude = \"active\",\n  ) {\n    const queries = new Map<string, ObservableQuery<any>>();\n    const queryNamesAndDocs = new Map<string | DocumentNode, boolean>();\n    const legacyQueryOptions = new Set<QueryOptions>();\n\n    if (Array.isArray(include)) {\n      include.forEach(desc => {\n        if (typeof desc === \"string\") {\n          queryNamesAndDocs.set(desc, false);\n        } else if (isDocumentNode(desc)) {\n          queryNamesAndDocs.set(this.transform(desc).document, false);\n        } else if (isNonNullObject(desc) && desc.query) {\n          legacyQueryOptions.add(desc);\n        }\n      });\n    }\n\n    this.queries.forEach(({ observableQuery: oq, document }, queryId) => {\n      if (oq) {\n        if (include === \"all\") {\n          queries.set(queryId, oq);\n          return;\n        }\n\n        const {\n          queryName,\n          options: { fetchPolicy },\n        } = oq;\n\n        if (\n          fetchPolicy === \"standby\" ||\n          (include === \"active\" && !oq.hasObservers())\n        ) {\n          return;\n        }\n\n        if (\n          include === \"active\" ||\n          (queryName && queryNamesAndDocs.has(queryName)) ||\n          (document && queryNamesAndDocs.has(document))\n        ) {\n          queries.set(queryId, oq);\n          if (queryName) queryNamesAndDocs.set(queryName, true);\n          if (document) queryNamesAndDocs.set(document, true);\n        }\n      }\n    });\n\n    if (legacyQueryOptions.size) {\n      legacyQueryOptions.forEach((options: QueryOptions) => {\n        // We will be issuing a fresh network request for this query, so we\n        // pre-allocate a new query ID here, using a special prefix to enable\n        // cleaning up these temporary queries later, after fetching.\n        const queryId = makeUniqueId(\"legacyOneTimeQuery\");\n        const queryInfo = this.getQuery(queryId).init({\n          document: options.query,\n          variables: options.variables,\n        });\n        const oq = new ObservableQuery({\n          queryManager: this,\n          queryInfo,\n          options: {\n            ...options,\n            fetchPolicy: \"network-only\",\n          },\n        });\n        invariant(oq.queryId === queryId);\n        queryInfo.setObservableQuery(oq);\n        queries.set(queryId, oq);\n      });\n    }\n\n    if (__DEV__ && queryNamesAndDocs.size) {\n      queryNamesAndDocs.forEach((included, nameOrDoc) => {\n        if (!included) {\n          invariant.warn(`Unknown query ${\n            typeof nameOrDoc === \"string\" ? \"named \" : \"\"\n          }${\n            JSON.stringify(nameOrDoc, null, 2)\n          } requested in refetchQueries options.include array`);\n        }\n      });\n    }\n\n    return queries;\n  }\n\n  public reFetchObservableQueries(\n    includeStandby: boolean = false,\n  ): Promise<ApolloQueryResult<any>[]> {\n    const observableQueryPromises: Promise<ApolloQueryResult<any>>[] = [];\n\n    this.getObservableQueries(\n      includeStandby ? \"all\" : \"active\"\n    ).forEach((observableQuery, queryId) => {\n      const { fetchPolicy } = observableQuery.options;\n      observableQuery.resetLastResults();\n      if (includeStandby ||\n          (fetchPolicy !== \"standby\" &&\n           fetchPolicy !== \"cache-only\")) {\n        observableQueryPromises.push(observableQuery.refetch());\n      }\n      this.getQuery(queryId).setDiff(null);\n    });\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public setObservableQuery(observableQuery: ObservableQuery<any, any>) {\n    this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\n  }\n\n  public startGraphQLSubscription<T = any>({\n    query,\n    fetchPolicy,\n    errorPolicy,\n    variables,\n    context = {},\n  }: SubscriptionOptions): Observable<FetchResult<T>> {\n    query = this.transform(query).document;\n    variables = this.getVariables(query, variables);\n\n    const makeObservable = (variables: OperationVariables) =>\n      this.getObservableFromLink<T>(\n        query,\n        context,\n        variables,\n      ).map(result => {\n        if (fetchPolicy !== 'no-cache') {\n          // the subscription interface should handle not sending us results we no longer subscribe to.\n          // XXX I don't think we ever send in an object with errors, but we might in the future...\n          if (shouldWriteResult(result, errorPolicy)) {\n            this.cache.write({\n              query,\n              result: result.data,\n              dataId: 'ROOT_SUBSCRIPTION',\n              variables: variables,\n            });\n          }\n\n          this.broadcastQueries();\n        }\n\n        const hasErrors = graphQLResultHasError(result);\n        const hasProtocolErrors = graphQLResultHasProtocolErrors(result);\n        if (hasErrors || hasProtocolErrors) {\n          const errors: ApolloErrorOptions = {};\n          if (hasErrors) {\n            errors.graphQLErrors = result.errors;\n          }\n          if (hasProtocolErrors) {\n            errors.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];\n          }\n          throw new ApolloError(errors);\n        }\n\n        return result;\n      });\n\n    if (this.transform(query).hasClientExports) {\n      const observablePromise = this.localState.addExportedVariables(\n        query,\n        variables,\n        context,\n      ).then(makeObservable);\n\n      return new Observable<FetchResult<T>>(observer => {\n        let sub: ObservableSubscription | null = null;\n        observablePromise.then(\n          observable => sub = observable.subscribe(observer),\n          observer.error,\n        );\n        return () => sub && sub.unsubscribe();\n      });\n    }\n\n    return makeObservable(variables);\n  }\n\n  public stopQuery(queryId: string) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryNoBroadcast(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  }\n\n  public removeQuery(queryId: string) {\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchCancelFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchCancelFns.delete(queryId);\n    if (this.queries.has(queryId)) {\n      this.getQuery(queryId).stop();\n      this.queries.delete(queryId);\n    }\n  }\n\n  public broadcastQueries() {\n    if (this.onBroadcast) this.onBroadcast();\n    this.queries.forEach(info => info.notify());\n  }\n\n  public getLocalState(): LocalState<TStore> {\n    return this.localState;\n  }\n\n  private inFlightLinkObservables = new Map<\n    DocumentNode,\n    Map<string, Observable<FetchResult>>\n  >();\n\n  private getObservableFromLink<T = any>(\n    query: DocumentNode,\n    context: any,\n    variables?: OperationVariables,\n    deduplication: boolean =\n      // Prefer context.queryDeduplication if specified.\n      context?.queryDeduplication ??\n      this.queryDeduplication,\n  ): Observable<FetchResult<T>> {\n    let observable: Observable<FetchResult<T>>;\n\n    const { serverQuery } = this.transform(query);\n    if (serverQuery) {\n      const { inFlightLinkObservables, link } = this;\n\n      const operation = {\n        query: serverQuery,\n        variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext({\n          ...context,\n          forceFetch: !deduplication\n        }),\n      };\n\n      context = operation.context;\n\n      if (deduplication) {\n        const byVariables = inFlightLinkObservables.get(serverQuery) || new Map();\n        inFlightLinkObservables.set(serverQuery, byVariables);\n\n        const varJson = canonicalStringify(variables);\n        observable = byVariables.get(varJson);\n\n        if (!observable) {\n          const concast = new Concast([\n            execute(link, operation) as Observable<FetchResult<T>>\n          ]);\n\n          byVariables.set(varJson, observable = concast);\n\n          concast.beforeNext(() => {\n            if (byVariables.delete(varJson) &&\n                byVariables.size < 1) {\n              inFlightLinkObservables.delete(serverQuery);\n            }\n          });\n        }\n\n      } else {\n        observable = new Concast([\n          execute(link, operation) as Observable<FetchResult<T>>\n        ]);\n      }\n    } else {\n      observable = new Concast([\n        Observable.of({ data: {} } as FetchResult<T>)\n      ]);\n      context = this.prepareContext(context);\n    }\n\n    const { clientQuery } = this.transform(query);\n    if (clientQuery) {\n      observable = asyncMap(observable, result => {\n        return this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context,\n          variables,\n        });\n      });\n    }\n\n    return observable;\n  }\n\n  private getResultsFromLink<TData, TVars extends OperationVariables>(\n    queryInfo: QueryInfo,\n    cacheWriteBehavior: CacheWriteBehavior,\n    options: Pick<WatchQueryOptions<TVars, TData>,\n      | \"variables\"\n      | \"context\"\n      | \"fetchPolicy\"\n      | \"errorPolicy\">,\n  ): Observable<ApolloQueryResult<TData>> {\n    const requestId = queryInfo.lastRequestId = this.generateRequestId();\n\n    // Performing transformForLink here gives this.cache a chance to fill in\n    // missing fragment definitions (for example) before sending this document\n    // through the link chain.\n    const linkDocument = this.cache.transformForLink(\n      // Use same document originally produced by this.cache.transformDocument.\n      this.transform(queryInfo.document!).document\n    );\n\n    return asyncMap(\n      this.getObservableFromLink(\n        linkDocument,\n        options.context,\n        options.variables,\n      ),\n\n      result => {\n        const graphQLErrors = getGraphQLErrorsFromResult(result);\n        const hasErrors = graphQLErrors.length > 0;\n\n        // If we interrupted this request by calling getResultsFromLink again\n        // with the same QueryInfo object, we ignore the old results.\n        if (requestId >= queryInfo.lastRequestId) {\n          if (hasErrors && options.errorPolicy === \"none\") {\n            // Throwing here effectively calls observer.error.\n            throw queryInfo.markError(new ApolloError({\n              graphQLErrors,\n            }));\n          }\n          // Use linkDocument rather than queryInfo.document so the\n          // operation/fragments used to write the result are the same as the\n          // ones used to obtain it from the link.\n          queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);\n          queryInfo.markReady();\n        }\n\n        const aqr: ApolloQueryResult<TData> = {\n          data: result.data,\n          loading: false,\n          networkStatus: NetworkStatus.ready,\n        };\n\n        if (hasErrors && options.errorPolicy !== \"ignore\") {\n          aqr.errors = graphQLErrors;\n          aqr.networkStatus = NetworkStatus.error;\n        }\n\n        return aqr;\n      },\n\n      networkError => {\n        const error = isApolloError(networkError)\n          ? networkError\n          : new ApolloError({ networkError });\n\n        // Avoid storing errors from older interrupted queries.\n        if (requestId >= queryInfo.lastRequestId) {\n          queryInfo.markError(error);\n        }\n\n        throw error;\n      },\n    );\n  }\n\n  public fetchQueryObservable<TData, TVars extends OperationVariables>(\n    queryId: string,\n    options: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus?: NetworkStatus,\n  ): Concast<ApolloQueryResult<TData>> {\n    return this.fetchConcastWithInfo(\n      queryId,\n      options,\n      networkStatus,\n    ).concast;\n  }\n\n  private fetchConcastWithInfo<TData, TVars extends OperationVariables>(\n    queryId: string,\n    options: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus = NetworkStatus.loading\n  ): ConcastAndInfo<TData> {\n    const query = this.transform(options.query).document;\n    const variables = this.getVariables(query, options.variables) as TVars;\n    const queryInfo = this.getQuery(queryId);\n\n    const defaults = this.defaultOptions.watchQuery;\n    let {\n      fetchPolicy = defaults && defaults.fetchPolicy || \"cache-first\",\n      errorPolicy = defaults && defaults.errorPolicy || \"none\",\n      returnPartialData = false,\n      notifyOnNetworkStatusChange = false,\n      context = {},\n    } = options;\n\n    const normalized = Object.assign({}, options, {\n      query,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      returnPartialData,\n      notifyOnNetworkStatusChange,\n      context,\n    });\n\n    const fromVariables = (variables: TVars) => {\n      // Since normalized is always a fresh copy of options, it's safe to\n      // modify its properties here, rather than creating yet another new\n      // WatchQueryOptions object.\n      normalized.variables = variables;\n\n      const sourcesWithInfo = this.fetchQueryByPolicy<TData, TVars>(\n        queryInfo,\n        normalized,\n        networkStatus,\n      );\n\n      if (\n        // If we're in standby, postpone advancing options.fetchPolicy using\n        // applyNextFetchPolicy.\n        normalized.fetchPolicy !== \"standby\" &&\n        // The \"standby\" policy currently returns [] from fetchQueryByPolicy, so\n        // this is another way to detect when nothing was done/fetched.\n        sourcesWithInfo.sources.length > 0 &&\n        queryInfo.observableQuery\n      ) {\n        queryInfo.observableQuery[\"applyNextFetchPolicy\"](\"after-fetch\", options);\n      }\n\n      return sourcesWithInfo;\n    };\n\n    // This cancel function needs to be set before the concast is created,\n    // in case concast creation synchronously cancels the request.\n    const cleanupCancelFn = () => this.fetchCancelFns.delete(queryId);\n    this.fetchCancelFns.set(queryId, reason => {\n      cleanupCancelFn();\n      // This delay ensures the concast variable has been initialized.\n      setTimeout(() => concast.cancel(reason));\n    });\n\n    let concast: Concast<ApolloQueryResult<TData>>,\n        containsDataFromLink: boolean;\n    // If the query has @export(as: ...) directives, then we need to\n    // process those directives asynchronously. When there are no\n    // @export directives (the common case), we deliberately avoid\n    // wrapping the result of this.fetchQueryByPolicy in a Promise,\n    // since the timing of result delivery is (unfortunately) important\n    // for backwards compatibility. TODO This code could be simpler if\n    // we deprecated and removed LocalState.\n    if (this.transform(normalized.query).hasClientExports) {\n      concast = new Concast(\n        this.localState\n          .addExportedVariables(normalized.query, normalized.variables, normalized.context)\n          .then(fromVariables).then(sourcesWithInfo => sourcesWithInfo.sources),\n      );\n      // there is just no way we can synchronously get the *right* value here,\n      // so we will assume `true`, which is the behaviour before the bug fix in\n      // #10597. This means that bug is not fixed in that case, and is probably\n      // un-fixable with reasonable effort for the edge case of @export as\n      // directives.\n      containsDataFromLink = true;\n    } else {\n      const sourcesWithInfo = fromVariables(normalized.variables);\n      containsDataFromLink = sourcesWithInfo.fromLink;\n      concast = new Concast(sourcesWithInfo.sources);\n    }\n\n    concast.promise.then(cleanupCancelFn, cleanupCancelFn);\n\n    return {\n      concast,\n      fromLink: containsDataFromLink,\n    };\n  }\n\n  public refetchQueries<TResult>({\n    updateCache,\n    include,\n    optimistic = false,\n    removeOptimistic = optimistic ? makeUniqueId(\"refetchQueries\") : void 0,\n    onQueryUpdated,\n  }: InternalRefetchQueriesOptions<ApolloCache<TStore>, TResult>\n  ): InternalRefetchQueriesMap<TResult> {\n    const includedQueriesById = new Map<string, {\n      oq: ObservableQuery<any>;\n      lastDiff?: Cache.DiffResult<any>;\n      diff?: Cache.DiffResult<any>;\n    }>();\n\n    if (include) {\n      this.getObservableQueries(include).forEach((oq, queryId) => {\n        includedQueriesById.set(queryId, {\n          oq,\n          lastDiff: this.getQuery(queryId).getDiff(),\n        });\n      });\n    }\n\n    const results: InternalRefetchQueriesMap<TResult> = new Map;\n\n    if (updateCache) {\n      this.cache.batch({\n        update: updateCache,\n\n        // Since you can perform any combination of cache reads and/or writes in\n        // the cache.batch update function, its optimistic option can be either\n        // a boolean or a string, representing three distinct modes of\n        // operation:\n        //\n        // * false: read/write only the root layer\n        // * true: read/write the topmost layer\n        // * string: read/write a fresh optimistic layer with that ID string\n        //\n        // When typeof optimistic === \"string\", a new optimistic layer will be\n        // temporarily created within cache.batch with that string as its ID. If\n        // we then pass that same string as the removeOptimistic option, we can\n        // make cache.batch immediately remove the optimistic layer after\n        // running the updateCache function, triggering only one broadcast.\n        //\n        // However, the refetchQueries method accepts only true or false for its\n        // optimistic option (not string). We interpret true to mean a temporary\n        // optimistic layer should be created, to allow efficiently rolling back\n        // the effect of the updateCache function, which involves passing a\n        // string instead of true as the optimistic option to cache.batch, when\n        // refetchQueries receives optimistic: true.\n        //\n        // In other words, we are deliberately not supporting the use case of\n        // writing to an *existing* optimistic layer (using the refetchQueries\n        // updateCache function), since that would potentially interfere with\n        // other optimistic updates in progress. Instead, you can read/write\n        // only the root layer by passing optimistic: false to refetchQueries,\n        // or you can read/write a brand new optimistic layer that will be\n        // automatically removed by passing optimistic: true.\n        optimistic: optimistic && removeOptimistic || false,\n\n        // The removeOptimistic option can also be provided by itself, even if\n        // optimistic === false, to remove some previously-added optimistic\n        // layer safely and efficiently, like we do in markMutationResult.\n        //\n        // If an explicit removeOptimistic string is provided with optimistic:\n        // true, the removeOptimistic string will determine the ID of the\n        // temporary optimistic layer, in case that ever matters.\n        removeOptimistic,\n\n        onWatchUpdated(watch, diff, lastDiff) {\n          const oq =\n            watch.watcher instanceof QueryInfo &&\n            watch.watcher.observableQuery;\n\n          if (oq) {\n            if (onQueryUpdated) {\n              // Since we're about to handle this query now, remove it from\n              // includedQueriesById, in case it was added earlier because of\n              // options.include.\n              includedQueriesById.delete(oq.queryId);\n\n              let result: TResult | boolean | Promise<ApolloQueryResult<any>> =\n                onQueryUpdated(oq, diff, lastDiff);\n\n              if (result === true) {\n                // The onQueryUpdated function requested the default refetching\n                // behavior by returning true.\n                result = oq.refetch();\n              }\n\n              // Record the result in the results Map, as long as onQueryUpdated\n              // did not return false to skip/ignore this result.\n              if (result !== false) {\n                results.set(oq, result as InternalRefetchQueriesResult<TResult>);\n              }\n\n              // Allow the default cache broadcast to happen, except when\n              // onQueryUpdated returns false.\n              return result;\n            }\n\n            if (onQueryUpdated !== null) {\n              // If we don't have an onQueryUpdated function, and onQueryUpdated\n              // was not disabled by passing null, make sure this query is\n              // \"included\" like any other options.include-specified query.\n              includedQueriesById.set(oq.queryId, { oq, lastDiff, diff });\n            }\n          }\n        },\n      });\n    }\n\n    if (includedQueriesById.size) {\n      includedQueriesById.forEach(({ oq, lastDiff, diff }, queryId) => {\n        let result: TResult | boolean | Promise<ApolloQueryResult<any>> | undefined;\n\n        // If onQueryUpdated is provided, we want to use it for all included\n        // queries, even the QueryOptions ones.\n        if (onQueryUpdated) {\n          if (!diff) {\n            const info = oq[\"queryInfo\"];\n            info.reset(); // Force info.getDiff() to read from cache.\n            diff = info.getDiff();\n          }\n          result = onQueryUpdated(oq, diff, lastDiff);\n        }\n\n        // Otherwise, we fall back to refetching.\n        if (!onQueryUpdated || result === true) {\n          result = oq.refetch();\n        }\n\n        if (result !== false) {\n          results.set(oq, result as InternalRefetchQueriesResult<TResult>);\n        }\n\n        if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n          this.stopQueryNoBroadcast(queryId);\n        }\n      });\n    }\n\n    if (removeOptimistic) {\n      // In case no updateCache callback was provided (so cache.batch was not\n      // called above, and thus did not already remove the optimistic layer),\n      // remove it here. Since this is a no-op when the layer has already been\n      // removed, we do it even if we called cache.batch above, since it's\n      // possible this.cache is an instance of some ApolloCache subclass other\n      // than InMemoryCache, and does not fully support the removeOptimistic\n      // option for cache.batch.\n      this.cache.removeOptimistic(removeOptimistic);\n    }\n\n    return results;\n  }\n\n  private fetchQueryByPolicy<TData, TVars extends OperationVariables>(\n    queryInfo: QueryInfo,\n    { query,\n      variables,\n      fetchPolicy,\n      refetchWritePolicy,\n      errorPolicy,\n      returnPartialData,\n      context,\n      notifyOnNetworkStatusChange,\n    }: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus: NetworkStatus\n  ): SourcesAndInfo<TData> {\n    const oldNetworkStatus = queryInfo.networkStatus;\n\n    queryInfo.init({\n      document: this.transform(query).document,\n      variables,\n      networkStatus,\n    });\n\n    const readCache = () => queryInfo.getDiff(variables);\n\n    const resultsFromCache = (\n      diff: Cache.DiffResult<TData>,\n      networkStatus = queryInfo.networkStatus || NetworkStatus.loading,\n    ) => {\n      const data = diff.result;\n\n      if (__DEV__ &&\n          !returnPartialData &&\n          !equal(data, {})) {\n        logMissingFieldErrors(diff.missing);\n      }\n\n      const fromData = (data: TData | undefined) => Observable.of({\n        data,\n        loading: isNetworkRequestInFlight(networkStatus),\n        networkStatus,\n        ...(diff.complete ? null : { partial: true }),\n      } as ApolloQueryResult<TData>);\n\n      if (data && this.transform(query).hasForcedResolvers) {\n        return this.localState.runResolvers({\n          document: query,\n          remoteResult: { data },\n          context,\n          variables,\n          onlyRunForcedResolvers: true,\n        }).then(resolved => fromData(resolved.data || void 0));\n      }\n\n      // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n      // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n      // data was incorrectly returned from the cache on refetch:\n      // if diff.missing exists, we should not return cache data.\n      if (\n        errorPolicy === 'none' &&\n        networkStatus === NetworkStatus.refetch &&\n        Array.isArray(diff.missing)\n      ) {\n        return fromData(void 0);\n      }\n\n      return fromData(data);\n    };\n\n    const cacheWriteBehavior =\n      fetchPolicy === \"no-cache\" ? CacheWriteBehavior.FORBID :\n      ( // Watched queries must opt into overwriting existing data on refetch,\n        // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n        networkStatus === NetworkStatus.refetch &&\n        refetchWritePolicy !== \"merge\"\n      ) ? CacheWriteBehavior.OVERWRITE\n        : CacheWriteBehavior.MERGE;\n\n    const resultsFromLink = () => this.getResultsFromLink<TData, TVars>(\n      queryInfo,\n      cacheWriteBehavior,\n      {\n        variables,\n        context,\n        fetchPolicy,\n        errorPolicy,\n      },\n    );\n\n    const shouldNotify =\n      notifyOnNetworkStatusChange &&\n      typeof oldNetworkStatus === \"number\" &&\n      oldNetworkStatus !== networkStatus &&\n      isNetworkRequestInFlight(networkStatus);\n\n    switch (fetchPolicy) {\n      default:  case \"cache-first\": {\n        const diff = readCache();\n\n        if (diff.complete) {\n          return { fromLink: false, sources: [resultsFromCache(diff, queryInfo.markReady())] };\n        }\n\n        if (returnPartialData || shouldNotify) {\n          return { fromLink: true, sources: [resultsFromCache(diff), resultsFromLink()] };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n      }\n\n      case \"cache-and-network\": {\n        const diff = readCache();\n\n        if (diff.complete || returnPartialData || shouldNotify) {\n          return { fromLink: true, sources: [resultsFromCache(diff), resultsFromLink()] };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n      }\n\n      case \"cache-only\":\n        return { fromLink: false, sources: [resultsFromCache(readCache(), queryInfo.markReady())] };\n\n      case \"network-only\":\n        if (shouldNotify) {\n          return { fromLink: true, sources: [resultsFromCache(readCache()), resultsFromLink()] };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n\n      case \"no-cache\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            // Note that queryInfo.getDiff() for no-cache queries does not call\n            // cache.diff, but instead returns a { complete: false } stub result\n            // when there is no queryInfo.diff already defined.\n            sources: [\n              resultsFromCache(queryInfo.getDiff()),\n              resultsFromLink(),\n            ],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n\n      case \"standby\":\n        return { fromLink: false, sources: [] };\n    }\n  }\n\n  private getQuery(queryId: string): QueryInfo {\n    if (queryId && !this.queries.has(queryId)) {\n      this.queries.set(queryId, new QueryInfo(this, queryId));\n    }\n    return this.queries.get(queryId)!;\n  }\n\n  private prepareContext(context = {}) {\n    const newContext = this.localState.prepareContext(context);\n    return {\n      ...newContext,\n      clientAwareness: this.clientAwareness,\n    };\n  }\n}\n\n// Return types used by fetchQueryByPolicy and other private methods above.\ninterface FetchConcastInfo {\n  // Metadata properties that can be returned in addition to the Concast.\n  fromLink: boolean;\n}\ninterface SourcesAndInfo<TData> extends FetchConcastInfo {\n  sources: ConcastSourcesArray<ApolloQueryResult<TData>>;\n}\ninterface ConcastAndInfo<TData> extends FetchConcastInfo {\n  concast: Concast<ApolloQueryResult<TData>>;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}