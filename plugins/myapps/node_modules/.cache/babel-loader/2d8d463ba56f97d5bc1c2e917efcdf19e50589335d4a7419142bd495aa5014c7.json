{"ast":null,"code":"import devAssert from \"../jsutils/devAssert.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { parse } from \"../language/parser.mjs\";\nimport { assertValidSDL } from \"../validation/validate.mjs\";\nimport { GraphQLSchema } from \"../type/schema.mjs\";\nimport { specifiedDirectives } from \"../type/directives.mjs\";\nimport { extendSchemaImpl } from \"./extendSchema.mjs\";\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function buildASTSchema(documentAST, options) {\n  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST.');\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    assertValidSDL(documentAST);\n  }\n  var emptySchemaConfig = {\n    description: undefined,\n    types: [],\n    directives: [],\n    extensions: undefined,\n    extensionASTNodes: [],\n    assumeValid: false\n  };\n  var config = extendSchemaImpl(emptySchemaConfig, documentAST, options);\n  if (config.astNode == null) {\n    for (var _i2 = 0, _config$types2 = config.types; _i2 < _config$types2.length; _i2++) {\n      var type = _config$types2[_i2];\n      switch (type.name) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        case 'Query':\n          config.query = type;\n          break;\n        case 'Mutation':\n          config.mutation = type;\n          break;\n        case 'Subscription':\n          config.subscription = type;\n          break;\n      }\n    }\n  }\n  var directives = config.directives; // If specified directives were not explicitly declared, add them.\n\n  var _loop = function _loop(_i4) {\n    var stdDirective = specifiedDirectives[_i4];\n    if (directives.every(function (directive) {\n      return directive.name !== stdDirective.name;\n    })) {\n      directives.push(stdDirective);\n    }\n  };\n  for (var _i4 = 0; _i4 < specifiedDirectives.length; _i4++) {\n    _loop(_i4);\n  }\n  return new GraphQLSchema(config);\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\nexport function buildSchema(source, options) {\n  var document = parse(source, {\n    noLocation: options === null || options === void 0 ? void 0 : options.noLocation,\n    allowLegacySDLEmptyFields: options === null || options === void 0 ? void 0 : options.allowLegacySDLEmptyFields,\n    allowLegacySDLImplementsInterfaces: options === null || options === void 0 ? void 0 : options.allowLegacySDLImplementsInterfaces,\n    experimentalFragmentVariables: options === null || options === void 0 ? void 0 : options.experimentalFragmentVariables\n  });\n  return buildASTSchema(document, {\n    commentDescriptions: options === null || options === void 0 ? void 0 : options.commentDescriptions,\n    assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  });\n}","map":{"version":3,"names":["devAssert","Kind","parse","assertValidSDL","GraphQLSchema","specifiedDirectives","extendSchemaImpl","buildASTSchema","documentAST","options","kind","DOCUMENT","assumeValid","assumeValidSDL","emptySchemaConfig","description","undefined","types","directives","extensions","extensionASTNodes","config","astNode","_i2","_config$types2","length","type","name","query","mutation","subscription","_loop","_i4","stdDirective","every","directive","push","buildSchema","source","document","noLocation","allowLegacySDLEmptyFields","allowLegacySDLImplementsInterfaces","experimentalFragmentVariables","commentDescriptions"],"sources":["/data/stackhub-web/plugins/myapps/node_modules/graphql/utilities/buildASTSchema.mjs"],"sourcesContent":["import devAssert from \"../jsutils/devAssert.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { parse } from \"../language/parser.mjs\";\nimport { assertValidSDL } from \"../validation/validate.mjs\";\nimport { GraphQLSchema } from \"../type/schema.mjs\";\nimport { specifiedDirectives } from \"../type/directives.mjs\";\nimport { extendSchemaImpl } from \"./extendSchema.mjs\";\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function buildASTSchema(documentAST, options) {\n  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST.');\n\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    assertValidSDL(documentAST);\n  }\n\n  var emptySchemaConfig = {\n    description: undefined,\n    types: [],\n    directives: [],\n    extensions: undefined,\n    extensionASTNodes: [],\n    assumeValid: false\n  };\n  var config = extendSchemaImpl(emptySchemaConfig, documentAST, options);\n\n  if (config.astNode == null) {\n    for (var _i2 = 0, _config$types2 = config.types; _i2 < _config$types2.length; _i2++) {\n      var type = _config$types2[_i2];\n\n      switch (type.name) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        case 'Query':\n          config.query = type;\n          break;\n\n        case 'Mutation':\n          config.mutation = type;\n          break;\n\n        case 'Subscription':\n          config.subscription = type;\n          break;\n      }\n    }\n  }\n\n  var directives = config.directives; // If specified directives were not explicitly declared, add them.\n\n  var _loop = function _loop(_i4) {\n    var stdDirective = specifiedDirectives[_i4];\n\n    if (directives.every(function (directive) {\n      return directive.name !== stdDirective.name;\n    })) {\n      directives.push(stdDirective);\n    }\n  };\n\n  for (var _i4 = 0; _i4 < specifiedDirectives.length; _i4++) {\n    _loop(_i4);\n  }\n\n  return new GraphQLSchema(config);\n}\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\nexport function buildSchema(source, options) {\n  var document = parse(source, {\n    noLocation: options === null || options === void 0 ? void 0 : options.noLocation,\n    allowLegacySDLEmptyFields: options === null || options === void 0 ? void 0 : options.allowLegacySDLEmptyFields,\n    allowLegacySDLImplementsInterfaces: options === null || options === void 0 ? void 0 : options.allowLegacySDLImplementsInterfaces,\n    experimentalFragmentVariables: options === null || options === void 0 ? void 0 : options.experimentalFragmentVariables\n  });\n  return buildASTSchema(document, {\n    commentDescriptions: options === null || options === void 0 ? void 0 : options.commentDescriptions,\n    assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}