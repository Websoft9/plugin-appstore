{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { parse } from 'graphql';\nvar docCache = new Map();\nvar fragmentSourceMap = new Map();\nvar printFragmentWarnings = true;\nvar experimentalFragmentVariables = false;\nfunction normalize(string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\nfunction cacheKeyFromLoc(loc) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\nfunction processFragments(ast) {\n  var seenKeys = new Set();\n  var definitions = [];\n  ast.definitions.forEach(function (fragmentDefinition) {\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n      var sourceKeySet = fragmentSourceMap.get(fragmentName);\n      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\" + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\" + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n      } else if (!sourceKeySet) {\n        fragmentSourceMap.set(fragmentName, sourceKeySet = new Set());\n      }\n      sourceKeySet.add(sourceKey);\n      if (!seenKeys.has(sourceKey)) {\n        seenKeys.add(sourceKey);\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  });\n  return __assign(__assign({}, ast), {\n    definitions: definitions\n  });\n}\nfunction stripLoc(doc) {\n  var workSet = new Set(doc.definitions);\n  workSet.forEach(function (node) {\n    if (node.loc) delete node.loc;\n    Object.keys(node).forEach(function (key) {\n      var value = node[key];\n      if (value && typeof value === 'object') {\n        workSet.add(value);\n      }\n    });\n  });\n  var loc = doc.loc;\n  if (loc) {\n    delete loc.startToken;\n    delete loc.endToken;\n  }\n  return doc;\n}\nfunction parseDocument(source) {\n  var cacheKey = normalize(source);\n  if (!docCache.has(cacheKey)) {\n    var parsed = parse(source, {\n      experimentalFragmentVariables: experimentalFragmentVariables,\n      allowLegacyFragmentVariables: experimentalFragmentVariables\n    });\n    if (!parsed || parsed.kind !== 'Document') {\n      throw new Error('Not a valid GraphQL document.');\n    }\n    docCache.set(cacheKey, stripLoc(processFragments(parsed)));\n  }\n  return docCache.get(cacheKey);\n}\nexport function gql(literals) {\n  var args = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    args[_i - 1] = arguments[_i];\n  }\n  if (typeof literals === 'string') {\n    literals = [literals];\n  }\n  var result = literals[0];\n  args.forEach(function (arg, i) {\n    if (arg && arg.kind === 'Document') {\n      result += arg.loc.source.body;\n    } else {\n      result += arg;\n    }\n    result += literals[i + 1];\n  });\n  return parseDocument(result);\n}\nexport function resetCaches() {\n  docCache.clear();\n  fragmentSourceMap.clear();\n}\nexport function disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\nexport function enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\nexport function disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\nvar extras = {\n  gql: gql,\n  resetCaches: resetCaches,\n  disableFragmentWarnings: disableFragmentWarnings,\n  enableExperimentalFragmentVariables: enableExperimentalFragmentVariables,\n  disableExperimentalFragmentVariables: disableExperimentalFragmentVariables\n};\n(function (gql_1) {\n  gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;\n})(gql || (gql = {}));\ngql[\"default\"] = gql;\nexport default gql;","map":{"version":3,"names":["parse","docCache","Map","fragmentSourceMap","printFragmentWarnings","experimentalFragmentVariables","normalize","string","replace","trim","cacheKeyFromLoc","loc","source","body","substring","start","end","processFragments","ast","seenKeys","Set","definitions","forEach","fragmentDefinition","kind","fragmentName","name","value","sourceKey","sourceKeySet","get","has","console","warn","set","add","push","__assign","stripLoc","doc","workSet","node","Object","keys","key","startToken","endToken","parseDocument","cacheKey","parsed","allowLegacyFragmentVariables","Error","gql","literals","args","_i","arguments","length","result","arg","i","resetCaches","clear","disableFragmentWarnings","enableExperimentalFragmentVariables","disableExperimentalFragmentVariables","extras","gql_1"],"sources":["/data/stackhub-web/plugins/myapps/node_modules/graphql-tag/src/index.ts"],"sourcesContent":["import { parse } from 'graphql';\n\nimport {\n  DocumentNode,\n  DefinitionNode,\n  Location,\n} from 'graphql/language/ast';\n\n// A map docString -> graphql document\nconst docCache = new Map<string, DocumentNode>();\n\n// A map fragmentName -> [normalized source]\nconst fragmentSourceMap = new Map<string, Set<string>>();\n\nlet printFragmentWarnings = true;\nlet experimentalFragmentVariables = false;\n\n// Strip insignificant whitespace\n// Note that this could do a lot more, such as reorder fields etc.\nfunction normalize(string: string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\nfunction cacheKeyFromLoc(loc: Location) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\n// Take a unstripped parsed document (query/mutation or even fragment), and\n// check all fragment definitions, checking for name->source uniqueness.\n// We also want to make sure only unique fragments exist in the document.\nfunction processFragments(ast: DocumentNode) {\n  const seenKeys = new Set<string>();\n  const definitions: DefinitionNode[] = [];\n\n  ast.definitions.forEach(fragmentDefinition => {\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc!);\n\n      // We know something about this fragment\n      let sourceKeySet = fragmentSourceMap.get(fragmentName)!;\n      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n        // this is a problem because the app developer is trying to register another fragment with\n        // the same name as one previously registered. So, we tell them about it.\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n            + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n            + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n      } else if (!sourceKeySet) {\n        fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);\n      }\n\n      sourceKeySet.add(sourceKey);\n\n      if (!seenKeys.has(sourceKey)) {\n        seenKeys.add(sourceKey);\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  });\n\n  return {\n    ...ast,\n    definitions,\n  };\n}\n\nfunction stripLoc(doc: DocumentNode) {\n  const workSet = new Set<Record<string, any>>(doc.definitions);\n\n  workSet.forEach(node => {\n    if (node.loc) delete node.loc;\n    Object.keys(node).forEach(key => {\n      const value = node[key];\n      if (value && typeof value === 'object') {\n        workSet.add(value);\n      }\n    });\n  });\n\n  const loc = doc.loc as Record<string, any>;\n  if (loc) {\n    delete loc.startToken;\n    delete loc.endToken;\n  }\n\n  return doc;\n}\n\nfunction parseDocument(source: string) {\n  var cacheKey = normalize(source);\n  if (!docCache.has(cacheKey)) {\n    const parsed = parse(source, {\n      experimentalFragmentVariables,\n      allowLegacyFragmentVariables: experimentalFragmentVariables,\n    } as any);\n    if (!parsed || parsed.kind !== 'Document') {\n      throw new Error('Not a valid GraphQL document.');\n    }\n    docCache.set(\n      cacheKey,\n      // check that all \"new\" fragments inside the documents are consistent with\n      // existing fragments of the same name\n      stripLoc(processFragments(parsed)),\n    );\n  }\n  return docCache.get(cacheKey)!;\n}\n\n// XXX This should eventually disallow arbitrary string interpolation, like Relay does\nexport function gql(\n  literals: string | readonly string[],\n  ...args: any[]\n) {\n\n  if (typeof literals === 'string') {\n    literals = [literals];\n  }\n\n  let result = literals[0];\n\n  args.forEach((arg, i) => {\n    if (arg && arg.kind === 'Document') {\n      result += arg.loc.source.body;\n    } else {\n      result += arg;\n    }\n    result += literals[i + 1];\n  });\n\n  return parseDocument(result);\n}\n\nexport function resetCaches() {\n  docCache.clear();\n  fragmentSourceMap.clear();\n}\n\nexport function disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\n\nexport function enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\n\nexport function disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\n\nconst extras = {\n  gql,\n  resetCaches,\n  disableFragmentWarnings,\n  enableExperimentalFragmentVariables,\n  disableExperimentalFragmentVariables,\n};\n\nexport namespace gql {\n  export const {\n    gql,\n    resetCaches,\n    disableFragmentWarnings,\n    enableExperimentalFragmentVariables,\n    disableExperimentalFragmentVariables,\n  } = extras;\n}\n\ngql.default = gql;\n\nexport default gql;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}