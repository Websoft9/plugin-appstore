{"ast":null,"code":"import { __assign, __extends, __rest } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { dep } from 'optimism';\nimport { equal } from '@wry/equality';\nimport { Trie } from '@wry/trie';\nimport { isReference, makeReference, DeepMerger, maybeDeepFreeze, canUseWeakMap, isNonNullObject } from \"../../utilities/index.js\";\nimport { hasOwn, fieldNameFromStoreName } from \"./helpers.js\";\nvar DELETE = Object.create(null);\nvar delModifier = function delModifier() {\n  return DELETE;\n};\nvar INVALIDATE = Object.create(null);\nvar EntityStore = function () {\n  function EntityStore(policies, group) {\n    var _this = this;\n    this.policies = policies;\n    this.group = group;\n    this.data = Object.create(null);\n    this.rootIds = Object.create(null);\n    this.refs = Object.create(null);\n    this.getFieldValue = function (objectOrReference, storeFieldName) {\n      return maybeDeepFreeze(isReference(objectOrReference) ? _this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]);\n    };\n    this.canRead = function (objOrRef) {\n      return isReference(objOrRef) ? _this.has(objOrRef.__ref) : typeof objOrRef === \"object\";\n    };\n    this.toReference = function (objOrIdOrRef, mergeIntoStore) {\n      if (typeof objOrIdOrRef === \"string\") {\n        return makeReference(objOrIdOrRef);\n      }\n      if (isReference(objOrIdOrRef)) {\n        return objOrIdOrRef;\n      }\n      var id = _this.policies.identify(objOrIdOrRef)[0];\n      if (id) {\n        var ref = makeReference(id);\n        if (mergeIntoStore) {\n          _this.merge(id, objOrIdOrRef);\n        }\n        return ref;\n      }\n    };\n  }\n  EntityStore.prototype.toObject = function () {\n    return __assign({}, this.data);\n  };\n  EntityStore.prototype.has = function (dataId) {\n    return this.lookup(dataId, true) !== void 0;\n  };\n  EntityStore.prototype.get = function (dataId, fieldName) {\n    this.group.depend(dataId, fieldName);\n    if (hasOwn.call(this.data, dataId)) {\n      var storeObject = this.data[dataId];\n      if (storeObject && hasOwn.call(storeObject, fieldName)) {\n        return storeObject[fieldName];\n      }\n    }\n    if (fieldName === \"__typename\" && hasOwn.call(this.policies.rootTypenamesById, dataId)) {\n      return this.policies.rootTypenamesById[dataId];\n    }\n    if (this instanceof Layer) {\n      return this.parent.get(dataId, fieldName);\n    }\n  };\n  EntityStore.prototype.lookup = function (dataId, dependOnExistence) {\n    if (dependOnExistence) this.group.depend(dataId, \"__exists\");\n    if (hasOwn.call(this.data, dataId)) {\n      return this.data[dataId];\n    }\n    if (this instanceof Layer) {\n      return this.parent.lookup(dataId, dependOnExistence);\n    }\n    if (this.policies.rootTypenamesById[dataId]) {\n      return Object.create(null);\n    }\n  };\n  EntityStore.prototype.merge = function (older, newer) {\n    var _this = this;\n    var dataId;\n    if (isReference(older)) older = older.__ref;\n    if (isReference(newer)) newer = newer.__ref;\n    var existing = typeof older === \"string\" ? this.lookup(dataId = older) : older;\n    var incoming = typeof newer === \"string\" ? this.lookup(dataId = newer) : newer;\n    if (!incoming) return;\n    __DEV__ ? invariant(typeof dataId === \"string\", \"store.merge expects a string ID\") : invariant(typeof dataId === \"string\", 1);\n    var merged = new DeepMerger(storeObjectReconciler).merge(existing, incoming);\n    this.data[dataId] = merged;\n    if (merged !== existing) {\n      delete this.refs[dataId];\n      if (this.group.caching) {\n        var fieldsToDirty_1 = Object.create(null);\n        if (!existing) fieldsToDirty_1.__exists = 1;\n        Object.keys(incoming).forEach(function (storeFieldName) {\n          if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {\n            fieldsToDirty_1[storeFieldName] = 1;\n            var fieldName = fieldNameFromStoreName(storeFieldName);\n            if (fieldName !== storeFieldName && !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {\n              fieldsToDirty_1[fieldName] = 1;\n            }\n            if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {\n              delete merged[storeFieldName];\n            }\n          }\n        });\n        if (fieldsToDirty_1.__typename && !(existing && existing.__typename) && this.policies.rootTypenamesById[dataId] === merged.__typename) {\n          delete fieldsToDirty_1.__typename;\n        }\n        Object.keys(fieldsToDirty_1).forEach(function (fieldName) {\n          return _this.group.dirty(dataId, fieldName);\n        });\n      }\n    }\n  };\n  EntityStore.prototype.modify = function (dataId, fields) {\n    var _this = this;\n    var storeObject = this.lookup(dataId);\n    if (storeObject) {\n      var changedFields_1 = Object.create(null);\n      var needToMerge_1 = false;\n      var allDeleted_1 = true;\n      var sharedDetails_1 = {\n        DELETE: DELETE,\n        INVALIDATE: INVALIDATE,\n        isReference: isReference,\n        toReference: this.toReference,\n        canRead: this.canRead,\n        readField: function readField(fieldNameOrOptions, from) {\n          return _this.policies.readField(typeof fieldNameOrOptions === \"string\" ? {\n            fieldName: fieldNameOrOptions,\n            from: from || makeReference(dataId)\n          } : fieldNameOrOptions, {\n            store: _this\n          });\n        }\n      };\n      Object.keys(storeObject).forEach(function (storeFieldName) {\n        var fieldName = fieldNameFromStoreName(storeFieldName);\n        var fieldValue = storeObject[storeFieldName];\n        if (fieldValue === void 0) return;\n        var modify = typeof fields === \"function\" ? fields : fields[storeFieldName] || fields[fieldName];\n        if (modify) {\n          var newValue = modify === delModifier ? DELETE : modify(maybeDeepFreeze(fieldValue), __assign(__assign({}, sharedDetails_1), {\n            fieldName: fieldName,\n            storeFieldName: storeFieldName,\n            storage: _this.getStorage(dataId, storeFieldName)\n          }));\n          if (newValue === INVALIDATE) {\n            _this.group.dirty(dataId, storeFieldName);\n          } else {\n            if (newValue === DELETE) newValue = void 0;\n            if (newValue !== fieldValue) {\n              changedFields_1[storeFieldName] = newValue;\n              needToMerge_1 = true;\n              fieldValue = newValue;\n            }\n          }\n        }\n        if (fieldValue !== void 0) {\n          allDeleted_1 = false;\n        }\n      });\n      if (needToMerge_1) {\n        this.merge(dataId, changedFields_1);\n        if (allDeleted_1) {\n          if (this instanceof Layer) {\n            this.data[dataId] = void 0;\n          } else {\n            delete this.data[dataId];\n          }\n          this.group.dirty(dataId, \"__exists\");\n        }\n        return true;\n      }\n    }\n    return false;\n  };\n  EntityStore.prototype.delete = function (dataId, fieldName, args) {\n    var _a;\n    var storeObject = this.lookup(dataId);\n    if (storeObject) {\n      var typename = this.getFieldValue(storeObject, \"__typename\");\n      var storeFieldName = fieldName && args ? this.policies.getStoreFieldName({\n        typename: typename,\n        fieldName: fieldName,\n        args: args\n      }) : fieldName;\n      return this.modify(dataId, storeFieldName ? (_a = {}, _a[storeFieldName] = delModifier, _a) : delModifier);\n    }\n    return false;\n  };\n  EntityStore.prototype.evict = function (options, limit) {\n    var evicted = false;\n    if (options.id) {\n      if (hasOwn.call(this.data, options.id)) {\n        evicted = this.delete(options.id, options.fieldName, options.args);\n      }\n      if (this instanceof Layer && this !== limit) {\n        evicted = this.parent.evict(options, limit) || evicted;\n      }\n      if (options.fieldName || evicted) {\n        this.group.dirty(options.id, options.fieldName || \"__exists\");\n      }\n    }\n    return evicted;\n  };\n  EntityStore.prototype.clear = function () {\n    this.replace(null);\n  };\n  EntityStore.prototype.extract = function () {\n    var _this = this;\n    var obj = this.toObject();\n    var extraRootIds = [];\n    this.getRootIdSet().forEach(function (id) {\n      if (!hasOwn.call(_this.policies.rootTypenamesById, id)) {\n        extraRootIds.push(id);\n      }\n    });\n    if (extraRootIds.length) {\n      obj.__META = {\n        extraRootIds: extraRootIds.sort()\n      };\n    }\n    return obj;\n  };\n  EntityStore.prototype.replace = function (newData) {\n    var _this = this;\n    Object.keys(this.data).forEach(function (dataId) {\n      if (!(newData && hasOwn.call(newData, dataId))) {\n        _this.delete(dataId);\n      }\n    });\n    if (newData) {\n      var __META = newData.__META,\n        rest_1 = __rest(newData, [\"__META\"]);\n      Object.keys(rest_1).forEach(function (dataId) {\n        _this.merge(dataId, rest_1[dataId]);\n      });\n      if (__META) {\n        __META.extraRootIds.forEach(this.retain, this);\n      }\n    }\n  };\n  EntityStore.prototype.retain = function (rootId) {\n    return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;\n  };\n  EntityStore.prototype.release = function (rootId) {\n    if (this.rootIds[rootId] > 0) {\n      var count = --this.rootIds[rootId];\n      if (!count) delete this.rootIds[rootId];\n      return count;\n    }\n    return 0;\n  };\n  EntityStore.prototype.getRootIdSet = function (ids) {\n    if (ids === void 0) {\n      ids = new Set();\n    }\n    Object.keys(this.rootIds).forEach(ids.add, ids);\n    if (this instanceof Layer) {\n      this.parent.getRootIdSet(ids);\n    } else {\n      Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);\n    }\n    return ids;\n  };\n  EntityStore.prototype.gc = function () {\n    var _this = this;\n    var ids = this.getRootIdSet();\n    var snapshot = this.toObject();\n    ids.forEach(function (id) {\n      if (hasOwn.call(snapshot, id)) {\n        Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);\n        delete snapshot[id];\n      }\n    });\n    var idsToRemove = Object.keys(snapshot);\n    if (idsToRemove.length) {\n      var root_1 = this;\n      while (root_1 instanceof Layer) root_1 = root_1.parent;\n      idsToRemove.forEach(function (id) {\n        return root_1.delete(id);\n      });\n    }\n    return idsToRemove;\n  };\n  EntityStore.prototype.findChildRefIds = function (dataId) {\n    if (!hasOwn.call(this.refs, dataId)) {\n      var found_1 = this.refs[dataId] = Object.create(null);\n      var root = this.data[dataId];\n      if (!root) return found_1;\n      var workSet_1 = new Set([root]);\n      workSet_1.forEach(function (obj) {\n        if (isReference(obj)) {\n          found_1[obj.__ref] = true;\n        }\n        if (isNonNullObject(obj)) {\n          Object.keys(obj).forEach(function (key) {\n            var child = obj[key];\n            if (isNonNullObject(child)) {\n              workSet_1.add(child);\n            }\n          });\n        }\n      });\n    }\n    return this.refs[dataId];\n  };\n  EntityStore.prototype.makeCacheKey = function () {\n    return this.group.keyMaker.lookupArray(arguments);\n  };\n  return EntityStore;\n}();\nexport { EntityStore };\nvar CacheGroup = function () {\n  function CacheGroup(caching, parent) {\n    if (parent === void 0) {\n      parent = null;\n    }\n    this.caching = caching;\n    this.parent = parent;\n    this.d = null;\n    this.resetCaching();\n  }\n  CacheGroup.prototype.resetCaching = function () {\n    this.d = this.caching ? dep() : null;\n    this.keyMaker = new Trie(canUseWeakMap);\n  };\n  CacheGroup.prototype.depend = function (dataId, storeFieldName) {\n    if (this.d) {\n      this.d(makeDepKey(dataId, storeFieldName));\n      var fieldName = fieldNameFromStoreName(storeFieldName);\n      if (fieldName !== storeFieldName) {\n        this.d(makeDepKey(dataId, fieldName));\n      }\n      if (this.parent) {\n        this.parent.depend(dataId, storeFieldName);\n      }\n    }\n  };\n  CacheGroup.prototype.dirty = function (dataId, storeFieldName) {\n    if (this.d) {\n      this.d.dirty(makeDepKey(dataId, storeFieldName), storeFieldName === \"__exists\" ? \"forget\" : \"setDirty\");\n    }\n  };\n  return CacheGroup;\n}();\nfunction makeDepKey(dataId, storeFieldName) {\n  return storeFieldName + '#' + dataId;\n}\nexport function maybeDependOnExistenceOfEntity(store, entityId) {\n  if (supportsResultCaching(store)) {\n    store.group.depend(entityId, \"__exists\");\n  }\n}\n(function (EntityStore) {\n  var Root = function (_super) {\n    __extends(Root, _super);\n    function Root(_a) {\n      var policies = _a.policies,\n        _b = _a.resultCaching,\n        resultCaching = _b === void 0 ? true : _b,\n        seed = _a.seed;\n      var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;\n      _this.stump = new Stump(_this);\n      _this.storageTrie = new Trie(canUseWeakMap);\n      if (seed) _this.replace(seed);\n      return _this;\n    }\n    Root.prototype.addLayer = function (layerId, replay) {\n      return this.stump.addLayer(layerId, replay);\n    };\n    Root.prototype.removeLayer = function () {\n      return this;\n    };\n    Root.prototype.getStorage = function () {\n      return this.storageTrie.lookupArray(arguments);\n    };\n    return Root;\n  }(EntityStore);\n  EntityStore.Root = Root;\n})(EntityStore || (EntityStore = {}));\nvar Layer = function (_super) {\n  __extends(Layer, _super);\n  function Layer(id, parent, replay, group) {\n    var _this = _super.call(this, parent.policies, group) || this;\n    _this.id = id;\n    _this.parent = parent;\n    _this.replay = replay;\n    _this.group = group;\n    replay(_this);\n    return _this;\n  }\n  Layer.prototype.addLayer = function (layerId, replay) {\n    return new Layer(layerId, this, replay, this.group);\n  };\n  Layer.prototype.removeLayer = function (layerId) {\n    var _this = this;\n    var parent = this.parent.removeLayer(layerId);\n    if (layerId === this.id) {\n      if (this.group.caching) {\n        Object.keys(this.data).forEach(function (dataId) {\n          var ownStoreObject = _this.data[dataId];\n          var parentStoreObject = parent[\"lookup\"](dataId);\n          if (!parentStoreObject) {\n            _this.delete(dataId);\n          } else if (!ownStoreObject) {\n            _this.group.dirty(dataId, \"__exists\");\n            Object.keys(parentStoreObject).forEach(function (storeFieldName) {\n              _this.group.dirty(dataId, storeFieldName);\n            });\n          } else if (ownStoreObject !== parentStoreObject) {\n            Object.keys(ownStoreObject).forEach(function (storeFieldName) {\n              if (!equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {\n                _this.group.dirty(dataId, storeFieldName);\n              }\n            });\n          }\n        });\n      }\n      return parent;\n    }\n    if (parent === this.parent) return this;\n    return parent.addLayer(this.id, this.replay);\n  };\n  Layer.prototype.toObject = function () {\n    return __assign(__assign({}, this.parent.toObject()), this.data);\n  };\n  Layer.prototype.findChildRefIds = function (dataId) {\n    var fromParent = this.parent.findChildRefIds(dataId);\n    return hasOwn.call(this.data, dataId) ? __assign(__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;\n  };\n  Layer.prototype.getStorage = function () {\n    var p = this.parent;\n    while (p.parent) p = p.parent;\n    return p.getStorage.apply(p, arguments);\n  };\n  return Layer;\n}(EntityStore);\nvar Stump = function (_super) {\n  __extends(Stump, _super);\n  function Stump(root) {\n    return _super.call(this, \"EntityStore.Stump\", root, function () {}, new CacheGroup(root.group.caching, root.group)) || this;\n  }\n  Stump.prototype.removeLayer = function () {\n    return this;\n  };\n  Stump.prototype.merge = function () {\n    return this.parent.merge.apply(this.parent, arguments);\n  };\n  return Stump;\n}(Layer);\nfunction storeObjectReconciler(existingObject, incomingObject, property) {\n  var existingValue = existingObject[property];\n  var incomingValue = incomingObject[property];\n  return equal(existingValue, incomingValue) ? existingValue : incomingValue;\n}\nexport function supportsResultCaching(store) {\n  return !!(store instanceof EntityStore && store.group.caching);\n}","map":{"version":3,"names":["invariant","dep","equal","Trie","isReference","makeReference","DeepMerger","maybeDeepFreeze","canUseWeakMap","isNonNullObject","hasOwn","fieldNameFromStoreName","DELETE","Object","create","delModifier","INVALIDATE","EntityStore","policies","group","_this","data","rootIds","refs","getFieldValue","objectOrReference","storeFieldName","get","__ref","canRead","objOrRef","has","toReference","objOrIdOrRef","mergeIntoStore","id","identify","ref","merge","prototype","toObject","__assign","dataId","lookup","fieldName","depend","call","storeObject","rootTypenamesById","Layer","parent","dependOnExistence","older","newer","existing","incoming","__DEV__","merged","storeObjectReconciler","caching","fieldsToDirty_1","__exists","keys","forEach","hasKeyArgs","__typename","dirty","modify","fields","changedFields_1","needToMerge_1","allDeleted_1","sharedDetails_1","readField","fieldNameOrOptions","from","store","fieldValue","newValue","storage","getStorage","delete","args","typename","getStoreFieldName","_a","evict","options","limit","evicted","clear","replace","extract","obj","extraRootIds","getRootIdSet","push","length","__META","sort","newData","rest_1","__rest","retain","rootId","release","count","ids","Set","add","gc","snapshot","findChildRefIds","idsToRemove","root_1","found_1","root","workSet_1","key","child","makeCacheKey","keyMaker","lookupArray","arguments","CacheGroup","d","resetCaching","makeDepKey","maybeDependOnExistenceOfEntity","entityId","supportsResultCaching","Root","_super","__extends","_b","resultCaching","seed","stump","Stump","storageTrie","addLayer","layerId","replay","removeLayer","ownStoreObject","parentStoreObject","fromParent","p","apply","existingObject","incomingObject","property","existingValue","incomingValue"],"sources":["/data/stackhub-web/plugins/myapps/node_modules/@apollo/src/cache/inmemory/entityStore.ts"],"sourcesContent":["import { invariant } from '../../utilities/globals';\nimport { dep, OptimisticDependencyFunction } from 'optimism';\nimport { equal } from '@wry/equality';\nimport { Trie } from '@wry/trie';\n\nimport {\n  isReference,\n  StoreValue,\n  StoreObject,\n  Reference,\n  makeReference,\n  DeepMerger,\n  maybeDeepFreeze,\n  canUseWeakMap,\n  isNonNullObject,\n} from '../../utilities';\nimport { NormalizedCache, NormalizedCacheObject } from './types';\nimport { hasOwn, fieldNameFromStoreName } from './helpers';\nimport { Policies, StorageType } from './policies';\nimport { Cache } from '../core/types/Cache';\nimport {\n  SafeReadonly,\n  Modifier,\n  Modifiers,\n  ReadFieldOptions,\n  ToReferenceFunction,\n  CanReadFunction,\n} from '../core/types/common';\n\nconst DELETE: any = Object.create(null);\nconst delModifier: Modifier<any> = () => DELETE;\nconst INVALIDATE: any = Object.create(null);\n\nexport abstract class EntityStore implements NormalizedCache {\n  protected data: NormalizedCacheObject = Object.create(null);\n\n  constructor(\n    public readonly policies: Policies,\n    public readonly group: CacheGroup,\n  ) {}\n\n  public abstract addLayer(\n    layerId: string,\n    replay: (layer: EntityStore) => any,\n  ): Layer;\n\n  public abstract removeLayer(layerId: string): EntityStore;\n\n  // Although the EntityStore class is abstract, it contains concrete\n  // implementations of the various NormalizedCache interface methods that\n  // are inherited by the Root and Layer subclasses.\n\n  public toObject(): NormalizedCacheObject {\n    return { ...this.data };\n  }\n\n  public has(dataId: string): boolean {\n    return this.lookup(dataId, true) !== void 0;\n  }\n\n  public get(dataId: string, fieldName: string): StoreValue {\n    this.group.depend(dataId, fieldName);\n    if (hasOwn.call(this.data, dataId)) {\n      const storeObject = this.data[dataId];\n      if (storeObject && hasOwn.call(storeObject, fieldName)) {\n        return storeObject[fieldName];\n      }\n    }\n    if (fieldName === \"__typename\" &&\n        hasOwn.call(this.policies.rootTypenamesById, dataId)) {\n      return this.policies.rootTypenamesById[dataId];\n    }\n    if (this instanceof Layer) {\n      return this.parent.get(dataId, fieldName);\n    }\n  }\n\n  protected lookup(dataId: string, dependOnExistence?: boolean): StoreObject | undefined {\n    // The has method (above) calls lookup with dependOnExistence = true, so\n    // that it can later be invalidated when we add or remove a StoreObject for\n    // this dataId. Any consumer who cares about the contents of the StoreObject\n    // should not rely on this dependency, since the contents could change\n    // without the object being added or removed.\n    if (dependOnExistence) this.group.depend(dataId, \"__exists\");\n\n    if (hasOwn.call(this.data, dataId)) {\n      return this.data[dataId];\n    }\n\n    if (this instanceof Layer) {\n      return this.parent.lookup(dataId, dependOnExistence);\n    }\n\n    if (this.policies.rootTypenamesById[dataId]) {\n      return Object.create(null);\n    }\n  }\n\n  public merge(\n    older: string | StoreObject,\n    newer: StoreObject | string,\n  ): void {\n    let dataId: string | undefined;\n\n    // Convert unexpected references to ID strings.\n    if (isReference(older)) older = older.__ref;\n    if (isReference(newer)) newer = newer.__ref;\n\n    const existing: StoreObject | undefined =\n      typeof older === \"string\"\n        ? this.lookup(dataId = older)\n        : older;\n\n    const incoming: StoreObject | undefined =\n      typeof newer === \"string\"\n        ? this.lookup(dataId = newer)\n        : newer;\n\n    // If newer was a string ID, but that ID was not defined in this store,\n    // then there are no fields to be merged, so we're done.\n    if (!incoming) return;\n\n    invariant(\n      typeof dataId === \"string\",\n      \"store.merge expects a string ID\",\n    );\n\n    const merged: StoreObject =\n      new DeepMerger(storeObjectReconciler).merge(existing, incoming);\n\n    // Even if merged === existing, existing may have come from a lower\n    // layer, so we always need to set this.data[dataId] on this level.\n    this.data[dataId] = merged;\n\n    if (merged !== existing) {\n      delete this.refs[dataId];\n      if (this.group.caching) {\n        const fieldsToDirty: Record<string, 1> = Object.create(null);\n\n        // If we added a new StoreObject where there was previously none, dirty\n        // anything that depended on the existence of this dataId, such as the\n        // EntityStore#has method.\n        if (!existing) fieldsToDirty.__exists = 1;\n\n        // Now invalidate dependents who called getFieldValue for any fields\n        // that are changing as a result of this merge.\n        Object.keys(incoming).forEach(storeFieldName => {\n          if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {\n            // Always dirty the full storeFieldName, which may include\n            // serialized arguments following the fieldName prefix.\n            fieldsToDirty[storeFieldName] = 1;\n\n            // Also dirty fieldNameFromStoreName(storeFieldName) if it's\n            // different from storeFieldName and this field does not have\n            // keyArgs configured, because that means the cache can't make\n            // any assumptions about how field values with the same field\n            // name but different arguments might be interrelated, so it\n            // must err on the side of invalidating all field values that\n            // share the same short fieldName, regardless of arguments.\n            const fieldName = fieldNameFromStoreName(storeFieldName);\n            if (fieldName !== storeFieldName &&\n                !this.policies.hasKeyArgs(merged.__typename, fieldName)) {\n              fieldsToDirty[fieldName] = 1;\n            }\n\n            // If merged[storeFieldName] has become undefined, and this is the\n            // Root layer, actually delete the property from the merged object,\n            // which is guaranteed to have been created fresh in this method.\n            if (merged[storeFieldName] === void 0 && !(this instanceof Layer)) {\n              delete merged[storeFieldName];\n            }\n          }\n        });\n\n        if (fieldsToDirty.__typename &&\n            !(existing && existing.__typename) &&\n            // Since we return default root __typename strings\n            // automatically from store.get, we don't need to dirty the\n            // ROOT_QUERY.__typename field if merged.__typename is equal\n            // to the default string (usually \"Query\").\n            this.policies.rootTypenamesById[dataId] === merged.__typename) {\n          delete fieldsToDirty.__typename;\n        }\n\n        Object.keys(fieldsToDirty).forEach(\n          fieldName => this.group.dirty(dataId as string, fieldName));\n      }\n    }\n  }\n\n  public modify(\n    dataId: string,\n    fields: Modifier<any> | Modifiers,\n  ): boolean {\n    const storeObject = this.lookup(dataId);\n\n    if (storeObject) {\n      const changedFields: Record<string, any> = Object.create(null);\n      let needToMerge = false;\n      let allDeleted = true;\n\n      const sharedDetails = {\n        DELETE,\n        INVALIDATE,\n        isReference,\n        toReference: this.toReference,\n        canRead: this.canRead,\n        readField: <V = StoreValue>(\n          fieldNameOrOptions: string | ReadFieldOptions,\n          from?: StoreObject | Reference,\n        ) => this.policies.readField<V>(\n          typeof fieldNameOrOptions === \"string\" ? {\n            fieldName: fieldNameOrOptions,\n            from: from || makeReference(dataId),\n          } : fieldNameOrOptions,\n          { store: this },\n        ),\n      };\n\n      Object.keys(storeObject).forEach(storeFieldName => {\n        const fieldName = fieldNameFromStoreName(storeFieldName);\n        let fieldValue = storeObject[storeFieldName];\n        if (fieldValue === void 0) return;\n        const modify: Modifier<StoreValue> = typeof fields === \"function\"\n          ? fields\n          : fields[storeFieldName] || fields[fieldName];\n        if (modify) {\n          let newValue = modify === delModifier ? DELETE :\n            modify(maybeDeepFreeze(fieldValue), {\n              ...sharedDetails,\n              fieldName,\n              storeFieldName,\n              storage: this.getStorage(dataId, storeFieldName),\n            });\n          if (newValue === INVALIDATE) {\n            this.group.dirty(dataId, storeFieldName);\n          } else {\n            if (newValue === DELETE) newValue = void 0;\n            if (newValue !== fieldValue) {\n              changedFields[storeFieldName] = newValue;\n              needToMerge = true;\n              fieldValue = newValue;\n            }\n          }\n        }\n        if (fieldValue !== void 0) {\n          allDeleted = false;\n        }\n      });\n\n      if (needToMerge) {\n        this.merge(dataId, changedFields);\n\n        if (allDeleted) {\n          if (this instanceof Layer) {\n            this.data[dataId] = void 0;\n          } else {\n            delete this.data[dataId];\n          }\n          this.group.dirty(dataId, \"__exists\");\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // If called with only one argument, removes the entire entity\n  // identified by dataId. If called with a fieldName as well, removes all\n  // fields of that entity whose names match fieldName according to the\n  // fieldNameFromStoreName helper function. If called with a fieldName\n  // and variables, removes all fields of that entity whose names match fieldName\n  // and whose arguments when cached exactly match the variables passed.\n  public delete(\n    dataId: string,\n    fieldName?: string,\n    args?: Record<string, any>,\n  ) {\n    const storeObject = this.lookup(dataId);\n    if (storeObject) {\n      const typename = this.getFieldValue<string>(storeObject, \"__typename\");\n      const storeFieldName = fieldName && args\n        ? this.policies.getStoreFieldName({ typename, fieldName, args })\n        : fieldName;\n      return this.modify(dataId, storeFieldName ? {\n        [storeFieldName]: delModifier,\n      } : delModifier);\n    }\n    return false;\n  }\n\n  public evict(\n    options: Cache.EvictOptions,\n    limit: EntityStore,\n  ): boolean {\n    let evicted = false;\n    if (options.id) {\n      if (hasOwn.call(this.data, options.id)) {\n        evicted = this.delete(options.id, options.fieldName, options.args);\n      }\n      if (this instanceof Layer && this !== limit) {\n        evicted = this.parent.evict(options, limit) || evicted;\n      }\n      // Always invalidate the field to trigger rereading of watched\n      // queries, even if no cache data was modified by the eviction,\n      // because queries may depend on computed fields with custom read\n      // functions, whose values are not stored in the EntityStore.\n      if (options.fieldName || evicted) {\n        this.group.dirty(options.id, options.fieldName || \"__exists\");\n      }\n    }\n    return evicted;\n  }\n\n  public clear(): void {\n    this.replace(null);\n  }\n\n  public extract(): NormalizedCacheObject {\n    const obj = this.toObject();\n    const extraRootIds: string[] = [];\n    this.getRootIdSet().forEach(id => {\n      if (!hasOwn.call(this.policies.rootTypenamesById, id)) {\n        extraRootIds.push(id);\n      }\n    });\n    if (extraRootIds.length) {\n      obj.__META = { extraRootIds: extraRootIds.sort() };\n    }\n    return obj;\n  }\n\n  public replace(newData: NormalizedCacheObject | null): void {\n    Object.keys(this.data).forEach(dataId => {\n      if (!(newData && hasOwn.call(newData, dataId))) {\n        this.delete(dataId);\n      }\n    });\n    if (newData) {\n      const { __META, ...rest } = newData;\n      Object.keys(rest).forEach(dataId => {\n        this.merge(dataId, rest[dataId] as StoreObject);\n      });\n      if (__META) {\n        __META.extraRootIds.forEach(this.retain, this);\n      }\n    }\n  }\n\n  public abstract getStorage(\n    idOrObj: string | StoreObject,\n    ...storeFieldNames: (string | number)[]\n  ): StorageType;\n\n  // Maps root entity IDs to the number of times they have been retained, minus\n  // the number of times they have been released. Retained entities keep other\n  // entities they reference (even indirectly) from being garbage collected.\n  private rootIds: {\n    [rootId: string]: number;\n  } = Object.create(null);\n\n  public retain(rootId: string): number {\n    return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;\n  }\n\n  public release(rootId: string): number {\n    if (this.rootIds[rootId] > 0) {\n      const count = --this.rootIds[rootId];\n      if (!count) delete this.rootIds[rootId];\n      return count;\n    }\n    return 0;\n  }\n\n  // Return a Set<string> of all the ID strings that have been retained by\n  // this layer/root *and* any layers/roots beneath it.\n  public getRootIdSet(ids = new Set<string>()) {\n    Object.keys(this.rootIds).forEach(ids.add, ids);\n    if (this instanceof Layer) {\n      this.parent.getRootIdSet(ids);\n    } else {\n      // Official singleton IDs like ROOT_QUERY and ROOT_MUTATION are\n      // always considered roots for garbage collection, regardless of\n      // their retainment counts in this.rootIds.\n      Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);\n    }\n    return ids;\n  }\n\n  // The goal of garbage collection is to remove IDs from the Root layer of the\n  // store that are no longer reachable starting from any IDs that have been\n  // explicitly retained (see retain and release, above). Returns an array of\n  // dataId strings that were removed from the store.\n  public gc() {\n    const ids = this.getRootIdSet();\n    const snapshot = this.toObject();\n    ids.forEach(id => {\n      if (hasOwn.call(snapshot, id)) {\n        // Because we are iterating over an ECMAScript Set, the IDs we add here\n        // will be visited in later iterations of the forEach loop only if they\n        // were not previously contained by the Set.\n        Object.keys(this.findChildRefIds(id)).forEach(ids.add, ids);\n        // By removing IDs from the snapshot object here, we protect them from\n        // getting removed from the root store layer below.\n        delete snapshot[id];\n      }\n    });\n    const idsToRemove = Object.keys(snapshot);\n    if (idsToRemove.length) {\n      let root: EntityStore = this;\n      while (root instanceof Layer) root = root.parent;\n      idsToRemove.forEach(id => root.delete(id));\n    }\n    return idsToRemove;\n  }\n\n  // Lazily tracks { __ref: <dataId> } strings contained by this.data[dataId].\n  private refs: {\n    [dataId: string]: Record<string, true>;\n  } = Object.create(null);\n\n  public findChildRefIds(dataId: string): Record<string, true> {\n    if (!hasOwn.call(this.refs, dataId)) {\n      const found = this.refs[dataId] = Object.create(null);\n      const root = this.data[dataId];\n      if (!root) return found;\n\n      const workSet = new Set<Record<string | number, any>>([root]);\n      // Within the store, only arrays and objects can contain child entity\n      // references, so we can prune the traversal using this predicate:\n      workSet.forEach(obj => {\n        if (isReference(obj)) {\n          found[obj.__ref] = true;\n          // In rare cases, a { __ref } Reference object may have other fields.\n          // This often indicates a mismerging of References with StoreObjects,\n          // but garbage collection should not be fooled by a stray __ref\n          // property in a StoreObject (ignoring all the other fields just\n          // because the StoreObject looks like a Reference). To avoid this\n          // premature termination of findChildRefIds recursion, we fall through\n          // to the code below, which will handle any other properties of obj.\n        }\n        if (isNonNullObject(obj)) {\n          Object.keys(obj).forEach(key => {\n            const child = obj[key];\n            // No need to add primitive values to the workSet, since they cannot\n            // contain reference objects.\n            if (isNonNullObject(child)) {\n              workSet.add(child);\n            }\n          });\n        }\n      });\n    }\n    return this.refs[dataId];\n  }\n\n  // Used to compute cache keys specific to this.group.\n  public makeCacheKey(...args: any[]): object;\n  public makeCacheKey() {\n    return this.group.keyMaker.lookupArray(arguments);\n  }\n\n  // Bound function that can be passed around to provide easy access to fields\n  // of Reference objects as well as ordinary objects.\n  public getFieldValue = <T = StoreValue>(\n    objectOrReference: StoreObject | Reference | undefined,\n    storeFieldName: string,\n  ) => maybeDeepFreeze(\n    isReference(objectOrReference)\n      ? this.get(objectOrReference.__ref, storeFieldName)\n      : objectOrReference && objectOrReference[storeFieldName]\n  ) as SafeReadonly<T>;\n\n  // Returns true for non-normalized StoreObjects and non-dangling\n  // References, indicating that readField(name, objOrRef) has a chance of\n  // working. Useful for filtering out dangling references from lists.\n  public canRead: CanReadFunction = objOrRef => {\n    return isReference(objOrRef)\n      ? this.has(objOrRef.__ref)\n      : typeof objOrRef === \"object\";\n  };\n\n  // Bound function that converts an id or an object with a __typename and\n  // primary key fields to a Reference object. If called with a Reference object,\n  // that same Reference object is returned. Pass true for mergeIntoStore to persist\n  // an object into the store.\n  public toReference: ToReferenceFunction = (\n    objOrIdOrRef,\n    mergeIntoStore,\n  ) => {\n    if (typeof objOrIdOrRef === \"string\") {\n      return makeReference(objOrIdOrRef);\n    }\n\n    if (isReference(objOrIdOrRef)) {\n      return objOrIdOrRef;\n    }\n\n    const [id] = this.policies.identify(objOrIdOrRef);\n\n    if (id) {\n      const ref = makeReference(id);\n      if (mergeIntoStore) {\n        this.merge(id, objOrIdOrRef);\n      }\n      return ref;\n    }\n  };\n}\n\nexport type FieldValueGetter = EntityStore[\"getFieldValue\"];\n\n// A single CacheGroup represents a set of one or more EntityStore objects,\n// typically the Root store in a CacheGroup by itself, and all active Layer\n// stores in a group together. A single EntityStore object belongs to only\n// one CacheGroup, store.group. The CacheGroup is responsible for tracking\n// dependencies, so store.group is helpful for generating unique keys for\n// cached results that need to be invalidated when/if those dependencies\n// change. If we used the EntityStore objects themselves as cache keys (that\n// is, store rather than store.group), the cache would become unnecessarily\n// fragmented by all the different Layer objects. Instead, the CacheGroup\n// approach allows all optimistic Layer objects in the same linked list to\n// belong to one CacheGroup, with the non-optimistic Root object belonging\n// to another CacheGroup, allowing resultCaching dependencies to be tracked\n// separately for optimistic and non-optimistic entity data.\nclass CacheGroup {\n  private d: OptimisticDependencyFunction<string> | null = null;\n\n  // Used by the EntityStore#makeCacheKey method to compute cache keys\n  // specific to this CacheGroup.\n  public keyMaker: Trie<object>;\n\n  constructor(\n    public readonly caching: boolean,\n    private parent: CacheGroup | null = null,\n  ) {\n    this.resetCaching();\n  }\n\n  public resetCaching() {\n    this.d = this.caching ? dep<string>() : null;\n    this.keyMaker = new Trie(canUseWeakMap);\n  }\n\n  public depend(dataId: string, storeFieldName: string) {\n    if (this.d) {\n      this.d(makeDepKey(dataId, storeFieldName));\n      const fieldName = fieldNameFromStoreName(storeFieldName);\n      if (fieldName !== storeFieldName) {\n        // Fields with arguments that contribute extra identifying\n        // information to the fieldName (thus forming the storeFieldName)\n        // depend not only on the full storeFieldName but also on the\n        // short fieldName, so the field can be invalidated using either\n        // level of specificity.\n        this.d(makeDepKey(dataId, fieldName));\n      }\n      if (this.parent) {\n        this.parent.depend(dataId, storeFieldName);\n      }\n    }\n  }\n\n  public dirty(dataId: string, storeFieldName: string) {\n    if (this.d) {\n      this.d.dirty(\n        makeDepKey(dataId, storeFieldName),\n        // When storeFieldName === \"__exists\", that means the entity identified\n        // by dataId has either disappeared from the cache or was newly added,\n        // so the result caching system would do well to \"forget everything it\n        // knows\" about that object. To achieve that kind of invalidation, we\n        // not only dirty the associated result cache entry, but also remove it\n        // completely from the dependency graph. For the optimism implementation\n        // details, see https://github.com/benjamn/optimism/pull/195.\n        storeFieldName === \"__exists\" ? \"forget\" : \"setDirty\",\n      );\n    }\n  }\n}\n\nfunction makeDepKey(dataId: string, storeFieldName: string) {\n  // Since field names cannot have '#' characters in them, this method\n  // of joining the field name and the ID should be unambiguous, and much\n  // cheaper than JSON.stringify([dataId, fieldName]).\n  return storeFieldName + '#' + dataId;\n}\n\nexport function maybeDependOnExistenceOfEntity(\n  store: NormalizedCache,\n  entityId: string,\n) {\n  if (supportsResultCaching(store)) {\n    // We use this pseudo-field __exists elsewhere in the EntityStore code to\n    // represent changes in the existence of the entity object identified by\n    // entityId. This dependency gets reliably dirtied whenever an object with\n    // this ID is deleted (or newly created) within this group, so any result\n    // cache entries (for example, StoreReader#executeSelectionSet results) that\n    // depend on __exists for this entityId will get dirtied as well, leading to\n    // the eventual recomputation (instead of reuse) of those result objects the\n    // next time someone reads them from the cache.\n    store.group.depend(entityId, \"__exists\");\n  }\n}\n\nexport namespace EntityStore {\n  // Refer to this class as EntityStore.Root outside this namespace.\n  export class Root extends EntityStore {\n    constructor({\n      policies,\n      resultCaching = true,\n      seed,\n    }: {\n      policies: Policies;\n      resultCaching?: boolean;\n      seed?: NormalizedCacheObject;\n    }) {\n      super(policies, new CacheGroup(resultCaching));\n      if (seed) this.replace(seed);\n    }\n\n    public readonly stump = new Stump(this);\n\n    public addLayer(\n      layerId: string,\n      replay: (layer: EntityStore) => any,\n    ): Layer {\n      // Adding an optimistic Layer on top of the Root actually adds the Layer\n      // on top of the Stump, so the Stump always comes between the Root and\n      // any Layer objects that we've added.\n      return this.stump.addLayer(layerId, replay);\n    }\n\n    public removeLayer(): Root {\n      // Never remove the root layer.\n      return this;\n    }\n\n    public readonly storageTrie = new Trie<StorageType>(canUseWeakMap);\n    public getStorage(): StorageType {\n      return this.storageTrie.lookupArray(arguments);\n    }\n  }\n}\n\n// Not exported, since all Layer instances are created by the addLayer method\n// of the EntityStore.Root class.\nclass Layer extends EntityStore {\n  constructor(\n    public readonly id: string,\n    public readonly parent: EntityStore,\n    public readonly replay: (layer: EntityStore) => any,\n    public readonly group: CacheGroup,\n  ) {\n    super(parent.policies, group);\n    replay(this);\n  }\n\n  public addLayer(\n    layerId: string,\n    replay: (layer: EntityStore) => any,\n  ): Layer {\n    return new Layer(layerId, this, replay, this.group);\n  }\n\n  public removeLayer(layerId: string): EntityStore {\n    // Remove all instances of the given id, not just the first one.\n    const parent = this.parent.removeLayer(layerId);\n\n    if (layerId === this.id) {\n      if (this.group.caching) {\n        // Dirty every ID we're removing. Technically we might be able to avoid\n        // dirtying fields that have values in higher layers, but we don't have\n        // easy access to higher layers here, and we're about to recreate those\n        // layers anyway (see parent.addLayer below).\n        Object.keys(this.data).forEach(dataId => {\n          const ownStoreObject = this.data[dataId];\n          const parentStoreObject = parent[\"lookup\"](dataId);\n          if (!parentStoreObject) {\n            // The StoreObject identified by dataId was defined in this layer\n            // but will be undefined in the parent layer, so we can delete the\n            // whole entity using this.delete(dataId). Since we're about to\n            // throw this layer away, the only goal of this deletion is to dirty\n            // the removed fields.\n            this.delete(dataId);\n          } else if (!ownStoreObject) {\n            // This layer had an entry for dataId but it was undefined, which\n            // means the entity was deleted in this layer, and it's about to\n            // become undeleted when we remove this layer, so we need to dirty\n            // all fields that are about to be reexposed.\n            this.group.dirty(dataId, \"__exists\");\n            Object.keys(parentStoreObject).forEach(storeFieldName => {\n              this.group.dirty(dataId, storeFieldName);\n            });\n          } else if (ownStoreObject !== parentStoreObject) {\n            // If ownStoreObject is not exactly the same as parentStoreObject,\n            // dirty any fields whose values will change as a result of this\n            // removal.\n            Object.keys(ownStoreObject).forEach(storeFieldName => {\n              if (!equal(ownStoreObject[storeFieldName],\n                         parentStoreObject[storeFieldName])) {\n                this.group.dirty(dataId, storeFieldName);\n              }\n            });\n          }\n        });\n      }\n\n      return parent;\n    }\n\n    // No changes are necessary if the parent chain remains identical.\n    if (parent === this.parent) return this;\n\n    // Recreate this layer on top of the new parent.\n    return parent.addLayer(this.id, this.replay);\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return {\n      ...this.parent.toObject(),\n      ...this.data,\n    };\n  }\n\n  public findChildRefIds(dataId: string): Record<string, true> {\n    const fromParent = this.parent.findChildRefIds(dataId);\n    return hasOwn.call(this.data, dataId) ? {\n      ...fromParent,\n      ...super.findChildRefIds(dataId),\n    } : fromParent;\n  }\n\n  public getStorage(): StorageType {\n    let p: EntityStore = this.parent;\n    while ((p as Layer).parent) p = (p as Layer).parent;\n    return p.getStorage.apply(p, arguments);\n  }\n}\n\n// Represents a Layer permanently installed just above the Root, which allows\n// reading optimistically (and registering optimistic dependencies) even when\n// no optimistic layers are currently active. The stump.group CacheGroup object\n// is shared by any/all Layer objects added on top of the Stump.\nclass Stump extends Layer {\n  constructor(root: EntityStore.Root) {\n    super(\n      \"EntityStore.Stump\",\n      root,\n      () => {},\n      new CacheGroup(root.group.caching, root.group),\n    );\n  }\n\n  public removeLayer() {\n    // Never remove the Stump layer.\n    return this;\n  }\n\n  public merge() {\n    // We never want to write any data into the Stump, so we forward any merge\n    // calls to the Root instead. Another option here would be to throw an\n    // exception, but the toReference(object, true) function can sometimes\n    // trigger Stump writes (which used to be Root writes, before the Stump\n    // concept was introduced).\n    return this.parent.merge.apply(this.parent, arguments);\n  }\n}\n\nfunction storeObjectReconciler(\n  existingObject: StoreObject,\n  incomingObject: StoreObject,\n  property: string,\n): StoreValue {\n  const existingValue = existingObject[property];\n  const incomingValue = incomingObject[property];\n  // Wherever there is a key collision, prefer the incoming value, unless\n  // it is deeply equal to the existing value. It's worth checking deep\n  // equality here (even though blindly returning incoming would be\n  // logically correct) because preserving the referential identity of\n  // existing data can prevent needless rereading and rerendering.\n  return equal(existingValue, incomingValue) ? existingValue : incomingValue;\n}\n\nexport function supportsResultCaching(store: any): store is EntityStore {\n  // When result caching is disabled, store.depend will be null.\n  return !!(store instanceof EntityStore && store.group.caching);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}