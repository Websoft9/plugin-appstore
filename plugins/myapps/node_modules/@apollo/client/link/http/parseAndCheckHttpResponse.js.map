{"version":3,"file":"parseAndCheckHttpResponse.js","sourceRoot":"","sources":["../../../src/link/http/parseAndCheckHttpResponse.ts"],"names":[],"mappings":"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","sourcesContent":["import { responseIterator } from \"./responseIterator\";\nimport { Operation } from \"../core\";\nimport { throwServerError } from \"../utils\";\nimport { PROTOCOL_ERRORS_SYMBOL } from '../../errors';\nimport { Observer } from \"../../utilities\";\nimport {\n  isApolloPayloadResult\n} from '../../utilities/common/incrementalResult';\n\nconst { hasOwnProperty } = Object.prototype;\n\nexport type ServerParseError = Error & {\n  response: Response;\n  statusCode: number;\n  bodyText: string;\n};\n\nexport async function readMultipartBody<\n  T extends object = Record<string, unknown>\n>(response: Response, observer: Observer<T>) {\n  if (TextDecoder === undefined) {\n    throw new Error(\n      \"TextDecoder must be defined in the environment: please import a polyfill.\"\n    );\n  }\n  const decoder = new TextDecoder(\"utf-8\");\n  const contentType = response.headers?.get(\"content-type\");\n  const delimiter = \"boundary=\";\n\n  // parse boundary value and ignore any subsequent name/value pairs after ;\n  // https://www.rfc-editor.org/rfc/rfc9110.html#name-parameters\n  // e.g. multipart/mixed;boundary=\"graphql\";deferSpec=20220824\n  // if no boundary is specified, default to -\n  const boundaryVal = contentType?.includes(delimiter)\n    ? contentType\n        ?.substring(contentType?.indexOf(delimiter) + delimiter.length)\n        .replace(/['\"]/g, \"\")\n        .replace(/\\;(.*)/gm, \"\")\n        .trim()\n    : \"-\";\n\n  const boundary = `\\r\\n--${boundaryVal}`;\n  let buffer = \"\";\n  const iterator = responseIterator(response);\n  let running = true;\n\n  while (running) {\n    const { value, done } = await iterator.next();\n    const chunk = typeof value === \"string\" ? value : decoder.decode(value);\n    const searchFrom = buffer.length - boundary.length + 1;\n    running = !done;\n    buffer += chunk;\n    let bi = buffer.indexOf(boundary, searchFrom);\n\n    while (bi > -1) {\n      let message: string;\n      [message, buffer] = [\n        buffer.slice(0, bi),\n        buffer.slice(bi + boundary.length),\n      ];\n      const i = message.indexOf(\"\\r\\n\\r\\n\");\n      const headers = parseHeaders(message.slice(0, i));\n      const contentType = headers[\"content-type\"];\n      if (\n        contentType &&\n        contentType.toLowerCase().indexOf(\"application/json\") === -1\n      ) {\n        throw new Error(\n          \"Unsupported patch content type: application/json is required.\"\n        );\n      }\n      // nb: Technically you'd want to slice off the beginning \"\\r\\n\" but since\n      // this is going to be `JSON.parse`d there is no need.\n      const body = message.slice(i);\n\n      if (body) {\n        try {\n          const result = parseJsonBody<T>(response, body);\n          if (\n            Object.keys(result).length > 1 ||\n            \"data\" in result ||\n            \"incremental\" in result ||\n            \"errors\" in result ||\n            \"payload\" in result\n          ) {\n            if (isApolloPayloadResult(result)) {\n              let next = {};\n              if (\"payload\" in result) {\n                next = { ...result.payload };\n              }\n              if (\"errors\" in result) {\n                next = {\n                  ...next,\n                  extensions: {\n                    ...(\"extensions\" in next ? next.extensions : null as any),\n                    [PROTOCOL_ERRORS_SYMBOL]: result.errors\n                  },\n                };\n              }\n              observer.next?.(next as T);\n            } else {\n              // for the last chunk with only `hasNext: false`\n              // we don't need to call observer.next as there is no data/errors\n              observer.next?.(result);\n            }\n          } else if (\n            // If the chunk contains only a \"hasNext: false\", we can call\n            // observer.complete() immediately.\n            Object.keys(result).length === 1 &&\n            \"hasNext\" in result &&\n            !result.hasNext\n          ) {\n            observer.complete?.();\n          }\n        } catch (err) {\n          handleError(err, observer);\n        }\n      }\n      bi = buffer.indexOf(boundary);\n    }\n  }\n  observer.complete?.();\n}\n\nexport function parseHeaders(headerText: string): Record<string, string> {\n  const headersInit: Record<string, string> = {};\n  headerText.split(\"\\n\").forEach((line) => {\n    const i = line.indexOf(\":\");\n    if (i > -1) {\n      // normalize headers to lowercase\n      const name = line.slice(0, i).trim().toLowerCase();\n      const value = line.slice(i + 1).trim();\n      headersInit[name] = value;\n    }\n  });\n  return headersInit;\n}\n\nexport function parseJsonBody<T>(response: Response, bodyText: string): T {\n  if (response.status >= 300) {\n    // Network error\n    const getResult = (): Record<string, unknown> | string => {\n      try {\n        return JSON.parse(bodyText);\n      } catch (err) {\n        return bodyText;\n      }\n    };\n    throwServerError(\n      response,\n      getResult(),\n      `Response not successful: Received status code ${response.status}`\n    );\n  }\n\n  try {\n    return JSON.parse(bodyText) as T;\n  } catch (err) {\n    const parseError = err as ServerParseError;\n    parseError.name = \"ServerParseError\";\n    parseError.response = response;\n    parseError.statusCode = response.status;\n    parseError.bodyText = bodyText;\n    throw parseError;\n  }\n}\n\nexport function handleError(err: any, observer: Observer<any>) {\n  if (err.name === \"AbortError\") return;\n  // if it is a network error, BUT there is graphql result info fire\n  // the next observer before calling error this gives apollo-client\n  // (and react-apollo) the `graphqlErrors` and `networkErrors` to\n  // pass to UI this should only happen if we *also* have data as\n  // part of the response key per the spec\n  if (err.result && err.result.errors && err.result.data) {\n    // if we don't call next, the UI can only show networkError\n    // because AC didn't get any graphqlErrors this is graphql\n    // execution result info (i.e errors and possibly data) this is\n    // because there is no formal spec how errors should translate to\n    // http status codes. So an auth error (401) could have both data\n    // from a public field, errors from a private field, and a status\n    // of 401\n    // {\n    //  user { // this will have errors\n    //    firstName\n    //  }\n    //  products { // this is public so will have data\n    //    cost\n    //  }\n    // }\n    //\n    // the result of above *could* look like this:\n    // {\n    //   data: { products: [{ cost: \"$10\" }] },\n    //   errors: [{\n    //      message: 'your session has timed out',\n    //      path: []\n    //   }]\n    // }\n    // status code of above would be a 401\n    // in the UI you want to show data where you can, errors as data where you can\n    // and use correct http status codes\n    observer.next?.(err.result);\n  }\n\n  observer.error?.(err);\n}\n\nexport function readJsonBody<T = Record<string, unknown>>(\n  response: Response,\n  operation: Operation,\n  observer: Observer<T>\n) {\n  parseAndCheckHttpResponse(operation)(response)\n    .then((result) => {\n      observer.next?.(result);\n      observer.complete?.();\n    })\n    .catch((err) => handleError(err, observer));\n}\n\nexport function parseAndCheckHttpResponse(operations: Operation | Operation[]) {\n  return (response: Response) =>\n    response\n      .text()\n      .then((bodyText) => parseJsonBody(response, bodyText))\n      .then((result: any) => {\n        if (response.status >= 300) {\n          // Network error\n          throwServerError(\n            response,\n            result,\n            `Response not successful: Received status code ${response.status}`\n          );\n        }\n        if (\n          !Array.isArray(result) &&\n          !hasOwnProperty.call(result, \"data\") &&\n          !hasOwnProperty.call(result, \"errors\")\n        ) {\n          // Data error\n          throwServerError(\n            response,\n            result,\n            `Server response was missing for query '${\n              Array.isArray(operations)\n                ? operations.map((op) => op.operationName)\n                : operations.operationName\n            }'.`\n          );\n        }\n        return result;\n      });\n}\n"]}